{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"node_modules/hexo-theme-Aurora/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/icons/favicon-16x16.png","path":"icons/favicon-16x16.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/icons/favicon-32x32.png","path":"icons/favicon-32x32.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/404.1a6cd5bd.css","path":"static/css/404.1a6cd5bd.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/about.32dfa3b0.css","path":"static/css/about.32dfa3b0.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/app.0d31776f.css","path":"static/css/app.0d31776f.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/archives.c0d49bd5.css","path":"static/css/archives.c0d49bd5.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/categories.10e2be12.css","path":"static/css/categories.10e2be12.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/chunk-libs.eebac533.css","path":"static/css/chunk-libs.eebac533.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/page.749ad047.css","path":"static/css/page.749ad047.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/post.9f951a60.css","path":"static/css/post.9f951a60.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/result.10e2be12.css","path":"static/css/result.10e2be12.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/tags.10e2be12.css","path":"static/css/tags.10e2be12.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/img/default-cover.df7c128c.jpg","path":"static/img/default-cover.df7c128c.jpg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/404.00d640a8.js","path":"static/js/404.00d640a8.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/app.6d2c358d.js","path":"static/js/app.6d2c358d.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/about.024aacd1.js","path":"static/js/about.024aacd1.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/archives.574ac664.js","path":"static/js/archives.574ac664.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/categories.90aa5475.js","path":"static/js/categories.90aa5475.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/chunk-libs.dc6146cd.js","path":"static/js/chunk-libs.dc6146cd.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/page.a02618ad.js","path":"static/js/page.a02618ad.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/post.cebfbaa4.js","path":"static/js/post.cebfbaa4.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/result.39470350.js","path":"static/js/result.39470350.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/tags.2ad613f5.js","path":"static/js/tags.2ad613f5.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"83c679868a95497228d71a2df4ebbfdabdd1b61c","modified":1672898573616},{"_id":"source/about/index.md","hash":"b2ea07876b524191ee963194c9da39f89dc270f6","modified":1672736543279},{"_id":"source/_posts/centos/centos镜像.md","hash":"82048de7cddbbe577f8d15d1821d048b6e22efb3","modified":1673340886932},{"_id":"source/_posts/docker/Docker 容器的使用.md","hash":"31e8f72b69f8421e75ae0bae207433d68fb2426a","modified":1672736543277},{"_id":"source/_posts/docker/Docker 容器连接.md","hash":"e0df5090709c17423e02f16289001d55a625d064","modified":1672736543277},{"_id":"source/_posts/docker/Docker 镜像的使用.md","hash":"4ce77fa74aaab20d6748cfe98652414d856434a9","modified":1672736543278},{"_id":"source/_posts/typescript/tsconfig.json 编译配置.md","hash":"18b84b5c1ec9b429773306d2a7adf3b5bfcc1d26","modified":1672736543279},{"_id":"source/_posts/typescript/TypeScript的数据类型.md","hash":"dbc0804fed31313b245c7fa52af3c37d7e3ec188","modified":1672736543278},{"_id":"source/_posts/typescript/webpack 搭建 ts 开发环境.md","hash":"22afc784be731b9373410a7819c30dcb4c87f29e","modified":1672736543279},{"_id":"source/_posts/typescript/基础/内置对象.md","hash":"390148152c54e59b7c37a60866a1041200a79952","modified":1673340597884},{"_id":"source/_posts/typescript/基础/任意值.md","hash":"529aef3cbde49afe13d0d6a0b0a62880dc67ba6c","modified":1672905236019},{"_id":"source/_posts/typescript/基础/函数的类型.md","hash":"03d3f6ffd4f4bb76c9ca5bed74f2f0bfcbda7890","modified":1673332591425},{"_id":"source/_posts/typescript/基础/原始数据类型.md","hash":"fe3adc8fba22c5ba44b27cb32ba3c8233de0e4f6","modified":1672905251780},{"_id":"source/_posts/typescript/基础/基础.md","hash":"e11ad9f327abb91cbb2b6fecc648693180bb6500","modified":1672905246832},{"_id":"source/_posts/typescript/基础/声明文件.md","hash":"a3d482882286afd1c0a21afd98e6385f9d5d9ab1","modified":1673339948180},{"_id":"source/_posts/typescript/基础/对象的类型——接口.md","hash":"6e4190a4a910644b4fdf61467649a8b8fffade94","modified":1672986945981},{"_id":"source/_posts/typescript/基础/数组的类型.md","hash":"6ffce96533aeede8c2cfdedffaaf2a99aa6ee63a","modified":1672912864290},{"_id":"source/_posts/typescript/基础/类型推论.md","hash":"adbf44804e8b0c05c5b9ae62ed8ba8dc29a6bf27","modified":1672905878377},{"_id":"source/_posts/typescript/基础/类型断言.md","hash":"4f17296f3a8034f934dc0e4a1b608d33744a11d4","modified":1673251284690},{"_id":"source/_posts/typescript/基础/联合类型.md","hash":"a907483c4c069ab18b1c4733c9a13bacfe99962e","modified":1672906320078},{"_id":"node_modules/hexo-theme-Aurora/.browserslistrc","hash":"db215b841182d2af3259a1c1d6e1957bca333970","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/CHANGELOG.md","hash":"e68f3af8af17d326a48e1b317e01d7429193217e","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/CHANGELOG_CN.md","hash":"5d13c251e8b77fd86870da50f3be98f8822edc66","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/LICENSE","hash":"21cf269018b0cf04e1126b6b9b1a5e6af7c5e61f","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/README.md","hash":"c50f58b08b75780990c18ab85761e3e24aac0d90","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/_config.yml","hash":"e6b2335cb393444b8a1fc1ad65331f4a30bc8915","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/jest.config.js","hash":"425f08cb718a56630ce61ae0686f35c55ef565df","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/package.json","hash":"1b312a6a2de107ba9dc952614f1078c78664a4e4","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/data/cn.yml","hash":"4f5dcc1e2953df7a8e4e683c1a9115f6e0041f5e","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/.circleci/config.yml","hash":"534051be311581f69aa8287120275a04539290e4","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/data/en.yml","hash":"7bbd6c0da0ae2f93f8a786a3be77fbe4e95a787e","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/index.js","hash":"2a3c62a860581ee6813ca4bcaa7c952f614e818c","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/layout/index.ejs","hash":"94732830a65b718d2fa506b8598df44f14399fd8","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/favicon.ico","hash":"c39d3ad80489cffed0d3df82c8cb05a049ab39a3","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/icons/favicon-16x16.png","hash":"849cad2a5ae49fa54c20372f7a21ae95192bafcf","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/filters/index.js","hash":"5eacff9446dd6c9a7eb0a0c84be9187055440454","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/icons/favicon-32x32.png","hash":"9dbabf6f4d825da99dcb2e91583755ae8d3b3ff4","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/category.js","hash":"0ae21ffcf6e471ebfb72ac62a833991fae86ec8a","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/index.js","hash":"dfbb0fdbf990bd67684ed891a4aaa1fd8dcd23f2","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/page.js","hash":"1be54ea9cdf8e293e67bf457075fcdd8a72b8779","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/post.js","hash":"76c3268e8b6887fb1fd11c4d71004aad9dc215fc","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/site.js","hash":"b5f5ce813b4b0b322eceb11b036dc65201604256","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/search.js","hash":"a2a636e1df76efdcaca37226b490afa539ce766b","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/statistic.js","hash":"1c641956e15cec96490de16a88ccc7bec0c9d5c4","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/tag.js","hash":"975e79e73d2503a33dbc63655b948100cc46d44f","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/helpers/mapper.js","hash":"7a99508d910321b90b4afa0df02ad90f62336901","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/helpers/symbols-count-time.js","hash":"d1a81e31b2988edcdf4b4761cec7326a980f097a","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/helpers/toc.js","hash":"5c7348c550ef7f164d492847801a360cdefc60a2","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/helpers/truncate-html.js","hash":"49d4832af027eabe5b8383a24e66dceae761533e","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/helpers/utils.js","hash":"93ff75f0e35a1dc40d5406cc097f5988dd820600","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/injector/index.js","hash":"7ca562ea3af3068ee925b5a8afdce0eaa1e15e64","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/about.32dfa3b0.css","hash":"614ef7c4e52877c76ffddb26192bf8fffddcb8d8","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/404.1a6cd5bd.css","hash":"a7a4d83756520d8f6c410ac0ffe9a45d63868113","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/archives.c0d49bd5.css","hash":"c56213315c57254d0a6e6301ef24c2186fef4d2b","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/categories.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/chunk-libs.eebac533.css","hash":"41226b6c29aadcc6190fe7c2c4c37464855b8453","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/page.749ad047.css","hash":"6fcf0e6f3c628954c5f8105791e0e7f3e6512da6","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/post.9f951a60.css","hash":"8e360582d745d6483fdfc18c46f75897b44721a6","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/result.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/tags.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/img/default-cover.df7c128c.jpg","hash":"1934ace0c6f2397d15729f9b08cc4d42e45bf437","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/404.00d640a8.js","hash":"74f1da9e0f953e73e4fe1a6554433f56fdcdf54d","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/about.024aacd1.js","hash":"7ce2b3f7d232dd3b3930ac993bb841452e2cde89","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/archives.574ac664.js","hash":"fbb094fb4f7a01bffd6975aca27142935bfdca73","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/categories.90aa5475.js","hash":"0dde3d731fc665962a4c330338a2c663c330be26","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/page.a02618ad.js","hash":"db775fbfbaa1cf8bbf4cc4f2b0a869519d508e3a","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/post.cebfbaa4.js","hash":"53586f9dab5886a366e9397eb17088e74af5cde1","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/tags.2ad613f5.js","hash":"4f49139e435788710115fc884dc26a5b1e0d4833","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/result.39470350.js","hash":"f6f5ab2ca7274dad169ec600a419d1a2aeb2347c","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/app.0d31776f.css","hash":"43b43acd76bd8dc22f34cc49c7e026c45c3a5004","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/app.6d2c358d.js","hash":"e176c20c22ce36e38935f463977e9b89b281c715","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/chunk-libs.dc6146cd.js","hash":"534266637d09abf39278f4d3a21bd36728740105","modified":1672726126472},{"_id":"public/api/posts/2.json","hash":"8a4a132c649fd48e31fbe6e51fa1b56ea782af64","modified":1673341261237},{"_id":"public/api/posts/1.json","hash":"4a496d3a5ac98ad62474dbd23d0fa1b88c1a9751","modified":1673341261237},{"_id":"public/api/articles/typescript/基础/内置对象.json","hash":"12c285e0e7f6475a154b6923166851ac83199aaf","modified":1673341261237},{"_id":"public/api/articles/typescript/基础/声明文件.json","hash":"c81fb9d96ddb193806ceef3ef0cc9dcfe1b73f09","modified":1673341261237},{"_id":"public/api/articles/centos/centos镜像.json","hash":"8d2d7364545a65ed5fa635c3359ecfd12fa6cfc9","modified":1673341261237},{"_id":"public/api/articles/typescript/基础/类型断言.json","hash":"00cd4657482658cb726b831dff9391fb95f3b78c","modified":1673341261237},{"_id":"public/api/articles/typescript/基础/函数的类型.json","hash":"a794376e88d11fe75bab719832e5fd2fe7b97b4b","modified":1673341261237},{"_id":"public/api/articles/typescript/基础/数组的类型.json","hash":"22efbf39fa17f35a4a7aafcaebd024739f4fb8af","modified":1673341261237},{"_id":"public/api/articles/typescript/基础/对象的类型——接口.json","hash":"2363c9ac9b5caec54be5ad408f15452526971b87","modified":1673341261237},{"_id":"public/api/articles/typescript/基础/联合类型.json","hash":"444709c02bbe37c8c6dad722032313235da0adba","modified":1673341261237},{"_id":"public/api/articles/typescript/基础/类型推论.json","hash":"c5448b065c65c01bb58204b2d41c3978900aa8c2","modified":1673341261237},{"_id":"public/api/articles/typescript/基础/任意值.json","hash":"b9d1d6925a9f15b6e13ac96756075992f4451098","modified":1673341261237},{"_id":"public/api/articles/typescript/基础/基础.json","hash":"e54516e9a119b8806b87342a166d1e9ce32e6012","modified":1673341261237},{"_id":"public/api/articles/typescript/基础/原始数据类型.json","hash":"f5108e646c7609b3e6cf78afb76931f89bfe9a97","modified":1673341261237},{"_id":"public/api/articles/docker/Docker 镜像的使用.json","hash":"9b908ef8e7b61ccd2c933df861354faff1e0efdf","modified":1673341261237},{"_id":"public/api/articles/docker/Docker 容器连接.json","hash":"39252b931227ec50a4dc04d1e72ae27c3fa064a7","modified":1673341261237},{"_id":"public/api/articles/docker/Docker 容器的使用.json","hash":"27d5acf16d9ca7b19b85c1b2d06ebbdbf7bd297e","modified":1673341261237},{"_id":"public/api/articles/typescript/webpack 搭建 ts 开发环境.json","hash":"e7550d382b682a0abaa4256b5a782d1ad1c0c391","modified":1673341261237},{"_id":"public/api/articles/typescript/TypeScript的数据类型.json","hash":"2c1bcc516adfdb29622bad42dc5837bc2fce27fe","modified":1673341261237},{"_id":"public/api/articles/typescript/tsconfig.json 编译配置.json","hash":"e57a0abd5035a031eb3d0757ae654baf70adac4f","modified":1673341261237},{"_id":"public/api/features.json","hash":"ecdfa3339d81caf4a4919327495cf0b9824394e2","modified":1673341261237},{"_id":"public/api/authors/blog-author.json","hash":"540e00c52897ac3ad9e36ba17c59bb31105a083a","modified":1673341261237},{"_id":"public/api/site.json","hash":"aebe497ecb9ec2ec7b0683d80e18bda9f9564ac6","modified":1673341261237},{"_id":"public/api/categories.json","hash":"8a3db39b1f75f2063b8036a738c4ab4627f302d4","modified":1673341261237},{"_id":"public/api/categories/Centos.json","hash":"a225e8a46278fe494243278bbfa925eb57eb77cf","modified":1673341261237},{"_id":"public/api/categories/Docker.json","hash":"67c65622fdb4b7cb790d06a32e5451080c71010f","modified":1673341261237},{"_id":"public/api/categories/TypeScript.json","hash":"eb057b81105c53210d44cd90d418f406ca8aa2f6","modified":1673341261237},{"_id":"public/api/tags/Centos.json","hash":"a225e8a46278fe494243278bbfa925eb57eb77cf","modified":1673341261237},{"_id":"public/api/tags.json","hash":"d08036cccdbacd00c2c573204c2946609c2258d0","modified":1673341261237},{"_id":"public/api/categories/TypeScript入门.json","hash":"d4c8f92de7b513f250f6c0a1ea153022475e87fb","modified":1673341261237},{"_id":"public/api/tags/镜像.json","hash":"e4c87ea10795704889844ed17c76a8afcb1ec3cd","modified":1673341261237},{"_id":"public/api/tags/Docker.json","hash":"67c65622fdb4b7cb790d06a32e5451080c71010f","modified":1673341261237},{"_id":"public/api/tags/容器.json","hash":"c7f947a3a5e92326dd05d2ae0c473e49ff885889","modified":1673341261237},{"_id":"public/api/tags/container.json","hash":"848ebe23d317d59cff7e684ea69e755dfa0d7349","modified":1673341261237},{"_id":"public/api/tags/images.json","hash":"d68b7869363c10e94db7c70ee4dd9f818c86e18e","modified":1673341261237},{"_id":"public/api/tags/TypeScript.json","hash":"3a594ae7562adcf5e3e5258639b2f253c45c1efb","modified":1673341261237},{"_id":"public/api/tags/tsconfig.json","hash":"64cca60802ba1dd118b32500f88b3929bbf46da0","modified":1673341261237},{"_id":"public/api/tags/数据类型.json","hash":"83b614277197502711f82aef0f440fc1e1c2943a","modified":1673341261237},{"_id":"public/api/tags/环境搭建.json","hash":"69a6201de0abc20ac00eef8eb8693883f64e1c89","modified":1673341261237},{"_id":"public/api/tags/webpack.json","hash":"e443ea26d18678c195ba6e98c4dd2893732da92f","modified":1673341261237},{"_id":"public/api/tags/基础.json","hash":"4a652da73f84882cf0d1dc0ea3b06761d9c88c91","modified":1673341261237},{"_id":"public/api/tags/类型.json","hash":"d1721f17cf4811ade6d0b25b0a31e0cdf3964fab","modified":1673341261237},{"_id":"public/api/tags/函数.json","hash":"38896d576c61dd278b7c06bf3b62b018081c002f","modified":1673341261237},{"_id":"public/api/tags/数组.json","hash":"edb307d40f9cd1bdba2556772681ba6a39894cbe","modified":1673341261237},{"_id":"public/api/pages/about/index.json","hash":"30874f92cc0dbd6d6a02f1d5f33c3fb8bf0889db","modified":1673341261237},{"_id":"public/api/search.json","hash":"ba49f590e2e722fa5b05801532e9d2c531084ad4","modified":1673341261237},{"_id":"public/api/statistic.json","hash":"ade5e14f97a498b6acd74c4fa043f049b6b98ded","modified":1673341261237},{"_id":"public/post/typescript/基础/内置对象.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/post/typescript/基础/声明文件.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/post/centos/centos镜像.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/post/typescript/基础/函数的类型.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/post/typescript/基础/类型断言.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/post/typescript/基础/数组的类型.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/post/typescript/基础/联合类型.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/post/typescript/基础/对象的类型——接口.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/post/typescript/基础/类型推论.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/post/typescript/基础/任意值.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/post/typescript/基础/基础.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/post/typescript/基础/原始数据类型.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/post/docker/Docker 镜像的使用.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/post/docker/Docker 容器连接.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/post/docker/Docker 容器的使用.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/post/typescript/webpack 搭建 ts 开发环境.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/index.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/post/typescript/TypeScript的数据类型.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/post/typescript/tsconfig.json 编译配置.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/page/2/index.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/tags/index.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/archives/index.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/page/about/index.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/tags/search/index.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1673341261237},{"_id":"public/icons/favicon-16x16.png","hash":"849cad2a5ae49fa54c20372f7a21ae95192bafcf","modified":1673341261237},{"_id":"public/favicon.ico","hash":"c39d3ad80489cffed0d3df82c8cb05a049ab39a3","modified":1673341261237},{"_id":"public/icons/favicon-32x32.png","hash":"9dbabf6f4d825da99dcb2e91583755ae8d3b3ff4","modified":1673341261237},{"_id":"public/CNAME","hash":"83c679868a95497228d71a2df4ebbfdabdd1b61c","modified":1673341261237},{"_id":"public/static/img/default-cover.df7c128c.jpg","hash":"1934ace0c6f2397d15729f9b08cc4d42e45bf437","modified":1673341261237},{"_id":"public/static/css/404.1a6cd5bd.css","hash":"a7a4d83756520d8f6c410ac0ffe9a45d63868113","modified":1673341261237},{"_id":"public/static/css/about.32dfa3b0.css","hash":"614ef7c4e52877c76ffddb26192bf8fffddcb8d8","modified":1673341261237},{"_id":"public/static/css/categories.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1673341261237},{"_id":"public/static/css/archives.c0d49bd5.css","hash":"c56213315c57254d0a6e6301ef24c2186fef4d2b","modified":1673341261237},{"_id":"public/static/css/chunk-libs.eebac533.css","hash":"41226b6c29aadcc6190fe7c2c4c37464855b8453","modified":1673341261237},{"_id":"public/static/css/page.749ad047.css","hash":"6fcf0e6f3c628954c5f8105791e0e7f3e6512da6","modified":1673341261237},{"_id":"public/static/css/result.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1673341261237},{"_id":"public/static/css/tags.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1673341261237},{"_id":"public/static/css/post.9f951a60.css","hash":"8e360582d745d6483fdfc18c46f75897b44721a6","modified":1673341261237},{"_id":"public/static/js/404.00d640a8.js","hash":"74f1da9e0f953e73e4fe1a6554433f56fdcdf54d","modified":1673341261237},{"_id":"public/static/js/about.024aacd1.js","hash":"7ce2b3f7d232dd3b3930ac993bb841452e2cde89","modified":1673341261237},{"_id":"public/static/js/archives.574ac664.js","hash":"fbb094fb4f7a01bffd6975aca27142935bfdca73","modified":1673341261237},{"_id":"public/static/js/categories.90aa5475.js","hash":"0dde3d731fc665962a4c330338a2c663c330be26","modified":1673341261237},{"_id":"public/static/js/page.a02618ad.js","hash":"db775fbfbaa1cf8bbf4cc4f2b0a869519d508e3a","modified":1673341261237},{"_id":"public/static/js/result.39470350.js","hash":"f6f5ab2ca7274dad169ec600a419d1a2aeb2347c","modified":1673341261237},{"_id":"public/static/js/post.cebfbaa4.js","hash":"53586f9dab5886a366e9397eb17088e74af5cde1","modified":1673341261237},{"_id":"public/static/js/tags.2ad613f5.js","hash":"4f49139e435788710115fc884dc26a5b1e0d4833","modified":1673341261237},{"_id":"public/static/css/app.0d31776f.css","hash":"43b43acd76bd8dc22f34cc49c7e026c45c3a5004","modified":1673341261237},{"_id":"public/static/js/app.6d2c358d.js","hash":"e176c20c22ce36e38935f463977e9b89b281c715","modified":1673341261237},{"_id":"public/static/js/chunk-libs.dc6146cd.js","hash":"534266637d09abf39278f4d3a21bd36728740105","modified":1673341261237}],"Category":[{"name":"Centos","_id":"clcq06kzk0003ysvnd6mphrcg"},{"name":"Docker","_id":"clcq06kzs0008ysvnbywh97cl"},{"name":"TypeScript","_id":"clcq06l03000oysvn1lzy1qf8"},{"name":"TypeScript入门","_id":"clcq06l0a0014ysvnfrp6a12m"}],"Data":[],"Page":[{"_content":"### 哈哈哈","source":"about/index.md","raw":"### 哈哈哈","date":"2023-01-03T09:02:23.279Z","updated":"2023-01-03T09:02:23.279Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"clcq06kzc0000ysvnf5wcf42g","content":"<h3 id=\"哈哈哈\"><a href=\"#哈哈哈\" class=\"headerlink\" title=\"哈哈哈\"></a>哈哈哈</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"哈哈哈\"><a href=\"#哈哈哈\" class=\"headerlink\" title=\"哈哈哈\"></a>哈哈哈</h3>"}],"Post":[{"title":"CentOS 镜像","cover":"https://api.onedrive.com/v1.0/shares/s!AkvcybxHlBS0kABBGGJbNnm15YHO/root/content","_content":"\n\n\n# CentOS 镜像\n\n[在线体验基于CentOS快速搭建LAMP环境去体验本教程介绍如何搭建LAMP环境，其中LAMP分别代表Linux、Apache、MySQL和PHP。](https://developer.aliyun.com/adc/scenario/6869de098ad44fc8a1560a1836a7c5f2)\n\n## 简介\n\nCentOS，是基于Red Hat Linux提供的可自由使用源代码的企业级Linux发行版本；是一个稳定，可预测，可管理和可复制的免费企业级计算平台。\n\n下载地址: https://mirrors.aliyun.com/centos/\n\n#### 相关仓库：\n\n- CentOS过期源（centos-vault）：https://developer.aliyun.com/mirror/centos-vault\n- CentOS arm源（centos-altarch）：https://developer.aliyun.com/mirror/centos-altarch/\n- CentOS Stream源（centos-stream）：https://developer.aliyun.com/mirror/centos-stream\n- CentOS debuginfo源（centos-debuginfo）：https://developer.aliyun.com/mirror/centos-debuginfo/\n\n## 配置方法\n\n> **通知：CentOS 8操作系统版本结束了生命周期（EOL），Linux社区已不再维护该操作系统版本。建议您切换到Anolis或Alinux。如果您的业务过渡期仍需要使用CentOS 8系统中的一些安装包，请根据下文切换CentOS 8的源。**\n\n### 1. 备份\n\n```\nmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\n```\n\n### 2. 下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/\n\n##### centos8（centos8官方源已下线，建议切换centos-vault源）\n\n```shell\nwget -O /etc/yum.repos.d/CentOS-Base.repo  https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo\n```\n\n或者\n\n```shell\ncurl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo\n```\n\n**centos6（centos6官方源已下线，建议切换centos-vault源）**\n\n```shell\nwget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-6.10.repo\n```\n\n或者\n\n```shell\ncurl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-6.10.repo\n```\n\n**CentOS 7**\n\n```shell\nwget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo\n```\n\n或者\n\n```shell\ncurl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo\n```\n\n### 3. 运行 yum makecache 生成缓存\n\n### 4. 其他\n\n非阿里云ECS用户会出现 Couldn't resolve host 'mirrors.cloud.aliyuncs.com' 信息，不影响使用。用户也可自行修改相关配置: eg:\n\n```shell\nsed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.aliyuncs.com/d' /etc/yum.repos.d/CentOS-Base.repo\n```\n\n\n\n## CentOS 8 结束生命周期如何切换源\n\n### 公网用户：\n\n```shell\nmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\nwget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo\nyum clean all && yum makecache\n```\n\n### 阿里云ecs用户：\n\n```powershell\nmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\nwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.cloud.aliyuncs.com/repo/Centos-vault-8.5.2111.repo\nsed -i 's/mirrors.cloud.aliyuncs.com/url_tmp/g' /etc/yum.repos.d/CentOS-Base.repo && sed -i 's/mirrors.aliyun.com/mirrors.cloud.aliyuncs.com/g' /etc/yum.repos.d/CentOS-Base.repo && sed -i 's/url_tmp/mirrors.aliyun.com/g' /etc/yum.repos.d/CentOS-Base.repo\nyum clean all && yum makecache\n```\n\n\n\n## 相关链接\n\n- 官方主页: http://www.centos.org/\n- 邮件列表: https://wiki.centos.org/GettingHelp/ListInfo\n- 论坛: https://forums.centos.org/\n- 文档: http://www.centos.org/docs/\n- Wiki: http://wiki.centos.org/","source":"_posts/centos/centos镜像.md","raw":"---\ntitle: CentOS 镜像\ncover: https://api.onedrive.com/v1.0/shares/s!AkvcybxHlBS0kABBGGJbNnm15YHO/root/content\ncategories:\n  - Centos\ntags:\n  - Centos\n  - 镜像\n---\n\n\n\n# CentOS 镜像\n\n[在线体验基于CentOS快速搭建LAMP环境去体验本教程介绍如何搭建LAMP环境，其中LAMP分别代表Linux、Apache、MySQL和PHP。](https://developer.aliyun.com/adc/scenario/6869de098ad44fc8a1560a1836a7c5f2)\n\n## 简介\n\nCentOS，是基于Red Hat Linux提供的可自由使用源代码的企业级Linux发行版本；是一个稳定，可预测，可管理和可复制的免费企业级计算平台。\n\n下载地址: https://mirrors.aliyun.com/centos/\n\n#### 相关仓库：\n\n- CentOS过期源（centos-vault）：https://developer.aliyun.com/mirror/centos-vault\n- CentOS arm源（centos-altarch）：https://developer.aliyun.com/mirror/centos-altarch/\n- CentOS Stream源（centos-stream）：https://developer.aliyun.com/mirror/centos-stream\n- CentOS debuginfo源（centos-debuginfo）：https://developer.aliyun.com/mirror/centos-debuginfo/\n\n## 配置方法\n\n> **通知：CentOS 8操作系统版本结束了生命周期（EOL），Linux社区已不再维护该操作系统版本。建议您切换到Anolis或Alinux。如果您的业务过渡期仍需要使用CentOS 8系统中的一些安装包，请根据下文切换CentOS 8的源。**\n\n### 1. 备份\n\n```\nmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\n```\n\n### 2. 下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/\n\n##### centos8（centos8官方源已下线，建议切换centos-vault源）\n\n```shell\nwget -O /etc/yum.repos.d/CentOS-Base.repo  https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo\n```\n\n或者\n\n```shell\ncurl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo\n```\n\n**centos6（centos6官方源已下线，建议切换centos-vault源）**\n\n```shell\nwget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-6.10.repo\n```\n\n或者\n\n```shell\ncurl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-6.10.repo\n```\n\n**CentOS 7**\n\n```shell\nwget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo\n```\n\n或者\n\n```shell\ncurl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo\n```\n\n### 3. 运行 yum makecache 生成缓存\n\n### 4. 其他\n\n非阿里云ECS用户会出现 Couldn't resolve host 'mirrors.cloud.aliyuncs.com' 信息，不影响使用。用户也可自行修改相关配置: eg:\n\n```shell\nsed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.aliyuncs.com/d' /etc/yum.repos.d/CentOS-Base.repo\n```\n\n\n\n## CentOS 8 结束生命周期如何切换源\n\n### 公网用户：\n\n```shell\nmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\nwget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo\nyum clean all && yum makecache\n```\n\n### 阿里云ecs用户：\n\n```powershell\nmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\nwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.cloud.aliyuncs.com/repo/Centos-vault-8.5.2111.repo\nsed -i 's/mirrors.cloud.aliyuncs.com/url_tmp/g' /etc/yum.repos.d/CentOS-Base.repo && sed -i 's/mirrors.aliyun.com/mirrors.cloud.aliyuncs.com/g' /etc/yum.repos.d/CentOS-Base.repo && sed -i 's/url_tmp/mirrors.aliyun.com/g' /etc/yum.repos.d/CentOS-Base.repo\nyum clean all && yum makecache\n```\n\n\n\n## 相关链接\n\n- 官方主页: http://www.centos.org/\n- 邮件列表: https://wiki.centos.org/GettingHelp/ListInfo\n- 论坛: https://forums.centos.org/\n- 文档: http://www.centos.org/docs/\n- Wiki: http://wiki.centos.org/","slug":"centos/centos镜像","published":1,"date":"2023-01-09T07:45:49.147Z","updated":"2023-01-10T08:54:46.932Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcq06kzf0001ysvn36dbgrdh","content":"<h1 id=\"CentOS-镜像\"><a href=\"#CentOS-镜像\" class=\"headerlink\" title=\"CentOS 镜像\"></a>CentOS 镜像</h1><p><a href=\"https://developer.aliyun.com/adc/scenario/6869de098ad44fc8a1560a1836a7c5f2\">在线体验基于CentOS快速搭建LAMP环境去体验本教程介绍如何搭建LAMP环境，其中LAMP分别代表Linux、Apache、MySQL和PHP。</a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>CentOS，是基于Red Hat Linux提供的可自由使用源代码的企业级Linux发行版本；是一个稳定，可预测，可管理和可复制的免费企业级计算平台。</p>\n<p>下载地址: <a href=\"https://mirrors.aliyun.com/centos/\">https://mirrors.aliyun.com/centos/</a></p>\n<h4 id=\"相关仓库：\"><a href=\"#相关仓库：\" class=\"headerlink\" title=\"相关仓库：\"></a>相关仓库：</h4><ul>\n<li>CentOS过期源（centos-vault）：<a href=\"https://developer.aliyun.com/mirror/centos-vault\">https://developer.aliyun.com/mirror/centos-vault</a></li>\n<li>CentOS arm源（centos-altarch）：<a href=\"https://developer.aliyun.com/mirror/centos-altarch/\">https://developer.aliyun.com/mirror/centos-altarch/</a></li>\n<li>CentOS Stream源（centos-stream）：<a href=\"https://developer.aliyun.com/mirror/centos-stream\">https://developer.aliyun.com/mirror/centos-stream</a></li>\n<li>CentOS debuginfo源（centos-debuginfo）：<a href=\"https://developer.aliyun.com/mirror/centos-debuginfo/\">https://developer.aliyun.com/mirror/centos-debuginfo/</a></li>\n</ul>\n<h2 id=\"配置方法\"><a href=\"#配置方法\" class=\"headerlink\" title=\"配置方法\"></a>配置方法</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>通知：CentOS 8操作系统版本结束了生命周期（EOL），Linux社区已不再维护该操作系统版本。建议您切换到Anolis或Alinux。如果您的业务过渡期仍需要使用CentOS 8系统中的一些安装包，请根据下文切换CentOS 8的源。</strong></p></blockquote>\n<h3 id=\"1-备份\"><a href=\"#1-备份\" class=\"headerlink\" title=\"1. 备份\"></a>1. 备份</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup</code></pre>\n\n<h3 id=\"2-下载新的-CentOS-Base-repo-到-etc-yum-repos-d\"><a href=\"#2-下载新的-CentOS-Base-repo-到-etc-yum-repos-d\" class=\"headerlink\" title=\"2. 下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/\"></a>2. 下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/</h3><h5 id=\"centos8（centos8官方源已下线，建议切换centos-vault源）\"><a href=\"#centos8（centos8官方源已下线，建议切换centos-vault源）\" class=\"headerlink\" title=\"centos8（centos8官方源已下线，建议切换centos-vault源）\"></a>centos8（centos8官方源已下线，建议切换centos-vault源）</h5><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo  https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-vault-8.5.2111.repo</code></pre>\n\n<p>或者</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-vault-8.5.2111.repo</code></pre>\n\n<p><strong>centos6（centos6官方源已下线，建议切换centos-vault源）</strong></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-vault-6.10.repo</code></pre>\n\n<p>或者</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-vault-6.10.repo</code></pre>\n\n<p><strong>CentOS 7</strong></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</code></pre>\n\n<p>或者</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</code></pre>\n\n<h3 id=\"3-运行-yum-makecache-生成缓存\"><a href=\"#3-运行-yum-makecache-生成缓存\" class=\"headerlink\" title=\"3. 运行 yum makecache 生成缓存\"></a>3. 运行 yum makecache 生成缓存</h3><h3 id=\"4-其他\"><a href=\"#4-其他\" class=\"headerlink\" title=\"4. 其他\"></a>4. 其他</h3><p>非阿里云ECS用户会出现 Couldn’t resolve host ‘mirrors.cloud.aliyuncs.com’ 信息，不影响使用。用户也可自行修改相关配置: eg:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">sed -i -e &#39;&#x2F;mirrors.cloud.aliyuncs.com&#x2F;d&#39; -e &#39;&#x2F;mirrors.aliyuncs.com&#x2F;d&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo</code></pre>\n\n\n\n<h2 id=\"CentOS-8-结束生命周期如何切换源\"><a href=\"#CentOS-8-结束生命周期如何切换源\" class=\"headerlink\" title=\"CentOS 8 结束生命周期如何切换源\"></a>CentOS 8 结束生命周期如何切换源</h2><h3 id=\"公网用户：\"><a href=\"#公网用户：\" class=\"headerlink\" title=\"公网用户：\"></a>公网用户：</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup\nwget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-vault-8.5.2111.repo\nyum clean all &amp;&amp; yum makecache</code></pre>\n\n<h3 id=\"阿里云ecs用户：\"><a href=\"#阿里云ecs用户：\" class=\"headerlink\" title=\"阿里云ecs用户：\"></a>阿里云ecs用户：</h3><pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup\nwget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.cloud.aliyuncs.com&#x2F;repo&#x2F;Centos-vault-8.5.2111.repo\nsed -i &#39;s&#x2F;mirrors.cloud.aliyuncs.com&#x2F;url_tmp&#x2F;g&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &amp;&amp; sed -i &#39;s&#x2F;mirrors.aliyun.com&#x2F;mirrors.cloud.aliyuncs.com&#x2F;g&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &amp;&amp; sed -i &#39;s&#x2F;url_tmp&#x2F;mirrors.aliyun.com&#x2F;g&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo\nyum clean all &amp;&amp; yum makecache</code></pre>\n\n\n\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><ul>\n<li>官方主页: <a href=\"http://www.centos.org/\">http://www.centos.org/</a></li>\n<li>邮件列表: <a href=\"https://wiki.centos.org/GettingHelp/ListInfo\">https://wiki.centos.org/GettingHelp/ListInfo</a></li>\n<li>论坛: <a href=\"https://forums.centos.org/\">https://forums.centos.org/</a></li>\n<li>文档: <a href=\"http://www.centos.org/docs/\">http://www.centos.org/docs/</a></li>\n<li>Wiki: <a href=\"http://wiki.centos.org/\">http://wiki.centos.org/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CentOS-镜像\"><a href=\"#CentOS-镜像\" class=\"headerlink\" title=\"CentOS 镜像\"></a>CentOS 镜像</h1><p><a href=\"https://developer.aliyun.com/adc/scenario/6869de098ad44fc8a1560a1836a7c5f2\">在线体验基于CentOS快速搭建LAMP环境去体验本教程介绍如何搭建LAMP环境，其中LAMP分别代表Linux、Apache、MySQL和PHP。</a></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>CentOS，是基于Red Hat Linux提供的可自由使用源代码的企业级Linux发行版本；是一个稳定，可预测，可管理和可复制的免费企业级计算平台。</p>\n<p>下载地址: <a href=\"https://mirrors.aliyun.com/centos/\">https://mirrors.aliyun.com/centos/</a></p>\n<h4 id=\"相关仓库：\"><a href=\"#相关仓库：\" class=\"headerlink\" title=\"相关仓库：\"></a>相关仓库：</h4><ul>\n<li>CentOS过期源（centos-vault）：<a href=\"https://developer.aliyun.com/mirror/centos-vault\">https://developer.aliyun.com/mirror/centos-vault</a></li>\n<li>CentOS arm源（centos-altarch）：<a href=\"https://developer.aliyun.com/mirror/centos-altarch/\">https://developer.aliyun.com/mirror/centos-altarch/</a></li>\n<li>CentOS Stream源（centos-stream）：<a href=\"https://developer.aliyun.com/mirror/centos-stream\">https://developer.aliyun.com/mirror/centos-stream</a></li>\n<li>CentOS debuginfo源（centos-debuginfo）：<a href=\"https://developer.aliyun.com/mirror/centos-debuginfo/\">https://developer.aliyun.com/mirror/centos-debuginfo/</a></li>\n</ul>\n<h2 id=\"配置方法\"><a href=\"#配置方法\" class=\"headerlink\" title=\"配置方法\"></a>配置方法</h2><blockquote>\n<p><strong>通知：CentOS 8操作系统版本结束了生命周期（EOL），Linux社区已不再维护该操作系统版本。建议您切换到Anolis或Alinux。如果您的业务过渡期仍需要使用CentOS 8系统中的一些安装包，请根据下文切换CentOS 8的源。</strong></p>\n</blockquote>\n<h3 id=\"1-备份\"><a href=\"#1-备份\" class=\"headerlink\" title=\"1. 备份\"></a>1. 备份</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup</code></pre>\n\n<h3 id=\"2-下载新的-CentOS-Base-repo-到-etc-yum-repos-d\"><a href=\"#2-下载新的-CentOS-Base-repo-到-etc-yum-repos-d\" class=\"headerlink\" title=\"2. 下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/\"></a>2. 下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/</h3><h5 id=\"centos8（centos8官方源已下线，建议切换centos-vault源）\"><a href=\"#centos8（centos8官方源已下线，建议切换centos-vault源）\" class=\"headerlink\" title=\"centos8（centos8官方源已下线，建议切换centos-vault源）\"></a>centos8（centos8官方源已下线，建议切换centos-vault源）</h5><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo  https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-vault-8.5.2111.repo</code></pre>\n\n<p>或者</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-vault-8.5.2111.repo</code></pre>\n\n<p><strong>centos6（centos6官方源已下线，建议切换centos-vault源）</strong></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-vault-6.10.repo</code></pre>\n\n<p>或者</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-vault-6.10.repo</code></pre>\n\n<p><strong>CentOS 7</strong></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</code></pre>\n\n<p>或者</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</code></pre>\n\n<h3 id=\"3-运行-yum-makecache-生成缓存\"><a href=\"#3-运行-yum-makecache-生成缓存\" class=\"headerlink\" title=\"3. 运行 yum makecache 生成缓存\"></a>3. 运行 yum makecache 生成缓存</h3><h3 id=\"4-其他\"><a href=\"#4-其他\" class=\"headerlink\" title=\"4. 其他\"></a>4. 其他</h3><p>非阿里云ECS用户会出现 Couldn’t resolve host ‘mirrors.cloud.aliyuncs.com’ 信息，不影响使用。用户也可自行修改相关配置: eg:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">sed -i -e &#39;&#x2F;mirrors.cloud.aliyuncs.com&#x2F;d&#39; -e &#39;&#x2F;mirrors.aliyuncs.com&#x2F;d&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo</code></pre>\n\n\n\n<h2 id=\"CentOS-8-结束生命周期如何切换源\"><a href=\"#CentOS-8-结束生命周期如何切换源\" class=\"headerlink\" title=\"CentOS 8 结束生命周期如何切换源\"></a>CentOS 8 结束生命周期如何切换源</h2><h3 id=\"公网用户：\"><a href=\"#公网用户：\" class=\"headerlink\" title=\"公网用户：\"></a>公网用户：</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup\nwget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-vault-8.5.2111.repo\nyum clean all &amp;&amp; yum makecache</code></pre>\n\n<h3 id=\"阿里云ecs用户：\"><a href=\"#阿里云ecs用户：\" class=\"headerlink\" title=\"阿里云ecs用户：\"></a>阿里云ecs用户：</h3><pre class=\"line-numbers language-powershell\" data-language=\"powershell\"><code class=\"language-powershell\">mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup\nwget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.cloud.aliyuncs.com&#x2F;repo&#x2F;Centos-vault-8.5.2111.repo\nsed -i &#39;s&#x2F;mirrors.cloud.aliyuncs.com&#x2F;url_tmp&#x2F;g&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &amp;&amp; sed -i &#39;s&#x2F;mirrors.aliyun.com&#x2F;mirrors.cloud.aliyuncs.com&#x2F;g&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &amp;&amp; sed -i &#39;s&#x2F;url_tmp&#x2F;mirrors.aliyun.com&#x2F;g&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo\nyum clean all &amp;&amp; yum makecache</code></pre>\n\n\n\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><ul>\n<li>官方主页: <a href=\"http://www.centos.org/\">http://www.centos.org/</a></li>\n<li>邮件列表: <a href=\"https://wiki.centos.org/GettingHelp/ListInfo\">https://wiki.centos.org/GettingHelp/ListInfo</a></li>\n<li>论坛: <a href=\"https://forums.centos.org/\">https://forums.centos.org/</a></li>\n<li>文档: <a href=\"http://www.centos.org/docs/\">http://www.centos.org/docs/</a></li>\n<li>Wiki: <a href=\"http://wiki.centos.org/\">http://wiki.centos.org/</a></li>\n</ul>\n"},{"title":"Docker 容器的使用","date":"2023-01-03T07:13:50.000Z","cover":"https://www.helloimg.com/images/2023/01/03/oCD5cE.png","_content":"\n# 网络端口映射\n有以下两种端口映射方式\n```shell\ndocker run -itd -P --name centos8 dokken/centos-8 /bin/bash\n```\n```shell\ndocker run -itd -p 1000:22 --name centos8 dokken/centos-8 /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- -d: 后台运行\n- -p 1000:22 :以指定的1000端口映射容器的22端口\n- -P: 容器内部端口随机映射到主机端口\n- --name: 容器别名\n- dokken/centos-8: 容器源名称\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n## 区别\n\n- -P :是容器内部端口随机映射到主机的端口。\n- -p : 是容器内部端口绑定到指定的主机端口。\n\n另外, 我们可以指定容器绑定的网络地址, 比如绑定 127.0.0.1\n```shell\ndocker run -itd -p 127.0.0.1:1000:22 --name centos8 dokken/centos-8 /bin/bash\n```\n这样我们就可以通过` 127.0.0.1:1000 `来访问容器的22端口了\n","source":"_posts/docker/Docker 容器连接.md","raw":"---\ntitle: Docker 容器的使用\ndate: 2023/1/3 15:13:50\ncover: https://www.helloimg.com/images/2023/01/03/oCD5cE.png\ncategories:\n  - Docker\ntags:\n  - Docker\n  - 容器\n  - container\n---\n\n# 网络端口映射\n有以下两种端口映射方式\n```shell\ndocker run -itd -P --name centos8 dokken/centos-8 /bin/bash\n```\n```shell\ndocker run -itd -p 1000:22 --name centos8 dokken/centos-8 /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- -d: 后台运行\n- -p 1000:22 :以指定的1000端口映射容器的22端口\n- -P: 容器内部端口随机映射到主机端口\n- --name: 容器别名\n- dokken/centos-8: 容器源名称\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n## 区别\n\n- -P :是容器内部端口随机映射到主机的端口。\n- -p : 是容器内部端口绑定到指定的主机端口。\n\n另外, 我们可以指定容器绑定的网络地址, 比如绑定 127.0.0.1\n```shell\ndocker run -itd -p 127.0.0.1:1000:22 --name centos8 dokken/centos-8 /bin/bash\n```\n这样我们就可以通过` 127.0.0.1:1000 `来访问容器的22端口了\n","slug":"docker/Docker 容器连接","published":1,"updated":"2023-01-03T09:02:23.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcq06kzi0002ysvnhld427pd","content":"<h1 id=\"网络端口映射\"><a href=\"#网络端口映射\" class=\"headerlink\" title=\"网络端口映射\"></a>网络端口映射</h1><p>有以下两种端口映射方式</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -itd -P --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash</code></pre>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -itd -p 1000:22 --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><ul>\n<li><p>-i：交互式操作</p>\n</li>\n<li><p>-t: 终端</p>\n</li>\n<li><p>-d: 后台运行</p>\n</li>\n<li><p>-p 1000:22 :以指定的1000端口映射容器的22端口</p>\n</li>\n<li><p>-P: 容器内部端口随机映射到主机端口</p>\n</li>\n<li><p>–name: 容器别名</p>\n</li>\n<li><p>dokken/centos-8: 容器源名称</p>\n</li>\n<li><p>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</p>\n<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2></li>\n<li><p>-P :是容器内部端口随机映射到主机的端口。</p>\n</li>\n<li><p>-p : 是容器内部端口绑定到指定的主机端口。</p>\n</li>\n</ul>\n<p>另外, 我们可以指定容器绑定的网络地址, 比如绑定 127.0.0.1</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -itd -p 127.0.0.1:1000:22 --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash</code></pre>\n<p>这样我们就可以通过<code>127.0.0.1:1000</code>来访问容器的22端口了</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"网络端口映射\"><a href=\"#网络端口映射\" class=\"headerlink\" title=\"网络端口映射\"></a>网络端口映射</h1><p>有以下两种端口映射方式</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -itd -P --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash</code></pre>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -itd -p 1000:22 --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><ul>\n<li><p>-i：交互式操作</p>\n</li>\n<li><p>-t: 终端</p>\n</li>\n<li><p>-d: 后台运行</p>\n</li>\n<li><p>-p 1000:22 :以指定的1000端口映射容器的22端口</p>\n</li>\n<li><p>-P: 容器内部端口随机映射到主机端口</p>\n</li>\n<li><p>–name: 容器别名</p>\n</li>\n<li><p>dokken/centos-8: 容器源名称</p>\n</li>\n<li><p>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</p>\n<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2></li>\n<li><p>-P :是容器内部端口随机映射到主机的端口。</p>\n</li>\n<li><p>-p : 是容器内部端口绑定到指定的主机端口。</p>\n</li>\n</ul>\n<p>另外, 我们可以指定容器绑定的网络地址, 比如绑定 127.0.0.1</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -itd -p 127.0.0.1:1000:22 --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash</code></pre>\n<p>这样我们就可以通过<code>127.0.0.1:1000</code>来访问容器的22端口了</p>\n"},{"title":"Docker 容器的使用","date":"2022-12-06T08:00:12.000Z","cover":"https://www.helloimg.com/images/2023/01/03/oCD5cE.png","_content":"\n# 获取容器\n我们可以使用docker pull 命令来下载 centos镜像\n```shell\n$ docker pull centos8\n```\n# 启动容器\n```shell\n$ docker run -it centos8 /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- centos8：centos8镜像\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n\n如果要退出终端那就使用\n```shell\n$ exit\n```\n# 查看所有容器\n```shell\n$ docker ps -a\n```\n# 启动一个已经停止的容器\n```shell\n$ docker start b750bbbcfd88(容器id)\n```\n# 停止一个已经启动的容器\n```shell\n$ docker stop b750bbbcfd88(容器id)\n```\n# 后台运行容器(不想进入容器的时候)\n```shell\n$ docker -itd --name content_8 centos8 /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- -d: 后台运行\n- --name: 运行时指定容器的名称\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n# 进入容器\n在使用参数 `-d` 时, 容器会进入后台, 这个时候如果想要进入容器内部可以使用以下命令\n```shell\n$ docker exec -it [容器ID] /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n# 导入和导出容器\n## 导出容器\n如果要导出到本地的某个容器, 可以使用 `docker export` 命令\n```shell\n$ docker export [容器ID] > centos8.tar\n```\n> 导出容器ID到本地文件的 centos8.tar\n\n## 导入容器\n```shell\n$ cat docker/ubuntu.tar | docker import - test/ubuntu:v1\n```\n此外, 还可以通过指定URL或某个目录来导入\n```shell\n$ docker import http://example.com/exampleimage.tgz example/imagerepo\n```\n## 删除容器\n```shell\n$ docker rm -f [容器ID]\n```\n清除所有处于终止状态下的容器\n```shell\n$ docker container prune\n```\n\n","source":"_posts/docker/Docker 容器的使用.md","raw":"---\ntitle: Docker 容器的使用\ndate: 2022/12/06 16:00:12\ncover: https://www.helloimg.com/images/2023/01/03/oCD5cE.png\ncategories:\n  - Docker\ntags:\n  - Docker\n  - 容器\n  - container\n---\n\n# 获取容器\n我们可以使用docker pull 命令来下载 centos镜像\n```shell\n$ docker pull centos8\n```\n# 启动容器\n```shell\n$ docker run -it centos8 /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- centos8：centos8镜像\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n\n如果要退出终端那就使用\n```shell\n$ exit\n```\n# 查看所有容器\n```shell\n$ docker ps -a\n```\n# 启动一个已经停止的容器\n```shell\n$ docker start b750bbbcfd88(容器id)\n```\n# 停止一个已经启动的容器\n```shell\n$ docker stop b750bbbcfd88(容器id)\n```\n# 后台运行容器(不想进入容器的时候)\n```shell\n$ docker -itd --name content_8 centos8 /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- -d: 后台运行\n- --name: 运行时指定容器的名称\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n# 进入容器\n在使用参数 `-d` 时, 容器会进入后台, 这个时候如果想要进入容器内部可以使用以下命令\n```shell\n$ docker exec -it [容器ID] /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n# 导入和导出容器\n## 导出容器\n如果要导出到本地的某个容器, 可以使用 `docker export` 命令\n```shell\n$ docker export [容器ID] > centos8.tar\n```\n> 导出容器ID到本地文件的 centos8.tar\n\n## 导入容器\n```shell\n$ cat docker/ubuntu.tar | docker import - test/ubuntu:v1\n```\n此外, 还可以通过指定URL或某个目录来导入\n```shell\n$ docker import http://example.com/exampleimage.tgz example/imagerepo\n```\n## 删除容器\n```shell\n$ docker rm -f [容器ID]\n```\n清除所有处于终止状态下的容器\n```shell\n$ docker container prune\n```\n\n","slug":"docker/Docker 容器的使用","published":1,"updated":"2023-01-03T09:02:23.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcq06kzm0005ysvngzauef60","content":"<h1 id=\"获取容器\"><a href=\"#获取容器\" class=\"headerlink\" title=\"获取容器\"></a>获取容器</h1><p>我们可以使用docker pull 命令来下载 centos镜像</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker pull centos8</code></pre>\n<h1 id=\"启动容器\"><a href=\"#启动容器\" class=\"headerlink\" title=\"启动容器\"></a>启动容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker run -it centos8 &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><ul>\n<li>-i：交互式操作</li>\n<li>-t: 终端</li>\n<li>centos8：centos8镜像</li>\n<li>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</li>\n</ul>\n<p>如果要退出终端那就使用</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ exit</code></pre>\n<h1 id=\"查看所有容器\"><a href=\"#查看所有容器\" class=\"headerlink\" title=\"查看所有容器\"></a>查看所有容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker ps -a</code></pre>\n<h1 id=\"启动一个已经停止的容器\"><a href=\"#启动一个已经停止的容器\" class=\"headerlink\" title=\"启动一个已经停止的容器\"></a>启动一个已经停止的容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker start b750bbbcfd88(容器id)</code></pre>\n<h1 id=\"停止一个已经启动的容器\"><a href=\"#停止一个已经启动的容器\" class=\"headerlink\" title=\"停止一个已经启动的容器\"></a>停止一个已经启动的容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker stop b750bbbcfd88(容器id)</code></pre>\n<h1 id=\"后台运行容器-不想进入容器的时候\"><a href=\"#后台运行容器-不想进入容器的时候\" class=\"headerlink\" title=\"后台运行容器(不想进入容器的时候)\"></a>后台运行容器(不想进入容器的时候)</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker -itd --name content_8 centos8 &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明-1\"><a href=\"#参数说明-1\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><ul>\n<li><p>-i：交互式操作</p>\n</li>\n<li><p>-t: 终端</p>\n</li>\n<li><p>-d: 后台运行</p>\n</li>\n<li><p>–name: 运行时指定容器的名称</p>\n</li>\n<li><p>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</p>\n<h1 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h1><p>在使用参数 <code>-d</code> 时, 容器会进入后台, 这个时候如果想要进入容器内部可以使用以下命令</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker exec -it [容器ID] &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明-2\"><a href=\"#参数说明-2\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2></li>\n<li><p>-i：交互式操作</p>\n</li>\n<li><p>-t: 终端</p>\n</li>\n<li><p>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</p>\n<h1 id=\"导入和导出容器\"><a href=\"#导入和导出容器\" class=\"headerlink\" title=\"导入和导出容器\"></a>导入和导出容器</h1><h2 id=\"导出容器\"><a href=\"#导出容器\" class=\"headerlink\" title=\"导出容器\"></a>导出容器</h2><p>如果要导出到本地的某个容器, 可以使用 <code>docker export</code> 命令</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker export [容器ID] &gt; centos8.tar</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>导出容器ID到本地文件的 centos8.tar</p></blockquote>\n</li>\n</ul>\n<h2 id=\"导入容器\"><a href=\"#导入容器\" class=\"headerlink\" title=\"导入容器\"></a>导入容器</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ cat docker&#x2F;ubuntu.tar | docker import - test&#x2F;ubuntu:v1</code></pre>\n<p>此外, 还可以通过指定URL或某个目录来导入</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker import http:&#x2F;&#x2F;example.com&#x2F;exampleimage.tgz example&#x2F;imagerepo</code></pre>\n<h2 id=\"删除容器\"><a href=\"#删除容器\" class=\"headerlink\" title=\"删除容器\"></a>删除容器</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker rm -f [容器ID]</code></pre>\n<p>清除所有处于终止状态下的容器</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker container prune</code></pre>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"获取容器\"><a href=\"#获取容器\" class=\"headerlink\" title=\"获取容器\"></a>获取容器</h1><p>我们可以使用docker pull 命令来下载 centos镜像</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker pull centos8</code></pre>\n<h1 id=\"启动容器\"><a href=\"#启动容器\" class=\"headerlink\" title=\"启动容器\"></a>启动容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker run -it centos8 &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><ul>\n<li>-i：交互式操作</li>\n<li>-t: 终端</li>\n<li>centos8：centos8镜像</li>\n<li>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</li>\n</ul>\n<p>如果要退出终端那就使用</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ exit</code></pre>\n<h1 id=\"查看所有容器\"><a href=\"#查看所有容器\" class=\"headerlink\" title=\"查看所有容器\"></a>查看所有容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker ps -a</code></pre>\n<h1 id=\"启动一个已经停止的容器\"><a href=\"#启动一个已经停止的容器\" class=\"headerlink\" title=\"启动一个已经停止的容器\"></a>启动一个已经停止的容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker start b750bbbcfd88(容器id)</code></pre>\n<h1 id=\"停止一个已经启动的容器\"><a href=\"#停止一个已经启动的容器\" class=\"headerlink\" title=\"停止一个已经启动的容器\"></a>停止一个已经启动的容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker stop b750bbbcfd88(容器id)</code></pre>\n<h1 id=\"后台运行容器-不想进入容器的时候\"><a href=\"#后台运行容器-不想进入容器的时候\" class=\"headerlink\" title=\"后台运行容器(不想进入容器的时候)\"></a>后台运行容器(不想进入容器的时候)</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker -itd --name content_8 centos8 &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明-1\"><a href=\"#参数说明-1\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><ul>\n<li><p>-i：交互式操作</p>\n</li>\n<li><p>-t: 终端</p>\n</li>\n<li><p>-d: 后台运行</p>\n</li>\n<li><p>–name: 运行时指定容器的名称</p>\n</li>\n<li><p>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</p>\n<h1 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h1><p>在使用参数 <code>-d</code> 时, 容器会进入后台, 这个时候如果想要进入容器内部可以使用以下命令</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker exec -it [容器ID] &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明-2\"><a href=\"#参数说明-2\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2></li>\n<li><p>-i：交互式操作</p>\n</li>\n<li><p>-t: 终端</p>\n</li>\n<li><p>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</p>\n<h1 id=\"导入和导出容器\"><a href=\"#导入和导出容器\" class=\"headerlink\" title=\"导入和导出容器\"></a>导入和导出容器</h1><h2 id=\"导出容器\"><a href=\"#导出容器\" class=\"headerlink\" title=\"导出容器\"></a>导出容器</h2><p>如果要导出到本地的某个容器, 可以使用 <code>docker export</code> 命令</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker export [容器ID] &gt; centos8.tar</code></pre>\n<blockquote>\n<p>导出容器ID到本地文件的 centos8.tar</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"导入容器\"><a href=\"#导入容器\" class=\"headerlink\" title=\"导入容器\"></a>导入容器</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ cat docker&#x2F;ubuntu.tar | docker import - test&#x2F;ubuntu:v1</code></pre>\n<p>此外, 还可以通过指定URL或某个目录来导入</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker import http:&#x2F;&#x2F;example.com&#x2F;exampleimage.tgz example&#x2F;imagerepo</code></pre>\n<h2 id=\"删除容器\"><a href=\"#删除容器\" class=\"headerlink\" title=\"删除容器\"></a>删除容器</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker rm -f [容器ID]</code></pre>\n<p>清除所有处于终止状态下的容器</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker container prune</code></pre>\n\n"},{"title":"Docker 镜像的使用","date":"2023-01-03T07:15:43.000Z","cover":"https://www.helloimg.com/images/2023/01/03/oCD5cE.png","_content":"\n# 列出镜像列表\n我们可以使用 `docker images` 来列出本地主机上的镜像\n```shell\n$ docker images\n```\n![image.png](https://s2.loli.net/2023/01/03/jYuRFcMDSm1Orlx.png)\n## 选项说明\n\n- REPOSITORY: 表示镜像的仓库源\n- TAG:　镜像的标签\n- IMAGE ID: 镜像ID\n- CREATED: 镜像的创建时间\n- SIZE: 镜像大小\n> 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。\n\n# 获取一个新的镜像\n当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。\n```shell\ndocker pull centos:8\n```\n当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。\n# 查找镜像\n我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： [https://hub.docker.com/](https://hub.docker.com/)\n我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。\n```shell\n$ docker search httpd\n```\n![image.png](https://s2.loli.net/2023/01/03/zlKVAxekZowgcYq.png)\n## 选项说明\n\n- NAME: 镜像仓库源名称\n- DESCRIPTION: 镜像的描述\n- OFFICIAL: 是否 docker 官方发布\n- STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。\n- AUTOMATED: 自动构建。\n# 拖取镜像\n```shell\n$ docker pull httpd\n```\n下载完后我们就可以使用这个镜像了\n```shell\n$ docker run httpd\n```\n# 删除镜像\n```shell\n$ docker rmi httpd\n```\n","source":"_posts/docker/Docker 镜像的使用.md","raw":"---\ntitle: Docker 镜像的使用\ndate: 2023/1/3 15:15:43\ncover: https://www.helloimg.com/images/2023/01/03/oCD5cE.png\ncategories:\n  - Docker\ntags:\n  - Docker\n  - 镜像\n  - images\n---\n\n# 列出镜像列表\n我们可以使用 `docker images` 来列出本地主机上的镜像\n```shell\n$ docker images\n```\n![image.png](https://s2.loli.net/2023/01/03/jYuRFcMDSm1Orlx.png)\n## 选项说明\n\n- REPOSITORY: 表示镜像的仓库源\n- TAG:　镜像的标签\n- IMAGE ID: 镜像ID\n- CREATED: 镜像的创建时间\n- SIZE: 镜像大小\n> 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。\n\n# 获取一个新的镜像\n当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。\n```shell\ndocker pull centos:8\n```\n当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。\n# 查找镜像\n我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： [https://hub.docker.com/](https://hub.docker.com/)\n我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。\n```shell\n$ docker search httpd\n```\n![image.png](https://s2.loli.net/2023/01/03/zlKVAxekZowgcYq.png)\n## 选项说明\n\n- NAME: 镜像仓库源名称\n- DESCRIPTION: 镜像的描述\n- OFFICIAL: 是否 docker 官方发布\n- STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。\n- AUTOMATED: 自动构建。\n# 拖取镜像\n```shell\n$ docker pull httpd\n```\n下载完后我们就可以使用这个镜像了\n```shell\n$ docker run httpd\n```\n# 删除镜像\n```shell\n$ docker rmi httpd\n```\n","slug":"docker/Docker 镜像的使用","published":1,"updated":"2023-01-03T09:02:23.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcq06kzo0006ysvn9tuxe2aa","content":"<h1 id=\"列出镜像列表\"><a href=\"#列出镜像列表\" class=\"headerlink\" title=\"列出镜像列表\"></a>列出镜像列表</h1><p>我们可以使用 <code>docker images</code> 来列出本地主机上的镜像</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker images</code></pre>\n<p><img src=\"https://s2.loli.net/2023/01/03/jYuRFcMDSm1Orlx.png\" alt=\"image.png\"></p>\n<h2 id=\"选项说明\"><a href=\"#选项说明\" class=\"headerlink\" title=\"选项说明\"></a>选项说明</h2><ul>\n<li>REPOSITORY: 表示镜像的仓库源</li>\n<li>TAG:　镜像的标签</li>\n<li>IMAGE ID: 镜像ID</li>\n<li>CREATED: 镜像的创建时间</li>\n<li>SIZE: 镜像大小<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p></blockquote>\n</li>\n</ul>\n<h1 id=\"获取一个新的镜像\"><a href=\"#获取一个新的镜像\" class=\"headerlink\" title=\"获取一个新的镜像\"></a>获取一个新的镜像</h1><p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker pull centos:8</code></pre>\n<p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p>\n<h1 id=\"查找镜像\"><a href=\"#查找镜像\" class=\"headerlink\" title=\"查找镜像\"></a>查找镜像</h1><p>我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <a href=\"https://hub.docker.com/\">https://hub.docker.com/</a><br>我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker search httpd</code></pre>\n<p><img src=\"https://s2.loli.net/2023/01/03/zlKVAxekZowgcYq.png\" alt=\"image.png\"></p>\n<h2 id=\"选项说明-1\"><a href=\"#选项说明-1\" class=\"headerlink\" title=\"选项说明\"></a>选项说明</h2><ul>\n<li>NAME: 镜像仓库源名称</li>\n<li>DESCRIPTION: 镜像的描述</li>\n<li>OFFICIAL: 是否 docker 官方发布</li>\n<li>STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。</li>\n<li>AUTOMATED: 自动构建。<h1 id=\"拖取镜像\"><a href=\"#拖取镜像\" class=\"headerlink\" title=\"拖取镜像\"></a>拖取镜像</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker pull httpd</code></pre>\n下载完后我们就可以使用这个镜像了<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker run httpd</code></pre>\n<h1 id=\"删除镜像\"><a href=\"#删除镜像\" class=\"headerlink\" title=\"删除镜像\"></a>删除镜像</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker rmi httpd</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"列出镜像列表\"><a href=\"#列出镜像列表\" class=\"headerlink\" title=\"列出镜像列表\"></a>列出镜像列表</h1><p>我们可以使用 <code>docker images</code> 来列出本地主机上的镜像</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker images</code></pre>\n<p><img src=\"https://s2.loli.net/2023/01/03/jYuRFcMDSm1Orlx.png\" alt=\"image.png\"></p>\n<h2 id=\"选项说明\"><a href=\"#选项说明\" class=\"headerlink\" title=\"选项说明\"></a>选项说明</h2><ul>\n<li>REPOSITORY: 表示镜像的仓库源</li>\n<li>TAG:　镜像的标签</li>\n<li>IMAGE ID: 镜像ID</li>\n<li>CREATED: 镜像的创建时间</li>\n<li>SIZE: 镜像大小<blockquote>\n<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"获取一个新的镜像\"><a href=\"#获取一个新的镜像\" class=\"headerlink\" title=\"获取一个新的镜像\"></a>获取一个新的镜像</h1><p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker pull centos:8</code></pre>\n<p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p>\n<h1 id=\"查找镜像\"><a href=\"#查找镜像\" class=\"headerlink\" title=\"查找镜像\"></a>查找镜像</h1><p>我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <a href=\"https://hub.docker.com/\">https://hub.docker.com/</a><br>我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker search httpd</code></pre>\n<p><img src=\"https://s2.loli.net/2023/01/03/zlKVAxekZowgcYq.png\" alt=\"image.png\"></p>\n<h2 id=\"选项说明-1\"><a href=\"#选项说明-1\" class=\"headerlink\" title=\"选项说明\"></a>选项说明</h2><ul>\n<li>NAME: 镜像仓库源名称</li>\n<li>DESCRIPTION: 镜像的描述</li>\n<li>OFFICIAL: 是否 docker 官方发布</li>\n<li>STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。</li>\n<li>AUTOMATED: 自动构建。<h1 id=\"拖取镜像\"><a href=\"#拖取镜像\" class=\"headerlink\" title=\"拖取镜像\"></a>拖取镜像</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker pull httpd</code></pre>\n下载完后我们就可以使用这个镜像了<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker run httpd</code></pre>\n<h1 id=\"删除镜像\"><a href=\"#删除镜像\" class=\"headerlink\" title=\"删除镜像\"></a>删除镜像</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker rmi httpd</code></pre></li>\n</ul>\n"},{"title":"tsconfig.json 编译配置","date":"2022-03-05T08:40:02.000Z","cover":"https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png","_content":"\n# tsconfig.json 编译配置\n\n```json\n  {\n    // 设置保存文件的时候自动编译，但需要编译器支持。\n    \"compileOnSave\": false,\n\n    // 编译选项配置\n    \"compilerOptions\": {\n      \"incremental\": true, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n\n      \"tsBuildInfoFile\": \"./buildFile\", // 增量编译文件的存储位置\n\n      \"diagnostics\": true, // 打印诊断信息\n\n      \"target\": \"ES5\", // 目标语言的版本\n\n      \"module\": \"CommonJS\", // 生成代码的模板标准\n\n      \"outFile\": \"./app.js\", // 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置\"module\": \"AMD\",\n\n      \"lib\": [\"DOM\", \"ES2015\", \"ScriptHost\", \"ES2019.Array\"], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入\"ES2019.Array\",\n\n      \"allowJS\": true, // 允许编译器编译JS，JSX文件\n\n      \"checkJs\": true, // 允许在JS文件中报错，通常与allowJS一起使用\n\n      \"outDir\": \"./dist\", // 指定输出目录\n\n      \"rootDir\": \"./\", // 指定输出文件目录(用于输出)，用于控制输出目录结构\n\n      \"declaration\": true, // 生成声明文件，开启后会自动生成声明文件\n\n      \"declarationDir\": \"./file\", // 指定生成声明文件存放目录\n\n      \"emitDeclarationOnly\": true, // 只生成声明文件，而不会生成js文件\n\n      \"sourceMap\": true, // 生成目标文件的sourceMap文件\n\n      \"inlineSourceMap\": true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n\n      \"declarationMap\": true, // 为声明文件生成sourceMap\n\n      \"typeRoots\": [], // 声明文件目录，默认时node_modules/@types\n\n      \"types\": [], // 加载的声明文件包\n\n      \"removeComments\":true, // 删除注释\n\n      \"noEmit\": true, // 不输出文件,即编译后不会生成任何js文件\n\n      \"noEmitOnError\": true, // 发送错误时不输出任何文件\n\n      \"noEmitHelpers\": true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n\n      \"importHelpers\": true, // 通过tslib引入helper函数，文件必须是模块\n\n      \"downlevelIteration\": true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现\n\n      \"strict\": true, // 开启所有严格的类型检查\n\n      \"alwaysStrict\": true, // 在代码中注入'use strict'\n\n      \"noImplicitAny\": true, // 不允许隐式的any类型\n\n      \"strictNullChecks\": true, // 不允许把null、undefined赋值给其他类型的变量\n\n      \"strictFunctionTypes\": true, // 不允许函数参数双向协变\n\n      \"strictPropertyInitialization\": true, // 类的实例属性必须初始化\n\n      \"strictBindCallApply\": true, // 严格的bind/call/apply检查\n\n      \"noImplicitThis\": true, // 不允许this有隐式的any类型\n\n      \"noUnusedLocals\": true, // 检查只声明、未使用的局部变量(只提示不报错)\n\n      \"noUnusedParameters\": true, // 检查未使用的函数参数(只提示不报错)\n\n      \"noFallthroughCasesInSwitch\": true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)\n\n      \"noImplicitReturns\": true, //每个分支都会有返回值\n\n      \"esModuleInterop\": true, // 允许export=导出，由import from 导入\n\n      \"allowUmdGlobalAccess\": true, // 允许在模块中全局变量的方式访问umd模块\n\n      \"moduleResolution\": \"node\", // 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n\n      \"baseUrl\": \"./\", // 解析非相对模块的基地址，默认是当前目录\n\n      \"paths\": { // 路径映射，相对于baseUrl\n        // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n        \"jquery\": [\"node_modules/jquery/dist/jquery.min.js\"]\n      },\n\n      \"rootDirs\": [\"src\",\"out\"], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n\n      \"listEmittedFiles\": true, // 打印输出文件\n\n      \"listFiles\": true// 打印编译的文件(包括引用的声明文件)\n    },\n\n    // include 属性作用是指定编译需要编译的文件或目录。\n    \"include\": [\"./src/**/*\"],\n\n    // exclude 属性作用是指定编译器需要排除的文件或文件夹。默认排除 node_modules 文件夹下文件。\n    \"exclude\": [\"./utils/**/*\"],\n\n    // extends 属性作用是引入其他配置文件，继承配置。\n    \"extends\": \"./tsconfig.base.json\",\n\n    // files 属性作用是指定需要编译的单个文件列表。 默认包含当前目录和子目录下所有 TypeScript 文件。\n    \"files\": [\n      // 指定编译文件是src目录下的leo.ts文件\n      \"scr/leo.ts\"\n    ],\n\n    // references 属性作用是指定工程引用依赖。\n    // 在项目开发中，有时候我们为了方便将前端项目和后端node项目放在同一个目录下开发，两个项目依赖同一个配置文件和通用文件，但我们希望前后端项目进行灵活的分别打包，那么我们可以进行如下配置：\n    \"references\": [ // 指定依赖的工程\n      {\"path\": \"./common\"}\n    ],\n\n    // typeAcquisition 属性作用是设置自动引入库类型定义文件(.d.ts)相关。\n    // enable  : 布尔类型，是否开启自动引入库类型定义文件(.d.ts)，默认为 false；\n    // include  : 数组类型，允许自动引入的库名，如：[\"jquery\", \"lodash\"]；\n    // exculde  : 数组类型，排除的库名。\n    \"typeAcquisition\": {\n      \"enable\": false,\n      \"exclude\": [\"jquery\"],\n      \"include\": [\"jest\"]\n    }\n  }\n```\n","source":"_posts/typescript/tsconfig.json 编译配置.md","raw":"---\ntitle: tsconfig.json 编译配置\ndate: 2022/3/5 16:40:02\ncover: https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png\ncategories:\n  - TypeScript\ntags:\n  - TypeScript\n  - tsconfig\n---\n\n# tsconfig.json 编译配置\n\n```json\n  {\n    // 设置保存文件的时候自动编译，但需要编译器支持。\n    \"compileOnSave\": false,\n\n    // 编译选项配置\n    \"compilerOptions\": {\n      \"incremental\": true, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n\n      \"tsBuildInfoFile\": \"./buildFile\", // 增量编译文件的存储位置\n\n      \"diagnostics\": true, // 打印诊断信息\n\n      \"target\": \"ES5\", // 目标语言的版本\n\n      \"module\": \"CommonJS\", // 生成代码的模板标准\n\n      \"outFile\": \"./app.js\", // 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置\"module\": \"AMD\",\n\n      \"lib\": [\"DOM\", \"ES2015\", \"ScriptHost\", \"ES2019.Array\"], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入\"ES2019.Array\",\n\n      \"allowJS\": true, // 允许编译器编译JS，JSX文件\n\n      \"checkJs\": true, // 允许在JS文件中报错，通常与allowJS一起使用\n\n      \"outDir\": \"./dist\", // 指定输出目录\n\n      \"rootDir\": \"./\", // 指定输出文件目录(用于输出)，用于控制输出目录结构\n\n      \"declaration\": true, // 生成声明文件，开启后会自动生成声明文件\n\n      \"declarationDir\": \"./file\", // 指定生成声明文件存放目录\n\n      \"emitDeclarationOnly\": true, // 只生成声明文件，而不会生成js文件\n\n      \"sourceMap\": true, // 生成目标文件的sourceMap文件\n\n      \"inlineSourceMap\": true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n\n      \"declarationMap\": true, // 为声明文件生成sourceMap\n\n      \"typeRoots\": [], // 声明文件目录，默认时node_modules/@types\n\n      \"types\": [], // 加载的声明文件包\n\n      \"removeComments\":true, // 删除注释\n\n      \"noEmit\": true, // 不输出文件,即编译后不会生成任何js文件\n\n      \"noEmitOnError\": true, // 发送错误时不输出任何文件\n\n      \"noEmitHelpers\": true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n\n      \"importHelpers\": true, // 通过tslib引入helper函数，文件必须是模块\n\n      \"downlevelIteration\": true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现\n\n      \"strict\": true, // 开启所有严格的类型检查\n\n      \"alwaysStrict\": true, // 在代码中注入'use strict'\n\n      \"noImplicitAny\": true, // 不允许隐式的any类型\n\n      \"strictNullChecks\": true, // 不允许把null、undefined赋值给其他类型的变量\n\n      \"strictFunctionTypes\": true, // 不允许函数参数双向协变\n\n      \"strictPropertyInitialization\": true, // 类的实例属性必须初始化\n\n      \"strictBindCallApply\": true, // 严格的bind/call/apply检查\n\n      \"noImplicitThis\": true, // 不允许this有隐式的any类型\n\n      \"noUnusedLocals\": true, // 检查只声明、未使用的局部变量(只提示不报错)\n\n      \"noUnusedParameters\": true, // 检查未使用的函数参数(只提示不报错)\n\n      \"noFallthroughCasesInSwitch\": true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)\n\n      \"noImplicitReturns\": true, //每个分支都会有返回值\n\n      \"esModuleInterop\": true, // 允许export=导出，由import from 导入\n\n      \"allowUmdGlobalAccess\": true, // 允许在模块中全局变量的方式访问umd模块\n\n      \"moduleResolution\": \"node\", // 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n\n      \"baseUrl\": \"./\", // 解析非相对模块的基地址，默认是当前目录\n\n      \"paths\": { // 路径映射，相对于baseUrl\n        // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n        \"jquery\": [\"node_modules/jquery/dist/jquery.min.js\"]\n      },\n\n      \"rootDirs\": [\"src\",\"out\"], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n\n      \"listEmittedFiles\": true, // 打印输出文件\n\n      \"listFiles\": true// 打印编译的文件(包括引用的声明文件)\n    },\n\n    // include 属性作用是指定编译需要编译的文件或目录。\n    \"include\": [\"./src/**/*\"],\n\n    // exclude 属性作用是指定编译器需要排除的文件或文件夹。默认排除 node_modules 文件夹下文件。\n    \"exclude\": [\"./utils/**/*\"],\n\n    // extends 属性作用是引入其他配置文件，继承配置。\n    \"extends\": \"./tsconfig.base.json\",\n\n    // files 属性作用是指定需要编译的单个文件列表。 默认包含当前目录和子目录下所有 TypeScript 文件。\n    \"files\": [\n      // 指定编译文件是src目录下的leo.ts文件\n      \"scr/leo.ts\"\n    ],\n\n    // references 属性作用是指定工程引用依赖。\n    // 在项目开发中，有时候我们为了方便将前端项目和后端node项目放在同一个目录下开发，两个项目依赖同一个配置文件和通用文件，但我们希望前后端项目进行灵活的分别打包，那么我们可以进行如下配置：\n    \"references\": [ // 指定依赖的工程\n      {\"path\": \"./common\"}\n    ],\n\n    // typeAcquisition 属性作用是设置自动引入库类型定义文件(.d.ts)相关。\n    // enable  : 布尔类型，是否开启自动引入库类型定义文件(.d.ts)，默认为 false；\n    // include  : 数组类型，允许自动引入的库名，如：[\"jquery\", \"lodash\"]；\n    // exculde  : 数组类型，排除的库名。\n    \"typeAcquisition\": {\n      \"enable\": false,\n      \"exclude\": [\"jquery\"],\n      \"include\": [\"jest\"]\n    }\n  }\n```\n","slug":"typescript/tsconfig.json 编译配置","published":1,"updated":"2023-01-03T09:02:23.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcq06kzr0007ysvn5lv5ccfs","content":"<h1 id=\"tsconfig-json-编译配置\"><a href=\"#tsconfig-json-编译配置\" class=\"headerlink\" title=\"tsconfig.json 编译配置\"></a>tsconfig.json 编译配置</h1><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &#x2F;&#x2F; 设置保存文件的时候自动编译，但需要编译器支持。\n  &quot;compileOnSave&quot;: false,\n\n  &#x2F;&#x2F; 编译选项配置\n  &quot;compilerOptions&quot;: &#123;\n    &quot;incremental&quot;: true, &#x2F;&#x2F; TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n\n    &quot;tsBuildInfoFile&quot;: &quot;.&#x2F;buildFile&quot;, &#x2F;&#x2F; 增量编译文件的存储位置\n\n    &quot;diagnostics&quot;: true, &#x2F;&#x2F; 打印诊断信息\n\n    &quot;target&quot;: &quot;ES5&quot;, &#x2F;&#x2F; 目标语言的版本\n\n    &quot;module&quot;: &quot;CommonJS&quot;, &#x2F;&#x2F; 生成代码的模板标准\n\n    &quot;outFile&quot;: &quot;.&#x2F;app.js&quot;, &#x2F;&#x2F; 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置&quot;module&quot;: &quot;AMD&quot;,\n\n    &quot;lib&quot;: [&quot;DOM&quot;, &quot;ES2015&quot;, &quot;ScriptHost&quot;, &quot;ES2019.Array&quot;], &#x2F;&#x2F; TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入&quot;ES2019.Array&quot;,\n\n    &quot;allowJS&quot;: true, &#x2F;&#x2F; 允许编译器编译JS，JSX文件\n\n    &quot;checkJs&quot;: true, &#x2F;&#x2F; 允许在JS文件中报错，通常与allowJS一起使用\n\n    &quot;outDir&quot;: &quot;.&#x2F;dist&quot;, &#x2F;&#x2F; 指定输出目录\n\n    &quot;rootDir&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 指定输出文件目录(用于输出)，用于控制输出目录结构\n\n    &quot;declaration&quot;: true, &#x2F;&#x2F; 生成声明文件，开启后会自动生成声明文件\n\n    &quot;declarationDir&quot;: &quot;.&#x2F;file&quot;, &#x2F;&#x2F; 指定生成声明文件存放目录\n\n    &quot;emitDeclarationOnly&quot;: true, &#x2F;&#x2F; 只生成声明文件，而不会生成js文件\n\n    &quot;sourceMap&quot;: true, &#x2F;&#x2F; 生成目标文件的sourceMap文件\n\n    &quot;inlineSourceMap&quot;: true, &#x2F;&#x2F; 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n\n    &quot;declarationMap&quot;: true, &#x2F;&#x2F; 为声明文件生成sourceMap\n\n    &quot;typeRoots&quot;: [], &#x2F;&#x2F; 声明文件目录，默认时node_modules&#x2F;@types\n\n    &quot;types&quot;: [], &#x2F;&#x2F; 加载的声明文件包\n\n    &quot;removeComments&quot;:true, &#x2F;&#x2F; 删除注释\n\n    &quot;noEmit&quot;: true, &#x2F;&#x2F; 不输出文件,即编译后不会生成任何js文件\n\n    &quot;noEmitOnError&quot;: true, &#x2F;&#x2F; 发送错误时不输出任何文件\n\n    &quot;noEmitHelpers&quot;: true, &#x2F;&#x2F; 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n\n    &quot;importHelpers&quot;: true, &#x2F;&#x2F; 通过tslib引入helper函数，文件必须是模块\n\n    &quot;downlevelIteration&quot;: true, &#x2F;&#x2F; 降级遍历器实现，如果目标源是es3&#x2F;5，那么遍历器会有降级的实现\n\n    &quot;strict&quot;: true, &#x2F;&#x2F; 开启所有严格的类型检查\n\n    &quot;alwaysStrict&quot;: true, &#x2F;&#x2F; 在代码中注入&#39;use strict&#39;\n\n    &quot;noImplicitAny&quot;: true, &#x2F;&#x2F; 不允许隐式的any类型\n\n    &quot;strictNullChecks&quot;: true, &#x2F;&#x2F; 不允许把null、undefined赋值给其他类型的变量\n\n    &quot;strictFunctionTypes&quot;: true, &#x2F;&#x2F; 不允许函数参数双向协变\n\n    &quot;strictPropertyInitialization&quot;: true, &#x2F;&#x2F; 类的实例属性必须初始化\n\n    &quot;strictBindCallApply&quot;: true, &#x2F;&#x2F; 严格的bind&#x2F;call&#x2F;apply检查\n\n    &quot;noImplicitThis&quot;: true, &#x2F;&#x2F; 不允许this有隐式的any类型\n\n    &quot;noUnusedLocals&quot;: true, &#x2F;&#x2F; 检查只声明、未使用的局部变量(只提示不报错)\n\n    &quot;noUnusedParameters&quot;: true, &#x2F;&#x2F; 检查未使用的函数参数(只提示不报错)\n\n    &quot;noFallthroughCasesInSwitch&quot;: true, &#x2F;&#x2F; 防止switch语句贯穿(即如果没有break语句后面不会执行)\n\n    &quot;noImplicitReturns&quot;: true, &#x2F;&#x2F;每个分支都会有返回值\n\n    &quot;esModuleInterop&quot;: true, &#x2F;&#x2F; 允许export&#x3D;导出，由import from 导入\n\n    &quot;allowUmdGlobalAccess&quot;: true, &#x2F;&#x2F; 允许在模块中全局变量的方式访问umd模块\n\n    &quot;moduleResolution&quot;: &quot;node&quot;, &#x2F;&#x2F; 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n\n    &quot;baseUrl&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 解析非相对模块的基地址，默认是当前目录\n\n    &quot;paths&quot;: &#123; &#x2F;&#x2F; 路径映射，相对于baseUrl\n      &#x2F;&#x2F; 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n      &quot;jquery&quot;: [&quot;node_modules&#x2F;jquery&#x2F;dist&#x2F;jquery.min.js&quot;]\n    &#125;,\n\n    &quot;rootDirs&quot;: [&quot;src&quot;,&quot;out&quot;], &#x2F;&#x2F; 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n\n    &quot;listEmittedFiles&quot;: true, &#x2F;&#x2F; 打印输出文件\n\n    &quot;listFiles&quot;: true&#x2F;&#x2F; 打印编译的文件(包括引用的声明文件)\n  &#125;,\n\n  &#x2F;&#x2F; include 属性作用是指定编译需要编译的文件或目录。\n  &quot;include&quot;: [&quot;.&#x2F;src&#x2F;**&#x2F;*&quot;],\n\n  &#x2F;&#x2F; exclude 属性作用是指定编译器需要排除的文件或文件夹。默认排除 node_modules 文件夹下文件。\n  &quot;exclude&quot;: [&quot;.&#x2F;utils&#x2F;**&#x2F;*&quot;],\n\n  &#x2F;&#x2F; extends 属性作用是引入其他配置文件，继承配置。\n  &quot;extends&quot;: &quot;.&#x2F;tsconfig.base.json&quot;,\n\n  &#x2F;&#x2F; files 属性作用是指定需要编译的单个文件列表。 默认包含当前目录和子目录下所有 TypeScript 文件。\n  &quot;files&quot;: [\n    &#x2F;&#x2F; 指定编译文件是src目录下的leo.ts文件\n    &quot;scr&#x2F;leo.ts&quot;\n  ],\n\n  &#x2F;&#x2F; references 属性作用是指定工程引用依赖。\n  &#x2F;&#x2F; 在项目开发中，有时候我们为了方便将前端项目和后端node项目放在同一个目录下开发，两个项目依赖同一个配置文件和通用文件，但我们希望前后端项目进行灵活的分别打包，那么我们可以进行如下配置：\n  &quot;references&quot;: [ &#x2F;&#x2F; 指定依赖的工程\n    &#123;&quot;path&quot;: &quot;.&#x2F;common&quot;&#125;\n  ],\n\n  &#x2F;&#x2F; typeAcquisition 属性作用是设置自动引入库类型定义文件(.d.ts)相关。\n  &#x2F;&#x2F; enable  : 布尔类型，是否开启自动引入库类型定义文件(.d.ts)，默认为 false；\n  &#x2F;&#x2F; include  : 数组类型，允许自动引入的库名，如：[&quot;jquery&quot;, &quot;lodash&quot;]；\n  &#x2F;&#x2F; exculde  : 数组类型，排除的库名。\n  &quot;typeAcquisition&quot;: &#123;\n    &quot;enable&quot;: false,\n    &quot;exclude&quot;: [&quot;jquery&quot;],\n    &quot;include&quot;: [&quot;jest&quot;]\n  &#125;\n&#125;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"tsconfig-json-编译配置\"><a href=\"#tsconfig-json-编译配置\" class=\"headerlink\" title=\"tsconfig.json 编译配置\"></a>tsconfig.json 编译配置</h1><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &#x2F;&#x2F; 设置保存文件的时候自动编译，但需要编译器支持。\n  &quot;compileOnSave&quot;: false,\n\n  &#x2F;&#x2F; 编译选项配置\n  &quot;compilerOptions&quot;: &#123;\n    &quot;incremental&quot;: true, &#x2F;&#x2F; TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n\n    &quot;tsBuildInfoFile&quot;: &quot;.&#x2F;buildFile&quot;, &#x2F;&#x2F; 增量编译文件的存储位置\n\n    &quot;diagnostics&quot;: true, &#x2F;&#x2F; 打印诊断信息\n\n    &quot;target&quot;: &quot;ES5&quot;, &#x2F;&#x2F; 目标语言的版本\n\n    &quot;module&quot;: &quot;CommonJS&quot;, &#x2F;&#x2F; 生成代码的模板标准\n\n    &quot;outFile&quot;: &quot;.&#x2F;app.js&quot;, &#x2F;&#x2F; 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置&quot;module&quot;: &quot;AMD&quot;,\n\n    &quot;lib&quot;: [&quot;DOM&quot;, &quot;ES2015&quot;, &quot;ScriptHost&quot;, &quot;ES2019.Array&quot;], &#x2F;&#x2F; TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入&quot;ES2019.Array&quot;,\n\n    &quot;allowJS&quot;: true, &#x2F;&#x2F; 允许编译器编译JS，JSX文件\n\n    &quot;checkJs&quot;: true, &#x2F;&#x2F; 允许在JS文件中报错，通常与allowJS一起使用\n\n    &quot;outDir&quot;: &quot;.&#x2F;dist&quot;, &#x2F;&#x2F; 指定输出目录\n\n    &quot;rootDir&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 指定输出文件目录(用于输出)，用于控制输出目录结构\n\n    &quot;declaration&quot;: true, &#x2F;&#x2F; 生成声明文件，开启后会自动生成声明文件\n\n    &quot;declarationDir&quot;: &quot;.&#x2F;file&quot;, &#x2F;&#x2F; 指定生成声明文件存放目录\n\n    &quot;emitDeclarationOnly&quot;: true, &#x2F;&#x2F; 只生成声明文件，而不会生成js文件\n\n    &quot;sourceMap&quot;: true, &#x2F;&#x2F; 生成目标文件的sourceMap文件\n\n    &quot;inlineSourceMap&quot;: true, &#x2F;&#x2F; 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n\n    &quot;declarationMap&quot;: true, &#x2F;&#x2F; 为声明文件生成sourceMap\n\n    &quot;typeRoots&quot;: [], &#x2F;&#x2F; 声明文件目录，默认时node_modules&#x2F;@types\n\n    &quot;types&quot;: [], &#x2F;&#x2F; 加载的声明文件包\n\n    &quot;removeComments&quot;:true, &#x2F;&#x2F; 删除注释\n\n    &quot;noEmit&quot;: true, &#x2F;&#x2F; 不输出文件,即编译后不会生成任何js文件\n\n    &quot;noEmitOnError&quot;: true, &#x2F;&#x2F; 发送错误时不输出任何文件\n\n    &quot;noEmitHelpers&quot;: true, &#x2F;&#x2F; 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n\n    &quot;importHelpers&quot;: true, &#x2F;&#x2F; 通过tslib引入helper函数，文件必须是模块\n\n    &quot;downlevelIteration&quot;: true, &#x2F;&#x2F; 降级遍历器实现，如果目标源是es3&#x2F;5，那么遍历器会有降级的实现\n\n    &quot;strict&quot;: true, &#x2F;&#x2F; 开启所有严格的类型检查\n\n    &quot;alwaysStrict&quot;: true, &#x2F;&#x2F; 在代码中注入&#39;use strict&#39;\n\n    &quot;noImplicitAny&quot;: true, &#x2F;&#x2F; 不允许隐式的any类型\n\n    &quot;strictNullChecks&quot;: true, &#x2F;&#x2F; 不允许把null、undefined赋值给其他类型的变量\n\n    &quot;strictFunctionTypes&quot;: true, &#x2F;&#x2F; 不允许函数参数双向协变\n\n    &quot;strictPropertyInitialization&quot;: true, &#x2F;&#x2F; 类的实例属性必须初始化\n\n    &quot;strictBindCallApply&quot;: true, &#x2F;&#x2F; 严格的bind&#x2F;call&#x2F;apply检查\n\n    &quot;noImplicitThis&quot;: true, &#x2F;&#x2F; 不允许this有隐式的any类型\n\n    &quot;noUnusedLocals&quot;: true, &#x2F;&#x2F; 检查只声明、未使用的局部变量(只提示不报错)\n\n    &quot;noUnusedParameters&quot;: true, &#x2F;&#x2F; 检查未使用的函数参数(只提示不报错)\n\n    &quot;noFallthroughCasesInSwitch&quot;: true, &#x2F;&#x2F; 防止switch语句贯穿(即如果没有break语句后面不会执行)\n\n    &quot;noImplicitReturns&quot;: true, &#x2F;&#x2F;每个分支都会有返回值\n\n    &quot;esModuleInterop&quot;: true, &#x2F;&#x2F; 允许export&#x3D;导出，由import from 导入\n\n    &quot;allowUmdGlobalAccess&quot;: true, &#x2F;&#x2F; 允许在模块中全局变量的方式访问umd模块\n\n    &quot;moduleResolution&quot;: &quot;node&quot;, &#x2F;&#x2F; 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n\n    &quot;baseUrl&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 解析非相对模块的基地址，默认是当前目录\n\n    &quot;paths&quot;: &#123; &#x2F;&#x2F; 路径映射，相对于baseUrl\n      &#x2F;&#x2F; 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n      &quot;jquery&quot;: [&quot;node_modules&#x2F;jquery&#x2F;dist&#x2F;jquery.min.js&quot;]\n    &#125;,\n\n    &quot;rootDirs&quot;: [&quot;src&quot;,&quot;out&quot;], &#x2F;&#x2F; 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n\n    &quot;listEmittedFiles&quot;: true, &#x2F;&#x2F; 打印输出文件\n\n    &quot;listFiles&quot;: true&#x2F;&#x2F; 打印编译的文件(包括引用的声明文件)\n  &#125;,\n\n  &#x2F;&#x2F; include 属性作用是指定编译需要编译的文件或目录。\n  &quot;include&quot;: [&quot;.&#x2F;src&#x2F;**&#x2F;*&quot;],\n\n  &#x2F;&#x2F; exclude 属性作用是指定编译器需要排除的文件或文件夹。默认排除 node_modules 文件夹下文件。\n  &quot;exclude&quot;: [&quot;.&#x2F;utils&#x2F;**&#x2F;*&quot;],\n\n  &#x2F;&#x2F; extends 属性作用是引入其他配置文件，继承配置。\n  &quot;extends&quot;: &quot;.&#x2F;tsconfig.base.json&quot;,\n\n  &#x2F;&#x2F; files 属性作用是指定需要编译的单个文件列表。 默认包含当前目录和子目录下所有 TypeScript 文件。\n  &quot;files&quot;: [\n    &#x2F;&#x2F; 指定编译文件是src目录下的leo.ts文件\n    &quot;scr&#x2F;leo.ts&quot;\n  ],\n\n  &#x2F;&#x2F; references 属性作用是指定工程引用依赖。\n  &#x2F;&#x2F; 在项目开发中，有时候我们为了方便将前端项目和后端node项目放在同一个目录下开发，两个项目依赖同一个配置文件和通用文件，但我们希望前后端项目进行灵活的分别打包，那么我们可以进行如下配置：\n  &quot;references&quot;: [ &#x2F;&#x2F; 指定依赖的工程\n    &#123;&quot;path&quot;: &quot;.&#x2F;common&quot;&#125;\n  ],\n\n  &#x2F;&#x2F; typeAcquisition 属性作用是设置自动引入库类型定义文件(.d.ts)相关。\n  &#x2F;&#x2F; enable  : 布尔类型，是否开启自动引入库类型定义文件(.d.ts)，默认为 false；\n  &#x2F;&#x2F; include  : 数组类型，允许自动引入的库名，如：[&quot;jquery&quot;, &quot;lodash&quot;]；\n  &#x2F;&#x2F; exculde  : 数组类型，排除的库名。\n  &quot;typeAcquisition&quot;: &#123;\n    &quot;enable&quot;: false,\n    &quot;exclude&quot;: [&quot;jquery&quot;],\n    &quot;include&quot;: [&quot;jest&quot;]\n  &#125;\n&#125;</code></pre>\n"},{"title":"TypeScript的数据类型","date":"2022-03-05T08:47:36.000Z","cover":"https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png","_content":"\n# TypeScript的数据类型\n\n> 变量一但定义了某个数据类型后就不允许赋值其他数据类型的数值了\n\n\n## 基础数据类型\n\n### number\n\n### string\n\n### boolean\n\n### void\n\n### null\n\n### undefinded\n\n### any (使用 TS 时不建议使用 any 类型)\n\n```typescript\n// 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet d; <=> let d: any;\n\n// any 类型还可以赋值给任意类型的变量\nlet s: string;\ns = d // 这时候是成立的\n```\n\n### unknown\n\n```typescript\n// 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet un: unknown;\n\n// any 类型还可以赋值给任意类型的变量\nlet s: string;\ns = un // 这时候是不成立的\n// 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n// unknown 实际上就是一个类型安全的 any\n// unknown 类型的变量不能直接赋值给其他类型的变量,可以间接实现\nif (typeof un === 'string') {\n  s = un; // 由于先进行了类型判断, 所以这时候赋值是成立的\n}\n```\n\n### enum(枚举类型)\n\n```typescript\n// 使用场景\nenum Gender {\n  male,\n  female\n}\n\nlet p: { name: string, gender: Gender }\np = {\n  name: '林丹',\n  gnder: Gender.male\n}\n```\n\n## 引用数据类型\n\n### array\n\n### object\n\n```typescript\n// 基础的定义方式\n// 由于在 js 中几乎万物皆是对象,所以不推荐这样使用\nlet o: object\no = {}\no = function\n\n// 可以用字面量的方式\nlet o1: { name: string, age: number }\no1 = { name: 'hanler', age: 12 }\n\n// 如果要可选常数则在常数后面加个问号\nlet o2: { name: string, age?: number }\no2 = { name: 'hehe' }\n\n// 当你需要一个固定值, 但是又需要其他值且不清楚数量的时候可以像以下定义\n/**\n * @param {string} propsName 这个是属性名, 后面的 string 代表的是 string 格式的属性名\n * 中括号后面的 string 代表的是属性(propsName)的值的格式\n * */\nlet o3: { name: string, [propsName: string]: string }\no3 = { name: 'str', age: '12' }\n```\n\n## 类型断言\n\n> 可以用来告诉 ts 解析器变量的实际数据类型\n\n\n```typescript\nlet un: nuknown;\nun = 'string'\n\nlet s: string;\n\ns = un; // 此时是不成立的\n// 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n// 由于此时的 un 确实是 string 类型,我们可以使用类型断言来告诉解析器 un 就是 string 类型的来解决解析器报错问题\n\n// 两种写法\ns = un as string;\ns = <string>un;\n```\n","source":"_posts/typescript/TypeScript的数据类型.md","raw":"---\ntitle: TypeScript的数据类型\ndate: 2022/3/5 16:47:36\ncover: https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png\ncategories:\n  - TypeScript\ntags:\n  - TypeScript\n  - 数据类型\n---\n\n# TypeScript的数据类型\n\n> 变量一但定义了某个数据类型后就不允许赋值其他数据类型的数值了\n\n\n## 基础数据类型\n\n### number\n\n### string\n\n### boolean\n\n### void\n\n### null\n\n### undefinded\n\n### any (使用 TS 时不建议使用 any 类型)\n\n```typescript\n// 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet d; <=> let d: any;\n\n// any 类型还可以赋值给任意类型的变量\nlet s: string;\ns = d // 这时候是成立的\n```\n\n### unknown\n\n```typescript\n// 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet un: unknown;\n\n// any 类型还可以赋值给任意类型的变量\nlet s: string;\ns = un // 这时候是不成立的\n// 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n// unknown 实际上就是一个类型安全的 any\n// unknown 类型的变量不能直接赋值给其他类型的变量,可以间接实现\nif (typeof un === 'string') {\n  s = un; // 由于先进行了类型判断, 所以这时候赋值是成立的\n}\n```\n\n### enum(枚举类型)\n\n```typescript\n// 使用场景\nenum Gender {\n  male,\n  female\n}\n\nlet p: { name: string, gender: Gender }\np = {\n  name: '林丹',\n  gnder: Gender.male\n}\n```\n\n## 引用数据类型\n\n### array\n\n### object\n\n```typescript\n// 基础的定义方式\n// 由于在 js 中几乎万物皆是对象,所以不推荐这样使用\nlet o: object\no = {}\no = function\n\n// 可以用字面量的方式\nlet o1: { name: string, age: number }\no1 = { name: 'hanler', age: 12 }\n\n// 如果要可选常数则在常数后面加个问号\nlet o2: { name: string, age?: number }\no2 = { name: 'hehe' }\n\n// 当你需要一个固定值, 但是又需要其他值且不清楚数量的时候可以像以下定义\n/**\n * @param {string} propsName 这个是属性名, 后面的 string 代表的是 string 格式的属性名\n * 中括号后面的 string 代表的是属性(propsName)的值的格式\n * */\nlet o3: { name: string, [propsName: string]: string }\no3 = { name: 'str', age: '12' }\n```\n\n## 类型断言\n\n> 可以用来告诉 ts 解析器变量的实际数据类型\n\n\n```typescript\nlet un: nuknown;\nun = 'string'\n\nlet s: string;\n\ns = un; // 此时是不成立的\n// 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n// 由于此时的 un 确实是 string 类型,我们可以使用类型断言来告诉解析器 un 就是 string 类型的来解决解析器报错问题\n\n// 两种写法\ns = un as string;\ns = <string>un;\n```\n","slug":"typescript/TypeScript的数据类型","published":1,"updated":"2023-01-03T09:02:23.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcq06kzu000aysvnf5zlgsp1","content":"<h1 id=\"TypeScript的数据类型\"><a href=\"#TypeScript的数据类型\" class=\"headerlink\" title=\"TypeScript的数据类型\"></a>TypeScript的数据类型</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>变量一但定义了某个数据类型后就不允许赋值其他数据类型的数值了</p></blockquote>\n<h2 id=\"基础数据类型\"><a href=\"#基础数据类型\" class=\"headerlink\" title=\"基础数据类型\"></a>基础数据类型</h2><h3 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\"number\"></a>number</h3><h3 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h3><h3 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h3><h3 id=\"void\"><a href=\"#void\" class=\"headerlink\" title=\"void\"></a>void</h3><h3 id=\"null\"><a href=\"#null\" class=\"headerlink\" title=\"null\"></a>null</h3><h3 id=\"undefinded\"><a href=\"#undefinded\" class=\"headerlink\" title=\"undefinded\"></a>undefinded</h3><h3 id=\"any-使用-TS-时不建议使用-any-类型\"><a href=\"#any-使用-TS-时不建议使用-any-类型\" class=\"headerlink\" title=\"any (使用 TS 时不建议使用 any 类型)\"></a>any (使用 TS 时不建议使用 any 类型)</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet d; &lt;&#x3D;&gt; let d: any;\n\n&#x2F;&#x2F; any 类型还可以赋值给任意类型的变量\nlet s: string;\ns &#x3D; d &#x2F;&#x2F; 这时候是成立的</code></pre>\n\n<h3 id=\"unknown\"><a href=\"#unknown\" class=\"headerlink\" title=\"unknown\"></a>unknown</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet un: unknown;\n\n&#x2F;&#x2F; any 类型还可以赋值给任意类型的变量\nlet s: string;\ns &#x3D; un &#x2F;&#x2F; 这时候是不成立的\n&#x2F;&#x2F; 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n&#x2F;&#x2F; unknown 实际上就是一个类型安全的 any\n&#x2F;&#x2F; unknown 类型的变量不能直接赋值给其他类型的变量,可以间接实现\nif (typeof un &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;\n  s &#x3D; un; &#x2F;&#x2F; 由于先进行了类型判断, 所以这时候赋值是成立的\n&#125;</code></pre>\n\n<h3 id=\"enum-枚举类型\"><a href=\"#enum-枚举类型\" class=\"headerlink\" title=\"enum(枚举类型)\"></a>enum(枚举类型)</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 使用场景\nenum Gender &#123;\n  male,\n  female\n&#125;\n\nlet p: &#123; name: string, gender: Gender &#125;\np &#x3D; &#123;\n  name: &#39;林丹&#39;,\n  gnder: Gender.male\n&#125;</code></pre>\n\n<h2 id=\"引用数据类型\"><a href=\"#引用数据类型\" class=\"headerlink\" title=\"引用数据类型\"></a>引用数据类型</h2><h3 id=\"array\"><a href=\"#array\" class=\"headerlink\" title=\"array\"></a>array</h3><h3 id=\"object\"><a href=\"#object\" class=\"headerlink\" title=\"object\"></a>object</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 基础的定义方式\n&#x2F;&#x2F; 由于在 js 中几乎万物皆是对象,所以不推荐这样使用\nlet o: object\no &#x3D; &#123;&#125;\no &#x3D; function\n\n&#x2F;&#x2F; 可以用字面量的方式\nlet o1: &#123; name: string, age: number &#125;\no1 &#x3D; &#123; name: &#39;hanler&#39;, age: 12 &#125;\n\n&#x2F;&#x2F; 如果要可选常数则在常数后面加个问号\nlet o2: &#123; name: string, age?: number &#125;\no2 &#x3D; &#123; name: &#39;hehe&#39; &#125;\n\n&#x2F;&#x2F; 当你需要一个固定值, 但是又需要其他值且不清楚数量的时候可以像以下定义\n&#x2F;**\n * @param &#123;string&#125; propsName 这个是属性名, 后面的 string 代表的是 string 格式的属性名\n * 中括号后面的 string 代表的是属性(propsName)的值的格式\n * *&#x2F;\nlet o3: &#123; name: string, [propsName: string]: string &#125;\no3 &#x3D; &#123; name: &#39;str&#39;, age: &#39;12&#39; &#125;</code></pre>\n\n<h2 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>可以用来告诉 ts 解析器变量的实际数据类型</p></blockquote>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let un: nuknown;\nun &#x3D; &#39;string&#39;\n\nlet s: string;\n\ns &#x3D; un; &#x2F;&#x2F; 此时是不成立的\n&#x2F;&#x2F; 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n&#x2F;&#x2F; 由于此时的 un 确实是 string 类型,我们可以使用类型断言来告诉解析器 un 就是 string 类型的来解决解析器报错问题\n\n&#x2F;&#x2F; 两种写法\ns &#x3D; un as string;\ns &#x3D; &lt;string&gt;un;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"TypeScript的数据类型\"><a href=\"#TypeScript的数据类型\" class=\"headerlink\" title=\"TypeScript的数据类型\"></a>TypeScript的数据类型</h1><blockquote>\n<p>变量一但定义了某个数据类型后就不允许赋值其他数据类型的数值了</p>\n</blockquote>\n<h2 id=\"基础数据类型\"><a href=\"#基础数据类型\" class=\"headerlink\" title=\"基础数据类型\"></a>基础数据类型</h2><h3 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\"number\"></a>number</h3><h3 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h3><h3 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h3><h3 id=\"void\"><a href=\"#void\" class=\"headerlink\" title=\"void\"></a>void</h3><h3 id=\"null\"><a href=\"#null\" class=\"headerlink\" title=\"null\"></a>null</h3><h3 id=\"undefinded\"><a href=\"#undefinded\" class=\"headerlink\" title=\"undefinded\"></a>undefinded</h3><h3 id=\"any-使用-TS-时不建议使用-any-类型\"><a href=\"#any-使用-TS-时不建议使用-any-类型\" class=\"headerlink\" title=\"any (使用 TS 时不建议使用 any 类型)\"></a>any (使用 TS 时不建议使用 any 类型)</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet d; &lt;&#x3D;&gt; let d: any;\n\n&#x2F;&#x2F; any 类型还可以赋值给任意类型的变量\nlet s: string;\ns &#x3D; d &#x2F;&#x2F; 这时候是成立的</code></pre>\n\n<h3 id=\"unknown\"><a href=\"#unknown\" class=\"headerlink\" title=\"unknown\"></a>unknown</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet un: unknown;\n\n&#x2F;&#x2F; any 类型还可以赋值给任意类型的变量\nlet s: string;\ns &#x3D; un &#x2F;&#x2F; 这时候是不成立的\n&#x2F;&#x2F; 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n&#x2F;&#x2F; unknown 实际上就是一个类型安全的 any\n&#x2F;&#x2F; unknown 类型的变量不能直接赋值给其他类型的变量,可以间接实现\nif (typeof un &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;\n  s &#x3D; un; &#x2F;&#x2F; 由于先进行了类型判断, 所以这时候赋值是成立的\n&#125;</code></pre>\n\n<h3 id=\"enum-枚举类型\"><a href=\"#enum-枚举类型\" class=\"headerlink\" title=\"enum(枚举类型)\"></a>enum(枚举类型)</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 使用场景\nenum Gender &#123;\n  male,\n  female\n&#125;\n\nlet p: &#123; name: string, gender: Gender &#125;\np &#x3D; &#123;\n  name: &#39;林丹&#39;,\n  gnder: Gender.male\n&#125;</code></pre>\n\n<h2 id=\"引用数据类型\"><a href=\"#引用数据类型\" class=\"headerlink\" title=\"引用数据类型\"></a>引用数据类型</h2><h3 id=\"array\"><a href=\"#array\" class=\"headerlink\" title=\"array\"></a>array</h3><h3 id=\"object\"><a href=\"#object\" class=\"headerlink\" title=\"object\"></a>object</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 基础的定义方式\n&#x2F;&#x2F; 由于在 js 中几乎万物皆是对象,所以不推荐这样使用\nlet o: object\no &#x3D; &#123;&#125;\no &#x3D; function\n\n&#x2F;&#x2F; 可以用字面量的方式\nlet o1: &#123; name: string, age: number &#125;\no1 &#x3D; &#123; name: &#39;hanler&#39;, age: 12 &#125;\n\n&#x2F;&#x2F; 如果要可选常数则在常数后面加个问号\nlet o2: &#123; name: string, age?: number &#125;\no2 &#x3D; &#123; name: &#39;hehe&#39; &#125;\n\n&#x2F;&#x2F; 当你需要一个固定值, 但是又需要其他值且不清楚数量的时候可以像以下定义\n&#x2F;**\n * @param &#123;string&#125; propsName 这个是属性名, 后面的 string 代表的是 string 格式的属性名\n * 中括号后面的 string 代表的是属性(propsName)的值的格式\n * *&#x2F;\nlet o3: &#123; name: string, [propsName: string]: string &#125;\no3 &#x3D; &#123; name: &#39;str&#39;, age: &#39;12&#39; &#125;</code></pre>\n\n<h2 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h2><blockquote>\n<p>可以用来告诉 ts 解析器变量的实际数据类型</p>\n</blockquote>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let un: nuknown;\nun &#x3D; &#39;string&#39;\n\nlet s: string;\n\ns &#x3D; un; &#x2F;&#x2F; 此时是不成立的\n&#x2F;&#x2F; 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n&#x2F;&#x2F; 由于此时的 un 确实是 string 类型,我们可以使用类型断言来告诉解析器 un 就是 string 类型的来解决解析器报错问题\n\n&#x2F;&#x2F; 两种写法\ns &#x3D; un as string;\ns &#x3D; &lt;string&gt;un;</code></pre>\n"},{"title":"webpack 创建简单的 ts 开发环境","date":"2022-03-05T08:55:46.000Z","cover":"https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png","_content":"\n# webpack 创建简单的 ts 开发环境\n\n## 前置要求\n\n需要的的 `npm` 插件\n\n>\n> 1. webpack ( webpack 本体 )\n> 2. webpack-cli ( webpack 的命令行工具 )\n> 3. typescript ( typescript 核心代码 )\n> 4. ts-loader (typescript 的 webpck 编译模块)\n> 5. clean-webpack-plugin ( 打包前清除之前打包的文件夹 )\n>\n\n\n\n## ts 开发环境目录\n![Snipaste_2022-03-05_15-32-16.png](https://s2.loli.net/2023/01/03/XS1lVDEMyifWocg.png)\n\n## tsconfig.json 配置\n\n```json\n  {\n    \"compilerOptions\": {\n\n      \"module\": \"ES6\",             // 使用的模块规则\n\n      \"target\": \"ES6\",             // 编译生成 js 的版本\n\n      \"noImplicitAny\": true,       // 不允许隐式的 any 类型\n\n      \"removeComments\": true,      // 删除注释\n\n      \"preserveConstEnums\": true,  // 保留 const 和 enum 声明\n\n      \"strict\": true               // 使用严格模式\n    },\n\n    // 需要编译的 ts 文件\n    \"include\": [\n      \"./src/**/*\"\n    ]\n  }\n```\n\n## webpack.config.js 配置\n\n### 基本配置\n\n```javascript\n  const path = require(\"path\")\n  const { CleanWebpackPlugin } = require(\"clean-webpack-plugin\")\n\n  module.exports = {\n    // 入口文件\n    entry: \"./src/index.ts\",\n\n    // 打包后的出口文件\n    output: {\n      // 文件路径\n      path: path.resolve(__dirname, \"dist\"),\n\n      // 文件名\n      filename: \"bundle.js\",\n    },\n    // 使用的编译模块\n    module: {\n\n      // 指定要加载的规则\n      rules: [\n        {\n          // test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n          test: /\\.ts$/,\n\n          // 要使用的 loader\n          use: ['ts-loader'],\n\n          // 排除要编译的文件夹\n          exclude: /node_modules/\n        }\n      ]\n    },\n\n    // 用来设置需要引用的模块文件 (这里包括了 ts 和 js) 不设置的话, 引用其他 ts/js 文件会编译报错\n    resolve: {\n      extensions: ['.ts', '.js']\n    },\n\n    // 配置 webpack 插件\n    plugins: [\n      new CleanWebpackPlugin()\n    ],\n  }\n```\n\n### 使用 html 文件配置\n\n> 前端项目中我们编译完的 js 文件最终会用到 html 文件中. 我们手动创建并引入 js 的话也不是不行, 但是很麻烦, 如果以后要增加一些其他的 js 或者 css 都得重新去手动引入. 这时候就可以用 `webpack` 给我们提供的一个自动引入经过 loader 编译后的文件 html 的插件 `html-webpack-plugin`\n>\n> `**_npm install -D html-webpack-plugin_**`\n\n\n在最外层的 `plugins` 中配置\n\n[更多 html-webpack-plugin 的配置信息看这里](https://github.com/jantimon/html-webpack-plugin#configuration)\n\n```javascript\n  // 引入插件\n  const HtmlWebpackPlugin = require(\"html-webpack-plugin\")\n\n  module.exprots = {\n    // 配置 webpack 插件\n    plugins: [\n      new HtmlWebpackPlugin({\n        // 配置 html 模板文件的目录\n        template: path.resolve(__dirname, 'public/index.html')\n      })\n    ],\n  }\n```\n\n### 使用 webpack-server 实时编译\n\n> 弄好 `html` 自动引入后我们需要打开网页去调试我们的 ts 程序, 按照普通方式来修改一次又要打包一遍, 又要重新刷新一遍网页的话就很麻烦, 这时我们可以用 `webpack-server` 来进行开发服务器部署\n>\n> `**_npm install -D webpack-server_**`\n>\n> 安装完后直接在 `package.json` 中进行配置运行命令运行就行了\n\n\n```json\n  {\n    \"scripts\": {\n      \"dev\": \"webpack server --mode development\"\n    }\n  }\n```\n\n### 配置 babel 来进行浏览器兼容\n\n在日常的开发中我们会经常遇到要兼容低版本浏览器的需要, 这时候为了增加开发效率我们可以用 `**_babel_**` 来将一些 `**_ES6_**` 中的高级属性来转换为低版本浏览器中的兼容属性\n\n需要的开发依赖\n\n>\n> 1. @babel/core ( babel 的核心代码 )\n> 2. @babel/preset-env ( babel 的兼容库 )\n> 3. core-js ( 高级属性的兼容性替代方案 )\n>\n\n> `**_npm install -D @babel/core @babel/preset-env core-js_**`\n\n\nwebpack 配置\n\n```javascript\n\n  module.exports = {\n\n    // 使用的编译模块\n    module: {\n      // 指定要加载的规则\n      rules: [\n        {\n          // test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n          test: /\\.ts$/,\n\n          // 要使用的 loader\n          use: [\n\n            // 配置 babel\n            {\n              // 指定要用的加载器\n              loader: 'babel-loader',\n\n              options: {\n                // 设置预定义的环境\n                presets: [\n                  [\n                    \"@babel-preset-env\",\n\n                    {\n                      // 需要兼容的目标浏览器, 根据项目需求填写\n                      targets: {\n                        \"chrome\": 95\n                      },\n\n                      // 指定的 core 版本\n                      \"corejs\": '3',\n\n                      // 使用 corejs 的方式 \"usage\" 按需加载\n                      \"useBuiltIns\": \"usage\"\n                    }\n                  ]\n                ]\n              }\n            },\n\n            // 由于 webpack 中 rules 是从数组从后往前执行的, 所以 ts-loader 放在后面, 让 ts 先编译为 js 在通过 babel 进行兼容性转换\n            'ts-loader'\n          ],\n        }\n      ]\n    }\n  }\n```\n","source":"_posts/typescript/webpack 搭建 ts 开发环境.md","raw":"---\ntitle: webpack 创建简单的 ts 开发环境\ndate: 2022/3/5 16:55:46\ncover: https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png\ncategories:\n  - TypeScript\ntags:\n  - TypeScript\n  - 环境搭建\n  - webpack\n---\n\n# webpack 创建简单的 ts 开发环境\n\n## 前置要求\n\n需要的的 `npm` 插件\n\n>\n> 1. webpack ( webpack 本体 )\n> 2. webpack-cli ( webpack 的命令行工具 )\n> 3. typescript ( typescript 核心代码 )\n> 4. ts-loader (typescript 的 webpck 编译模块)\n> 5. clean-webpack-plugin ( 打包前清除之前打包的文件夹 )\n>\n\n\n\n## ts 开发环境目录\n![Snipaste_2022-03-05_15-32-16.png](https://s2.loli.net/2023/01/03/XS1lVDEMyifWocg.png)\n\n## tsconfig.json 配置\n\n```json\n  {\n    \"compilerOptions\": {\n\n      \"module\": \"ES6\",             // 使用的模块规则\n\n      \"target\": \"ES6\",             // 编译生成 js 的版本\n\n      \"noImplicitAny\": true,       // 不允许隐式的 any 类型\n\n      \"removeComments\": true,      // 删除注释\n\n      \"preserveConstEnums\": true,  // 保留 const 和 enum 声明\n\n      \"strict\": true               // 使用严格模式\n    },\n\n    // 需要编译的 ts 文件\n    \"include\": [\n      \"./src/**/*\"\n    ]\n  }\n```\n\n## webpack.config.js 配置\n\n### 基本配置\n\n```javascript\n  const path = require(\"path\")\n  const { CleanWebpackPlugin } = require(\"clean-webpack-plugin\")\n\n  module.exports = {\n    // 入口文件\n    entry: \"./src/index.ts\",\n\n    // 打包后的出口文件\n    output: {\n      // 文件路径\n      path: path.resolve(__dirname, \"dist\"),\n\n      // 文件名\n      filename: \"bundle.js\",\n    },\n    // 使用的编译模块\n    module: {\n\n      // 指定要加载的规则\n      rules: [\n        {\n          // test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n          test: /\\.ts$/,\n\n          // 要使用的 loader\n          use: ['ts-loader'],\n\n          // 排除要编译的文件夹\n          exclude: /node_modules/\n        }\n      ]\n    },\n\n    // 用来设置需要引用的模块文件 (这里包括了 ts 和 js) 不设置的话, 引用其他 ts/js 文件会编译报错\n    resolve: {\n      extensions: ['.ts', '.js']\n    },\n\n    // 配置 webpack 插件\n    plugins: [\n      new CleanWebpackPlugin()\n    ],\n  }\n```\n\n### 使用 html 文件配置\n\n> 前端项目中我们编译完的 js 文件最终会用到 html 文件中. 我们手动创建并引入 js 的话也不是不行, 但是很麻烦, 如果以后要增加一些其他的 js 或者 css 都得重新去手动引入. 这时候就可以用 `webpack` 给我们提供的一个自动引入经过 loader 编译后的文件 html 的插件 `html-webpack-plugin`\n>\n> `**_npm install -D html-webpack-plugin_**`\n\n\n在最外层的 `plugins` 中配置\n\n[更多 html-webpack-plugin 的配置信息看这里](https://github.com/jantimon/html-webpack-plugin#configuration)\n\n```javascript\n  // 引入插件\n  const HtmlWebpackPlugin = require(\"html-webpack-plugin\")\n\n  module.exprots = {\n    // 配置 webpack 插件\n    plugins: [\n      new HtmlWebpackPlugin({\n        // 配置 html 模板文件的目录\n        template: path.resolve(__dirname, 'public/index.html')\n      })\n    ],\n  }\n```\n\n### 使用 webpack-server 实时编译\n\n> 弄好 `html` 自动引入后我们需要打开网页去调试我们的 ts 程序, 按照普通方式来修改一次又要打包一遍, 又要重新刷新一遍网页的话就很麻烦, 这时我们可以用 `webpack-server` 来进行开发服务器部署\n>\n> `**_npm install -D webpack-server_**`\n>\n> 安装完后直接在 `package.json` 中进行配置运行命令运行就行了\n\n\n```json\n  {\n    \"scripts\": {\n      \"dev\": \"webpack server --mode development\"\n    }\n  }\n```\n\n### 配置 babel 来进行浏览器兼容\n\n在日常的开发中我们会经常遇到要兼容低版本浏览器的需要, 这时候为了增加开发效率我们可以用 `**_babel_**` 来将一些 `**_ES6_**` 中的高级属性来转换为低版本浏览器中的兼容属性\n\n需要的开发依赖\n\n>\n> 1. @babel/core ( babel 的核心代码 )\n> 2. @babel/preset-env ( babel 的兼容库 )\n> 3. core-js ( 高级属性的兼容性替代方案 )\n>\n\n> `**_npm install -D @babel/core @babel/preset-env core-js_**`\n\n\nwebpack 配置\n\n```javascript\n\n  module.exports = {\n\n    // 使用的编译模块\n    module: {\n      // 指定要加载的规则\n      rules: [\n        {\n          // test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n          test: /\\.ts$/,\n\n          // 要使用的 loader\n          use: [\n\n            // 配置 babel\n            {\n              // 指定要用的加载器\n              loader: 'babel-loader',\n\n              options: {\n                // 设置预定义的环境\n                presets: [\n                  [\n                    \"@babel-preset-env\",\n\n                    {\n                      // 需要兼容的目标浏览器, 根据项目需求填写\n                      targets: {\n                        \"chrome\": 95\n                      },\n\n                      // 指定的 core 版本\n                      \"corejs\": '3',\n\n                      // 使用 corejs 的方式 \"usage\" 按需加载\n                      \"useBuiltIns\": \"usage\"\n                    }\n                  ]\n                ]\n              }\n            },\n\n            // 由于 webpack 中 rules 是从数组从后往前执行的, 所以 ts-loader 放在后面, 让 ts 先编译为 js 在通过 babel 进行兼容性转换\n            'ts-loader'\n          ],\n        }\n      ]\n    }\n  }\n```\n","slug":"typescript/webpack 搭建 ts 开发环境","published":1,"updated":"2023-01-03T09:02:23.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcq06kzw000bysvn7omiglxy","content":"<h1 id=\"webpack-创建简单的-ts-开发环境\"><a href=\"#webpack-创建简单的-ts-开发环境\" class=\"headerlink\" title=\"webpack 创建简单的 ts 开发环境\"></a>webpack 创建简单的 ts 开发环境</h1><h2 id=\"前置要求\"><a href=\"#前置要求\" class=\"headerlink\" title=\"前置要求\"></a>前置要求</h2><p>需要的的 <code>npm</code> 插件</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>webpack ( webpack 本体 )</li>\n<li>webpack-cli ( webpack 的命令行工具 )</li>\n<li>typescript ( typescript 核心代码 )</li>\n<li>ts-loader (typescript 的 webpck 编译模块)</li>\n<li>clean-webpack-plugin ( 打包前清除之前打包的文件夹 )</li>\n</ol></blockquote>\n<h2 id=\"ts-开发环境目录\"><a href=\"#ts-开发环境目录\" class=\"headerlink\" title=\"ts 开发环境目录\"></a>ts 开发环境目录</h2><p><img src=\"https://s2.loli.net/2023/01/03/XS1lVDEMyifWocg.png\" alt=\"Snipaste_2022-03-05_15-32-16.png\"></p>\n<h2 id=\"tsconfig-json-配置\"><a href=\"#tsconfig-json-配置\" class=\"headerlink\" title=\"tsconfig.json 配置\"></a>tsconfig.json 配置</h2><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;compilerOptions&quot;: &#123;\n\n    &quot;module&quot;: &quot;ES6&quot;,             &#x2F;&#x2F; 使用的模块规则\n\n    &quot;target&quot;: &quot;ES6&quot;,             &#x2F;&#x2F; 编译生成 js 的版本\n\n    &quot;noImplicitAny&quot;: true,       &#x2F;&#x2F; 不允许隐式的 any 类型\n\n    &quot;removeComments&quot;: true,      &#x2F;&#x2F; 删除注释\n\n    &quot;preserveConstEnums&quot;: true,  &#x2F;&#x2F; 保留 const 和 enum 声明\n\n    &quot;strict&quot;: true               &#x2F;&#x2F; 使用严格模式\n  &#125;,\n\n  &#x2F;&#x2F; 需要编译的 ts 文件\n  &quot;include&quot;: [\n    &quot;.&#x2F;src&#x2F;**&#x2F;*&quot;\n  ]\n&#125;</code></pre>\n\n<h2 id=\"webpack-config-js-配置\"><a href=\"#webpack-config-js-配置\" class=\"headerlink\" title=\"webpack.config.js 配置\"></a>webpack.config.js 配置</h2><h3 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const path &#x3D; require(&quot;path&quot;)\nconst &#123; CleanWebpackPlugin &#125; &#x3D; require(&quot;clean-webpack-plugin&quot;)\n\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; 入口文件\n  entry: &quot;.&#x2F;src&#x2F;index.ts&quot;,\n\n  &#x2F;&#x2F; 打包后的出口文件\n  output: &#123;\n    &#x2F;&#x2F; 文件路径\n    path: path.resolve(__dirname, &quot;dist&quot;),\n\n    &#x2F;&#x2F; 文件名\n    filename: &quot;bundle.js&quot;,\n  &#125;,\n  &#x2F;&#x2F; 使用的编译模块\n  module: &#123;\n\n    &#x2F;&#x2F; 指定要加载的规则\n    rules: [\n      &#123;\n        &#x2F;&#x2F; test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n        test: &#x2F;\\.ts$&#x2F;,\n\n        &#x2F;&#x2F; 要使用的 loader\n        use: [&#39;ts-loader&#39;],\n\n        &#x2F;&#x2F; 排除要编译的文件夹\n        exclude: &#x2F;node_modules&#x2F;\n      &#125;\n    ]\n  &#125;,\n\n  &#x2F;&#x2F; 用来设置需要引用的模块文件 (这里包括了 ts 和 js) 不设置的话, 引用其他 ts&#x2F;js 文件会编译报错\n  resolve: &#123;\n    extensions: [&#39;.ts&#39;, &#39;.js&#39;]\n  &#125;,\n\n  &#x2F;&#x2F; 配置 webpack 插件\n  plugins: [\n    new CleanWebpackPlugin()\n  ],\n&#125;</code></pre>\n\n<h3 id=\"使用-html-文件配置\"><a href=\"#使用-html-文件配置\" class=\"headerlink\" title=\"使用 html 文件配置\"></a>使用 html 文件配置</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>前端项目中我们编译完的 js 文件最终会用到 html 文件中. 我们手动创建并引入 js 的话也不是不行, 但是很麻烦, 如果以后要增加一些其他的 js 或者 css 都得重新去手动引入. 这时候就可以用 <code>webpack</code> 给我们提供的一个自动引入经过 loader 编译后的文件 html 的插件 <code>html-webpack-plugin</code></p>\n<p><code>**_npm install -D html-webpack-plugin_**</code></p></blockquote>\n<p>在最外层的 <code>plugins</code> 中配置</p>\n<p><a href=\"https://github.com/jantimon/html-webpack-plugin#configuration\">更多 html-webpack-plugin 的配置信息看这里</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 引入插件\nconst HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;)\n\nmodule.exprots &#x3D; &#123;\n  &#x2F;&#x2F; 配置 webpack 插件\n  plugins: [\n    new HtmlWebpackPlugin(&#123;\n      &#x2F;&#x2F; 配置 html 模板文件的目录\n      template: path.resolve(__dirname, &#39;public&#x2F;index.html&#39;)\n    &#125;)\n  ],\n&#125;</code></pre>\n\n<h3 id=\"使用-webpack-server-实时编译\"><a href=\"#使用-webpack-server-实时编译\" class=\"headerlink\" title=\"使用 webpack-server 实时编译\"></a>使用 webpack-server 实时编译</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>弄好 <code>html</code> 自动引入后我们需要打开网页去调试我们的 ts 程序, 按照普通方式来修改一次又要打包一遍, 又要重新刷新一遍网页的话就很麻烦, 这时我们可以用 <code>webpack-server</code> 来进行开发服务器部署</p>\n<p><code>**_npm install -D webpack-server_**</code></p>\n<p>安装完后直接在 <code>package.json</code> 中进行配置运行命令运行就行了</p></blockquote>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;webpack server --mode development&quot;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"配置-babel-来进行浏览器兼容\"><a href=\"#配置-babel-来进行浏览器兼容\" class=\"headerlink\" title=\"配置 babel 来进行浏览器兼容\"></a>配置 babel 来进行浏览器兼容</h3><p>在日常的开发中我们会经常遇到要兼容低版本浏览器的需要, 这时候为了增加开发效率我们可以用 <code>**_babel_**</code> 来将一些 <code>**_ES6_**</code> 中的高级属性来转换为低版本浏览器中的兼容属性</p>\n<p>需要的开发依赖</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>@babel/core ( babel 的核心代码 )</li>\n<li>@babel/preset-env ( babel 的兼容库 )</li>\n<li>core-js ( 高级属性的兼容性替代方案 )</li>\n</ol></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>**_npm install -D @babel/core @babel/preset-env core-js_**</code></p></blockquote>\n<p>webpack 配置</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\nmodule.exports &#x3D; &#123;\n\n  &#x2F;&#x2F; 使用的编译模块\n  module: &#123;\n    &#x2F;&#x2F; 指定要加载的规则\n    rules: [\n      &#123;\n        &#x2F;&#x2F; test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n        test: &#x2F;\\.ts$&#x2F;,\n\n        &#x2F;&#x2F; 要使用的 loader\n        use: [\n\n          &#x2F;&#x2F; 配置 babel\n          &#123;\n            &#x2F;&#x2F; 指定要用的加载器\n            loader: &#39;babel-loader&#39;,\n\n            options: &#123;\n              &#x2F;&#x2F; 设置预定义的环境\n              presets: [\n                [\n                  &quot;@babel-preset-env&quot;,\n\n                  &#123;\n                    &#x2F;&#x2F; 需要兼容的目标浏览器, 根据项目需求填写\n                    targets: &#123;\n                      &quot;chrome&quot;: 95\n                    &#125;,\n\n                    &#x2F;&#x2F; 指定的 core 版本\n                    &quot;corejs&quot;: &#39;3&#39;,\n\n                    &#x2F;&#x2F; 使用 corejs 的方式 &quot;usage&quot; 按需加载\n                    &quot;useBuiltIns&quot;: &quot;usage&quot;\n                  &#125;\n                ]\n              ]\n            &#125;\n          &#125;,\n\n          &#x2F;&#x2F; 由于 webpack 中 rules 是从数组从后往前执行的, 所以 ts-loader 放在后面, 让 ts 先编译为 js 在通过 babel 进行兼容性转换\n          &#39;ts-loader&#39;\n        ],\n      &#125;\n    ]\n  &#125;\n&#125;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"webpack-创建简单的-ts-开发环境\"><a href=\"#webpack-创建简单的-ts-开发环境\" class=\"headerlink\" title=\"webpack 创建简单的 ts 开发环境\"></a>webpack 创建简单的 ts 开发环境</h1><h2 id=\"前置要求\"><a href=\"#前置要求\" class=\"headerlink\" title=\"前置要求\"></a>前置要求</h2><p>需要的的 <code>npm</code> 插件</p>\n<blockquote>\n<ol>\n<li>webpack ( webpack 本体 )</li>\n<li>webpack-cli ( webpack 的命令行工具 )</li>\n<li>typescript ( typescript 核心代码 )</li>\n<li>ts-loader (typescript 的 webpck 编译模块)</li>\n<li>clean-webpack-plugin ( 打包前清除之前打包的文件夹 )</li>\n</ol>\n</blockquote>\n<h2 id=\"ts-开发环境目录\"><a href=\"#ts-开发环境目录\" class=\"headerlink\" title=\"ts 开发环境目录\"></a>ts 开发环境目录</h2><p><img src=\"https://s2.loli.net/2023/01/03/XS1lVDEMyifWocg.png\" alt=\"Snipaste_2022-03-05_15-32-16.png\"></p>\n<h2 id=\"tsconfig-json-配置\"><a href=\"#tsconfig-json-配置\" class=\"headerlink\" title=\"tsconfig.json 配置\"></a>tsconfig.json 配置</h2><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;compilerOptions&quot;: &#123;\n\n    &quot;module&quot;: &quot;ES6&quot;,             &#x2F;&#x2F; 使用的模块规则\n\n    &quot;target&quot;: &quot;ES6&quot;,             &#x2F;&#x2F; 编译生成 js 的版本\n\n    &quot;noImplicitAny&quot;: true,       &#x2F;&#x2F; 不允许隐式的 any 类型\n\n    &quot;removeComments&quot;: true,      &#x2F;&#x2F; 删除注释\n\n    &quot;preserveConstEnums&quot;: true,  &#x2F;&#x2F; 保留 const 和 enum 声明\n\n    &quot;strict&quot;: true               &#x2F;&#x2F; 使用严格模式\n  &#125;,\n\n  &#x2F;&#x2F; 需要编译的 ts 文件\n  &quot;include&quot;: [\n    &quot;.&#x2F;src&#x2F;**&#x2F;*&quot;\n  ]\n&#125;</code></pre>\n\n<h2 id=\"webpack-config-js-配置\"><a href=\"#webpack-config-js-配置\" class=\"headerlink\" title=\"webpack.config.js 配置\"></a>webpack.config.js 配置</h2><h3 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const path &#x3D; require(&quot;path&quot;)\nconst &#123; CleanWebpackPlugin &#125; &#x3D; require(&quot;clean-webpack-plugin&quot;)\n\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; 入口文件\n  entry: &quot;.&#x2F;src&#x2F;index.ts&quot;,\n\n  &#x2F;&#x2F; 打包后的出口文件\n  output: &#123;\n    &#x2F;&#x2F; 文件路径\n    path: path.resolve(__dirname, &quot;dist&quot;),\n\n    &#x2F;&#x2F; 文件名\n    filename: &quot;bundle.js&quot;,\n  &#125;,\n  &#x2F;&#x2F; 使用的编译模块\n  module: &#123;\n\n    &#x2F;&#x2F; 指定要加载的规则\n    rules: [\n      &#123;\n        &#x2F;&#x2F; test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n        test: &#x2F;\\.ts$&#x2F;,\n\n        &#x2F;&#x2F; 要使用的 loader\n        use: [&#39;ts-loader&#39;],\n\n        &#x2F;&#x2F; 排除要编译的文件夹\n        exclude: &#x2F;node_modules&#x2F;\n      &#125;\n    ]\n  &#125;,\n\n  &#x2F;&#x2F; 用来设置需要引用的模块文件 (这里包括了 ts 和 js) 不设置的话, 引用其他 ts&#x2F;js 文件会编译报错\n  resolve: &#123;\n    extensions: [&#39;.ts&#39;, &#39;.js&#39;]\n  &#125;,\n\n  &#x2F;&#x2F; 配置 webpack 插件\n  plugins: [\n    new CleanWebpackPlugin()\n  ],\n&#125;</code></pre>\n\n<h3 id=\"使用-html-文件配置\"><a href=\"#使用-html-文件配置\" class=\"headerlink\" title=\"使用 html 文件配置\"></a>使用 html 文件配置</h3><blockquote>\n<p>前端项目中我们编译完的 js 文件最终会用到 html 文件中. 我们手动创建并引入 js 的话也不是不行, 但是很麻烦, 如果以后要增加一些其他的 js 或者 css 都得重新去手动引入. 这时候就可以用 <code>webpack</code> 给我们提供的一个自动引入经过 loader 编译后的文件 html 的插件 <code>html-webpack-plugin</code></p>\n<p><code>**_npm install -D html-webpack-plugin_**</code></p>\n</blockquote>\n<p>在最外层的 <code>plugins</code> 中配置</p>\n<p><a href=\"https://github.com/jantimon/html-webpack-plugin#configuration\">更多 html-webpack-plugin 的配置信息看这里</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 引入插件\nconst HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;)\n\nmodule.exprots &#x3D; &#123;\n  &#x2F;&#x2F; 配置 webpack 插件\n  plugins: [\n    new HtmlWebpackPlugin(&#123;\n      &#x2F;&#x2F; 配置 html 模板文件的目录\n      template: path.resolve(__dirname, &#39;public&#x2F;index.html&#39;)\n    &#125;)\n  ],\n&#125;</code></pre>\n\n<h3 id=\"使用-webpack-server-实时编译\"><a href=\"#使用-webpack-server-实时编译\" class=\"headerlink\" title=\"使用 webpack-server 实时编译\"></a>使用 webpack-server 实时编译</h3><blockquote>\n<p>弄好 <code>html</code> 自动引入后我们需要打开网页去调试我们的 ts 程序, 按照普通方式来修改一次又要打包一遍, 又要重新刷新一遍网页的话就很麻烦, 这时我们可以用 <code>webpack-server</code> 来进行开发服务器部署</p>\n<p><code>**_npm install -D webpack-server_**</code></p>\n<p>安装完后直接在 <code>package.json</code> 中进行配置运行命令运行就行了</p>\n</blockquote>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;webpack server --mode development&quot;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"配置-babel-来进行浏览器兼容\"><a href=\"#配置-babel-来进行浏览器兼容\" class=\"headerlink\" title=\"配置 babel 来进行浏览器兼容\"></a>配置 babel 来进行浏览器兼容</h3><p>在日常的开发中我们会经常遇到要兼容低版本浏览器的需要, 这时候为了增加开发效率我们可以用 <code>**_babel_**</code> 来将一些 <code>**_ES6_**</code> 中的高级属性来转换为低版本浏览器中的兼容属性</p>\n<p>需要的开发依赖</p>\n<blockquote>\n<ol>\n<li>@babel/core ( babel 的核心代码 )</li>\n<li>@babel/preset-env ( babel 的兼容库 )</li>\n<li>core-js ( 高级属性的兼容性替代方案 )</li>\n</ol>\n</blockquote>\n<blockquote>\n<p><code>**_npm install -D @babel/core @babel/preset-env core-js_**</code></p>\n</blockquote>\n<p>webpack 配置</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\nmodule.exports &#x3D; &#123;\n\n  &#x2F;&#x2F; 使用的编译模块\n  module: &#123;\n    &#x2F;&#x2F; 指定要加载的规则\n    rules: [\n      &#123;\n        &#x2F;&#x2F; test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n        test: &#x2F;\\.ts$&#x2F;,\n\n        &#x2F;&#x2F; 要使用的 loader\n        use: [\n\n          &#x2F;&#x2F; 配置 babel\n          &#123;\n            &#x2F;&#x2F; 指定要用的加载器\n            loader: &#39;babel-loader&#39;,\n\n            options: &#123;\n              &#x2F;&#x2F; 设置预定义的环境\n              presets: [\n                [\n                  &quot;@babel-preset-env&quot;,\n\n                  &#123;\n                    &#x2F;&#x2F; 需要兼容的目标浏览器, 根据项目需求填写\n                    targets: &#123;\n                      &quot;chrome&quot;: 95\n                    &#125;,\n\n                    &#x2F;&#x2F; 指定的 core 版本\n                    &quot;corejs&quot;: &#39;3&#39;,\n\n                    &#x2F;&#x2F; 使用 corejs 的方式 &quot;usage&quot; 按需加载\n                    &quot;useBuiltIns&quot;: &quot;usage&quot;\n                  &#125;\n                ]\n              ]\n            &#125;\n          &#125;,\n\n          &#x2F;&#x2F; 由于 webpack 中 rules 是从数组从后往前执行的, 所以 ts-loader 放在后面, 让 ts 先编译为 js 在通过 babel 进行兼容性转换\n          &#39;ts-loader&#39;\n        ],\n      &#125;\n    ]\n  &#125;\n&#125;</code></pre>\n"},{"title":"基础 - 内置对象","cover":"https://whitelabelcoders.com/app/uploads/18.jpg","_content":"\n\n\n# 内置对象\n\nJavaScript 中有很多[内置对象](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects)，它们可以直接在 TypeScript 中当做定义好了的类型。\n\n内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。\n\n## ECMAScript 的内置对象\n\nECMAScript 标准提供的内置对象有：\n\n`Boolean`、`Error`、`Date`、`RegExp` 等。\n\n我们可以在 TypeScript 中将变量定义为这些类型：\n\n```ts\nlet b: Boolean = new Boolean(1);\nlet e: Error = new Error('Error occurred');\nlet d: Date = new Date();\nlet r: RegExp = /[a-z]/;\n```\n\n更多的内置对象，可以查看 [MDN 的文档](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects)。\n\n而他们的定义文件，则在 [TypeScript 核心库的定义文件](https://github.com/Microsoft/TypeScript/tree/master/src/lib)中。\n\n## DOM 和 BOM 的内置对象\n\nDOM 和 BOM 提供的内置对象有：\n\n`Document`、`HTMLElement`、`Event`、`NodeList` 等。\n\nTypeScript 中会经常用到这些类型：\n\n```ts\nlet body: HTMLElement = document.body;\nlet allDiv: NodeList = document.querySelectorAll('div');\ndocument.addEventListener('click', function(e: MouseEvent) {\n  // Do something\n});\n```\n\n它们的定义文件同样在 [TypeScript 核心库的定义文件](https://github.com/Microsoft/TypeScript/tree/master/src/lib)中。\n\n## TypeScript 核心库的定义文件\n\n[TypeScript 核心库的定义文件](https://github.com/Microsoft/TypeScript/tree/master/src/lib)中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。\n\n当你在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了，比如：\n\n```ts\nMath.pow(10, '2');\n\n// index.ts(1,14): error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.\n```\n\n上面的例子中，`Math.pow` 必须接受两个 `number` 类型的参数。事实上 `Math.pow` 的类型定义如下：\n\n```ts\ninterface Math {\n    /**\n     * Returns the value of a base expression taken to a specified power.\n     * @param x The base value of the expression.\n     * @param y The exponent value of the expression.\n     */\n    pow(x: number, y: number): number;\n}\n```\n\n再举一个 DOM 中的例子：\n\n```ts\ndocument.addEventListener('click', function(e) {\n    console.log(e.targetCurrent);\n});\n\n// index.ts(2,17): error TS2339: Property 'targetCurrent' does not exist on type 'MouseEvent'.\n```\n\n上面的例子中，`addEventListener` 方法是在 TypeScript 核心库中定义的：\n\n```ts\ninterface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent {\n    addEventListener(type: string, listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\n}\n```\n\n所以 `e` 被推断成了 `MouseEvent`，而 `MouseEvent` 是没有 `targetCurrent` 属性的，所以报错了。\n\n注意，TypeScript 核心库的定义中不包含 Node.js 部分。\n\n## 用 TypeScript 写 Node.js\n\nNode.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：\n\n```bash\nnpm install @types/node --save-dev\n```\n\n## 参考\n\n- [内置对象](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects)\n- [TypeScript 核心库的定义文件](https://github.com/Microsoft/TypeScript/tree/master/src/lib)","source":"_posts/typescript/基础/内置对象.md","raw":"---\ntitle: 基础 - 内置对象\ncover: https://whitelabelcoders.com/app/uploads/18.jpg\ncategories:\n  - TypeScript入门\ntags:\n  - TypeScript\n  - 基础\n---\n\n\n\n# 内置对象\n\nJavaScript 中有很多[内置对象](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects)，它们可以直接在 TypeScript 中当做定义好了的类型。\n\n内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。\n\n## ECMAScript 的内置对象\n\nECMAScript 标准提供的内置对象有：\n\n`Boolean`、`Error`、`Date`、`RegExp` 等。\n\n我们可以在 TypeScript 中将变量定义为这些类型：\n\n```ts\nlet b: Boolean = new Boolean(1);\nlet e: Error = new Error('Error occurred');\nlet d: Date = new Date();\nlet r: RegExp = /[a-z]/;\n```\n\n更多的内置对象，可以查看 [MDN 的文档](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects)。\n\n而他们的定义文件，则在 [TypeScript 核心库的定义文件](https://github.com/Microsoft/TypeScript/tree/master/src/lib)中。\n\n## DOM 和 BOM 的内置对象\n\nDOM 和 BOM 提供的内置对象有：\n\n`Document`、`HTMLElement`、`Event`、`NodeList` 等。\n\nTypeScript 中会经常用到这些类型：\n\n```ts\nlet body: HTMLElement = document.body;\nlet allDiv: NodeList = document.querySelectorAll('div');\ndocument.addEventListener('click', function(e: MouseEvent) {\n  // Do something\n});\n```\n\n它们的定义文件同样在 [TypeScript 核心库的定义文件](https://github.com/Microsoft/TypeScript/tree/master/src/lib)中。\n\n## TypeScript 核心库的定义文件\n\n[TypeScript 核心库的定义文件](https://github.com/Microsoft/TypeScript/tree/master/src/lib)中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。\n\n当你在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了，比如：\n\n```ts\nMath.pow(10, '2');\n\n// index.ts(1,14): error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.\n```\n\n上面的例子中，`Math.pow` 必须接受两个 `number` 类型的参数。事实上 `Math.pow` 的类型定义如下：\n\n```ts\ninterface Math {\n    /**\n     * Returns the value of a base expression taken to a specified power.\n     * @param x The base value of the expression.\n     * @param y The exponent value of the expression.\n     */\n    pow(x: number, y: number): number;\n}\n```\n\n再举一个 DOM 中的例子：\n\n```ts\ndocument.addEventListener('click', function(e) {\n    console.log(e.targetCurrent);\n});\n\n// index.ts(2,17): error TS2339: Property 'targetCurrent' does not exist on type 'MouseEvent'.\n```\n\n上面的例子中，`addEventListener` 方法是在 TypeScript 核心库中定义的：\n\n```ts\ninterface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent {\n    addEventListener(type: string, listener: (ev: MouseEvent) => any, useCapture?: boolean): void;\n}\n```\n\n所以 `e` 被推断成了 `MouseEvent`，而 `MouseEvent` 是没有 `targetCurrent` 属性的，所以报错了。\n\n注意，TypeScript 核心库的定义中不包含 Node.js 部分。\n\n## 用 TypeScript 写 Node.js\n\nNode.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：\n\n```bash\nnpm install @types/node --save-dev\n```\n\n## 参考\n\n- [内置对象](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects)\n- [TypeScript 核心库的定义文件](https://github.com/Microsoft/TypeScript/tree/master/src/lib)","slug":"typescript/基础/内置对象","published":1,"date":"2023-01-10T08:41:16.613Z","updated":"2023-01-10T08:49:57.884Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcq06kzy000fysvn8irn91de","content":"<h1 id=\"内置对象\"><a href=\"#内置对象\" class=\"headerlink\" title=\"内置对象\"></a>内置对象</h1><p>JavaScript 中有很多<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\">内置对象</a>，它们可以直接在 TypeScript 中当做定义好了的类型。</p>\n<p>内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。</p>\n<h2 id=\"ECMAScript-的内置对象\"><a href=\"#ECMAScript-的内置对象\" class=\"headerlink\" title=\"ECMAScript 的内置对象\"></a>ECMAScript 的内置对象</h2><p>ECMAScript 标准提供的内置对象有：</p>\n<p><code>Boolean</code>、<code>Error</code>、<code>Date</code>、<code>RegExp</code> 等。</p>\n<p>我们可以在 TypeScript 中将变量定义为这些类型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let b: Boolean &#x3D; new Boolean(1);\nlet e: Error &#x3D; new Error(&#39;Error occurred&#39;);\nlet d: Date &#x3D; new Date();\nlet r: RegExp &#x3D; &#x2F;[a-z]&#x2F;;</code></pre>\n\n<p>更多的内置对象，可以查看 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\">MDN 的文档</a>。</p>\n<p>而他们的定义文件，则在 <a href=\"https://github.com/Microsoft/TypeScript/tree/master/src/lib\">TypeScript 核心库的定义文件</a>中。</p>\n<h2 id=\"DOM-和-BOM-的内置对象\"><a href=\"#DOM-和-BOM-的内置对象\" class=\"headerlink\" title=\"DOM 和 BOM 的内置对象\"></a>DOM 和 BOM 的内置对象</h2><p>DOM 和 BOM 提供的内置对象有：</p>\n<p><code>Document</code>、<code>HTMLElement</code>、<code>Event</code>、<code>NodeList</code> 等。</p>\n<p>TypeScript 中会经常用到这些类型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let body: HTMLElement &#x3D; document.body;\nlet allDiv: NodeList &#x3D; document.querySelectorAll(&#39;div&#39;);\ndocument.addEventListener(&#39;click&#39;, function(e: MouseEvent) &#123;\n  &#x2F;&#x2F; Do something\n&#125;);</code></pre>\n\n<p>它们的定义文件同样在 <a href=\"https://github.com/Microsoft/TypeScript/tree/master/src/lib\">TypeScript 核心库的定义文件</a>中。</p>\n<h2 id=\"TypeScript-核心库的定义文件\"><a href=\"#TypeScript-核心库的定义文件\" class=\"headerlink\" title=\"TypeScript 核心库的定义文件\"></a>TypeScript 核心库的定义文件</h2><p><a href=\"https://github.com/Microsoft/TypeScript/tree/master/src/lib\">TypeScript 核心库的定义文件</a>中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。</p>\n<p>当你在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了，比如：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">Math.pow(10, &#39;2&#39;);\n\n&#x2F;&#x2F; index.ts(1,14): error TS2345: Argument of type &#39;string&#39; is not assignable to parameter of type &#39;number&#39;.</code></pre>\n\n<p>上面的例子中，<code>Math.pow</code> 必须接受两个 <code>number</code> 类型的参数。事实上 <code>Math.pow</code> 的类型定义如下：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Math &#123;\n    &#x2F;**\n     * Returns the value of a base expression taken to a specified power.\n     * @param x The base value of the expression.\n     * @param y The exponent value of the expression.\n     *&#x2F;\n    pow(x: number, y: number): number;\n&#125;</code></pre>\n\n<p>再举一个 DOM 中的例子：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">document.addEventListener(&#39;click&#39;, function(e) &#123;\n    console.log(e.targetCurrent);\n&#125;);\n\n&#x2F;&#x2F; index.ts(2,17): error TS2339: Property &#39;targetCurrent&#39; does not exist on type &#39;MouseEvent&#39;.</code></pre>\n\n<p>上面的例子中，<code>addEventListener</code> 方法是在 TypeScript 核心库中定义的：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent &#123;\n    addEventListener(type: string, listener: (ev: MouseEvent) &#x3D;&gt; any, useCapture?: boolean): void;\n&#125;</code></pre>\n\n<p>所以 <code>e</code> 被推断成了 <code>MouseEvent</code>，而 <code>MouseEvent</code> 是没有 <code>targetCurrent</code> 属性的，所以报错了。</p>\n<p>注意，TypeScript 核心库的定义中不包含 Node.js 部分。</p>\n<h2 id=\"用-TypeScript-写-Node-js\"><a href=\"#用-TypeScript-写-Node-js\" class=\"headerlink\" title=\"用 TypeScript 写 Node.js\"></a>用 TypeScript 写 Node.js</h2><p>Node.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install @types&#x2F;node --save-dev</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\">内置对象</a></li>\n<li><a href=\"https://github.com/Microsoft/TypeScript/tree/master/src/lib\">TypeScript 核心库的定义文件</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"内置对象\"><a href=\"#内置对象\" class=\"headerlink\" title=\"内置对象\"></a>内置对象</h1><p>JavaScript 中有很多<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\">内置对象</a>，它们可以直接在 TypeScript 中当做定义好了的类型。</p>\n<p>内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。</p>\n<h2 id=\"ECMAScript-的内置对象\"><a href=\"#ECMAScript-的内置对象\" class=\"headerlink\" title=\"ECMAScript 的内置对象\"></a>ECMAScript 的内置对象</h2><p>ECMAScript 标准提供的内置对象有：</p>\n<p><code>Boolean</code>、<code>Error</code>、<code>Date</code>、<code>RegExp</code> 等。</p>\n<p>我们可以在 TypeScript 中将变量定义为这些类型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let b: Boolean &#x3D; new Boolean(1);\nlet e: Error &#x3D; new Error(&#39;Error occurred&#39;);\nlet d: Date &#x3D; new Date();\nlet r: RegExp &#x3D; &#x2F;[a-z]&#x2F;;</code></pre>\n\n<p>更多的内置对象，可以查看 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\">MDN 的文档</a>。</p>\n<p>而他们的定义文件，则在 <a href=\"https://github.com/Microsoft/TypeScript/tree/master/src/lib\">TypeScript 核心库的定义文件</a>中。</p>\n<h2 id=\"DOM-和-BOM-的内置对象\"><a href=\"#DOM-和-BOM-的内置对象\" class=\"headerlink\" title=\"DOM 和 BOM 的内置对象\"></a>DOM 和 BOM 的内置对象</h2><p>DOM 和 BOM 提供的内置对象有：</p>\n<p><code>Document</code>、<code>HTMLElement</code>、<code>Event</code>、<code>NodeList</code> 等。</p>\n<p>TypeScript 中会经常用到这些类型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let body: HTMLElement &#x3D; document.body;\nlet allDiv: NodeList &#x3D; document.querySelectorAll(&#39;div&#39;);\ndocument.addEventListener(&#39;click&#39;, function(e: MouseEvent) &#123;\n  &#x2F;&#x2F; Do something\n&#125;);</code></pre>\n\n<p>它们的定义文件同样在 <a href=\"https://github.com/Microsoft/TypeScript/tree/master/src/lib\">TypeScript 核心库的定义文件</a>中。</p>\n<h2 id=\"TypeScript-核心库的定义文件\"><a href=\"#TypeScript-核心库的定义文件\" class=\"headerlink\" title=\"TypeScript 核心库的定义文件\"></a>TypeScript 核心库的定义文件</h2><p><a href=\"https://github.com/Microsoft/TypeScript/tree/master/src/lib\">TypeScript 核心库的定义文件</a>中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。</p>\n<p>当你在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了，比如：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">Math.pow(10, &#39;2&#39;);\n\n&#x2F;&#x2F; index.ts(1,14): error TS2345: Argument of type &#39;string&#39; is not assignable to parameter of type &#39;number&#39;.</code></pre>\n\n<p>上面的例子中，<code>Math.pow</code> 必须接受两个 <code>number</code> 类型的参数。事实上 <code>Math.pow</code> 的类型定义如下：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Math &#123;\n    &#x2F;**\n     * Returns the value of a base expression taken to a specified power.\n     * @param x The base value of the expression.\n     * @param y The exponent value of the expression.\n     *&#x2F;\n    pow(x: number, y: number): number;\n&#125;</code></pre>\n\n<p>再举一个 DOM 中的例子：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">document.addEventListener(&#39;click&#39;, function(e) &#123;\n    console.log(e.targetCurrent);\n&#125;);\n\n&#x2F;&#x2F; index.ts(2,17): error TS2339: Property &#39;targetCurrent&#39; does not exist on type &#39;MouseEvent&#39;.</code></pre>\n\n<p>上面的例子中，<code>addEventListener</code> 方法是在 TypeScript 核心库中定义的：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent &#123;\n    addEventListener(type: string, listener: (ev: MouseEvent) &#x3D;&gt; any, useCapture?: boolean): void;\n&#125;</code></pre>\n\n<p>所以 <code>e</code> 被推断成了 <code>MouseEvent</code>，而 <code>MouseEvent</code> 是没有 <code>targetCurrent</code> 属性的，所以报错了。</p>\n<p>注意，TypeScript 核心库的定义中不包含 Node.js 部分。</p>\n<h2 id=\"用-TypeScript-写-Node-js\"><a href=\"#用-TypeScript-写-Node-js\" class=\"headerlink\" title=\"用 TypeScript 写 Node.js\"></a>用 TypeScript 写 Node.js</h2><p>Node.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install @types&#x2F;node --save-dev</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\">内置对象</a></li>\n<li><a href=\"https://github.com/Microsoft/TypeScript/tree/master/src/lib\">TypeScript 核心库的定义文件</a></li>\n</ul>\n"},{"title":"基础 - 函数的类型","cover":"https://whitelabelcoders.com/app/uploads/18.jpg","_content":"\n# 函数的类型\n\n## 函数的声明\n\n一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：\n\n```TypeScript\nfunction sum(x: number, y:number): number {\n  return x + y\n}\n```\n\n:::tip\n输入多余的（或者少于要求的）参数，都是不被允许的\n:::\n\n## 函数表达式\n\n我们现在写一个对函数的表达式( Function Expression ), 可能会写成这样\n\n```TypeScript\nlet mySum = function (x: number, y: number): number {\n    return x + y;\n};\n```\n\n这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 `mySum`，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 `mySum` 添加类型，则应该是这样：\n\n```ts\nlet mySum: (x: number, y: number) => number = function (x: number, y: number): number {\n    return x + y;\n};\n```\n\n注意不要混淆了 TypeScript 中的 `=>` 和 ES6 中的 `=>`。\n\n在 TypeScript 的类型定义中，`=>` 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。\n\n在 ES6 中，`=>` 叫做箭头函数，应用十分广泛，可以参考 [ES6 中的箭头函数](http://es6.ruanyifeng.com/#docs/function#箭头函数)。\n\n## 用接口定义函数的形状\n\n我们也可以使用接口的方式来定义一个函数需要符合的形状：\n\n```ts\ninterface SearchFunc {\n    (source: string, subString: string): boolean;\n}\n\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n    return source.search(subString) !== -1;\n}\n```\n\n采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。\n\n\n\n## 可选参数\n\n可选参数必须在必选参数的后面\n\n```ts\nfunction buildName(firstName: string, lastName?: string) {\n    if (lastName) {\n        return firstName + ' ' + lastName;\n    } else {\n        return firstName;\n    }\n}\n```\n\n需要注意的是, **可选参数后面不允许出现比选参数了**\n\n## 参数默认值\n\n在 ES6 中，我们允许给函数的参数添加默认值，**TypeScript 会将添加了默认值的参数识别为可选参数**：\n\n```ts\nfunction buildName(firstName: string, lastName: string = 'Cat') {\n    return firstName + ' ' + lastName;\n}\n```\n\n 给了参数默认值后就不受**可选参数必须在必选参数的后面**的限制了\n\n```ts\nfunction buildName(firstName?: string = 'dog', lastName: string) {\n    return firstName + ' ' + lastName;\n}\n```\n\n## 剩余参数\n\n在ES6中, 我们可以使用`...items`的方式来获取函数中的剩余参数(res参数)\n\n```js\nfunction push(array, ...items) {\n    items.forEach(function(item) {\n        array.push(item);\n    });\n}\n\nlet a: any[] = [];\npush(a, 1, 2, 3);\n```\n\n事实上`items`是一个数组, 我们可以用数组的形式来定义它\n\n```ts\nfunction push(array: any[], ...items: any[]) {\n    items.forEach(function(item) {\n        array.push(item);\n    });\n}\n\nlet a = [];\npush(a, 1, 2, 3);\n```\n\n> 注意，rest 参数只能是最后一个参数，关于 rest 参数，可以参考 [ES6 中的 rest 参数](http://es6.ruanyifeng.com/#docs/function#rest参数)。\n\n## 重载\n\n重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。\n\n比如，我们需要实现一个函数 `reverse`，输入数字 `123` 的时候，输出反转的数字 `321`，输入字符串 `'hello'` 的时候，输出反转的字符串 `'olleh'`。\n\n这时，我们可以使用重载定义多个 `reverse` 的函数类型：\n\n```ts\nfunction reverse(x: number): number;\nfunction reverse(x: string): string;\nfunction reverse(x: number | string): number | string | void {\n    if (typeof x === 'number') {\n        return Number(x.toString().split('').reverse().join(''));\n    } else if (typeof x === 'string') {\n        return x.split('').reverse().join('');\n    }\n}\n```\n\n上例中，我们重复定义了多次函数 `reverse`，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。\n\n注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。\n\n## 参考\n\n- [Functions](http://www.typescriptlang.org/docs/handbook/functions.html)（[中文版](https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Functions.html)）\n- [Functions # Function Types](http://www.typescriptlang.org/docs/handbook/interfaces.html#function-types)（[中文版](https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Interfaces.html#函数类型)）\n- [JS 函数式编程指南](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/)\n- [ES6 中的箭头函数](http://es6.ruanyifeng.com/#docs/function#箭头函数)\n- [ES6 中函数参数的默认值](http://es6.ruanyifeng.com/#docs/function#函数参数的默认值)\n- [ES6 中的 rest 参数](http://es6.ruanyifeng.com/#docs/function#rest参数)","source":"_posts/typescript/基础/函数的类型.md","raw":"---\ntitle: 基础 - 函数的类型\ncover: https://whitelabelcoders.com/app/uploads/18.jpg\ncategories:\n  - TypeScript入门\ntags:\n  - TypeScript\n  - 类型\n  - 函数\n---\n\n# 函数的类型\n\n## 函数的声明\n\n一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：\n\n```TypeScript\nfunction sum(x: number, y:number): number {\n  return x + y\n}\n```\n\n:::tip\n输入多余的（或者少于要求的）参数，都是不被允许的\n:::\n\n## 函数表达式\n\n我们现在写一个对函数的表达式( Function Expression ), 可能会写成这样\n\n```TypeScript\nlet mySum = function (x: number, y: number): number {\n    return x + y;\n};\n```\n\n这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 `mySum`，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 `mySum` 添加类型，则应该是这样：\n\n```ts\nlet mySum: (x: number, y: number) => number = function (x: number, y: number): number {\n    return x + y;\n};\n```\n\n注意不要混淆了 TypeScript 中的 `=>` 和 ES6 中的 `=>`。\n\n在 TypeScript 的类型定义中，`=>` 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。\n\n在 ES6 中，`=>` 叫做箭头函数，应用十分广泛，可以参考 [ES6 中的箭头函数](http://es6.ruanyifeng.com/#docs/function#箭头函数)。\n\n## 用接口定义函数的形状\n\n我们也可以使用接口的方式来定义一个函数需要符合的形状：\n\n```ts\ninterface SearchFunc {\n    (source: string, subString: string): boolean;\n}\n\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n    return source.search(subString) !== -1;\n}\n```\n\n采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。\n\n\n\n## 可选参数\n\n可选参数必须在必选参数的后面\n\n```ts\nfunction buildName(firstName: string, lastName?: string) {\n    if (lastName) {\n        return firstName + ' ' + lastName;\n    } else {\n        return firstName;\n    }\n}\n```\n\n需要注意的是, **可选参数后面不允许出现比选参数了**\n\n## 参数默认值\n\n在 ES6 中，我们允许给函数的参数添加默认值，**TypeScript 会将添加了默认值的参数识别为可选参数**：\n\n```ts\nfunction buildName(firstName: string, lastName: string = 'Cat') {\n    return firstName + ' ' + lastName;\n}\n```\n\n 给了参数默认值后就不受**可选参数必须在必选参数的后面**的限制了\n\n```ts\nfunction buildName(firstName?: string = 'dog', lastName: string) {\n    return firstName + ' ' + lastName;\n}\n```\n\n## 剩余参数\n\n在ES6中, 我们可以使用`...items`的方式来获取函数中的剩余参数(res参数)\n\n```js\nfunction push(array, ...items) {\n    items.forEach(function(item) {\n        array.push(item);\n    });\n}\n\nlet a: any[] = [];\npush(a, 1, 2, 3);\n```\n\n事实上`items`是一个数组, 我们可以用数组的形式来定义它\n\n```ts\nfunction push(array: any[], ...items: any[]) {\n    items.forEach(function(item) {\n        array.push(item);\n    });\n}\n\nlet a = [];\npush(a, 1, 2, 3);\n```\n\n> 注意，rest 参数只能是最后一个参数，关于 rest 参数，可以参考 [ES6 中的 rest 参数](http://es6.ruanyifeng.com/#docs/function#rest参数)。\n\n## 重载\n\n重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。\n\n比如，我们需要实现一个函数 `reverse`，输入数字 `123` 的时候，输出反转的数字 `321`，输入字符串 `'hello'` 的时候，输出反转的字符串 `'olleh'`。\n\n这时，我们可以使用重载定义多个 `reverse` 的函数类型：\n\n```ts\nfunction reverse(x: number): number;\nfunction reverse(x: string): string;\nfunction reverse(x: number | string): number | string | void {\n    if (typeof x === 'number') {\n        return Number(x.toString().split('').reverse().join(''));\n    } else if (typeof x === 'string') {\n        return x.split('').reverse().join('');\n    }\n}\n```\n\n上例中，我们重复定义了多次函数 `reverse`，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。\n\n注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。\n\n## 参考\n\n- [Functions](http://www.typescriptlang.org/docs/handbook/functions.html)（[中文版](https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Functions.html)）\n- [Functions # Function Types](http://www.typescriptlang.org/docs/handbook/interfaces.html#function-types)（[中文版](https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Interfaces.html#函数类型)）\n- [JS 函数式编程指南](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/)\n- [ES6 中的箭头函数](http://es6.ruanyifeng.com/#docs/function#箭头函数)\n- [ES6 中函数参数的默认值](http://es6.ruanyifeng.com/#docs/function#函数参数的默认值)\n- [ES6 中的 rest 参数](http://es6.ruanyifeng.com/#docs/function#rest参数)","slug":"typescript/基础/函数的类型","published":1,"date":"2023-01-06T02:30:32.294Z","updated":"2023-01-10T06:36:31.425Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcq06l00000hysvn81ok7q96","content":"<h1 id=\"函数的类型\"><a href=\"#函数的类型\" class=\"headerlink\" title=\"函数的类型\"></a>函数的类型</h1><h2 id=\"函数的声明\"><a href=\"#函数的声明\" class=\"headerlink\" title=\"函数的声明\"></a>函数的声明</h2><p>一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function sum(x: number, y:number): number &#123;\n  return x + y\n&#125;</code></pre>\n\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>输入多余的（或者少于要求的）参数，都是不被允许的</p>\n</div>\n<h2 id=\"函数表达式\"><a href=\"#函数表达式\" class=\"headerlink\" title=\"函数表达式\"></a>函数表达式</h2><p>我们现在写一个对函数的表达式( Function Expression ), 可能会写成这样</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let mySum &#x3D; function (x: number, y: number): number &#123;\n    return x + y;\n&#125;;</code></pre>\n\n<p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 <code>mySum</code>，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 <code>mySum</code> 添加类型，则应该是这样：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let mySum: (x: number, y: number) &#x3D;&gt; number &#x3D; function (x: number, y: number): number &#123;\n    return x + y;\n&#125;;</code></pre>\n\n<p>注意不要混淆了 TypeScript 中的 <code>=&gt;</code> 和 ES6 中的 <code>=&gt;</code>。</p>\n<p>在 TypeScript 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p>\n<p>在 ES6 中，<code>=&gt;</code> 叫做箭头函数，应用十分广泛，可以参考 <a href=\"http://es6.ruanyifeng.com/#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0\">ES6 中的箭头函数</a>。</p>\n<h2 id=\"用接口定义函数的形状\"><a href=\"#用接口定义函数的形状\" class=\"headerlink\" title=\"用接口定义函数的形状\"></a>用接口定义函数的形状</h2><p>我们也可以使用接口的方式来定义一个函数需要符合的形状：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface SearchFunc &#123;\n    (source: string, subString: string): boolean;\n&#125;\n\nlet mySearch: SearchFunc;\nmySearch &#x3D; function(source: string, subString: string) &#123;\n    return source.search(subString) !&#x3D;&#x3D; -1;\n&#125;</code></pre>\n\n<p>采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p>\n<h2 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h2><p>可选参数必须在必选参数的后面</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function buildName(firstName: string, lastName?: string) &#123;\n    if (lastName) &#123;\n        return firstName + &#39; &#39; + lastName;\n    &#125; else &#123;\n        return firstName;\n    &#125;\n&#125;</code></pre>\n\n<p>需要注意的是, <strong>可选参数后面不允许出现比选参数了</strong></p>\n<h2 id=\"参数默认值\"><a href=\"#参数默认值\" class=\"headerlink\" title=\"参数默认值\"></a>参数默认值</h2><p>在 ES6 中，我们允许给函数的参数添加默认值，<strong>TypeScript 会将添加了默认值的参数识别为可选参数</strong>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function buildName(firstName: string, lastName: string &#x3D; &#39;Cat&#39;) &#123;\n    return firstName + &#39; &#39; + lastName;\n&#125;</code></pre>\n\n<p> 给了参数默认值后就不受<strong>可选参数必须在必选参数的后面</strong>的限制了</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function buildName(firstName?: string &#x3D; &#39;dog&#39;, lastName: string) &#123;\n    return firstName + &#39; &#39; + lastName;\n&#125;</code></pre>\n\n<h2 id=\"剩余参数\"><a href=\"#剩余参数\" class=\"headerlink\" title=\"剩余参数\"></a>剩余参数</h2><p>在ES6中, 我们可以使用<code>...items</code>的方式来获取函数中的剩余参数(res参数)</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function push(array, ...items) &#123;\n    items.forEach(function(item) &#123;\n        array.push(item);\n    &#125;);\n&#125;\n\nlet a: any[] &#x3D; [];\npush(a, 1, 2, 3);</code></pre>\n\n<p>事实上<code>items</code>是一个数组, 我们可以用数组的形式来定义它</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function push(array: any[], ...items: any[]) &#123;\n    items.forEach(function(item) &#123;\n        array.push(item);\n    &#125;);\n&#125;\n\nlet a &#x3D; [];\npush(a, 1, 2, 3);</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意，rest 参数只能是最后一个参数，关于 rest 参数，可以参考 <a href=\"http://es6.ruanyifeng.com/#docs/function#rest%E5%8F%82%E6%95%B0\">ES6 中的 rest 参数</a>。</p></blockquote>\n<h2 id=\"重载\"><a href=\"#重载\" class=\"headerlink\" title=\"重载\"></a>重载</h2><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p>\n<p>比如，我们需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 的时候，输出反转的数字 <code>321</code>，输入字符串 <code>&#39;hello&#39;</code> 的时候，输出反转的字符串 <code>&#39;olleh&#39;</code>。</p>\n<p>这时，我们可以使用重载定义多个 <code>reverse</code> 的函数类型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function reverse(x: number): number;\nfunction reverse(x: string): string;\nfunction reverse(x: number | string): number | string | void &#123;\n    if (typeof x &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;\n        return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));\n    &#125; else if (typeof x &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;\n        return x.split(&#39;&#39;).reverse().join(&#39;&#39;);\n    &#125;\n&#125;</code></pre>\n\n<p>上例中，我们重复定义了多次函数 <code>reverse</code>，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。</p>\n<p>注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/functions.html\">Functions</a>（<a href=\"https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Functions.html\">中文版</a>）</li>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/interfaces.html#function-types\">Functions # Function Types</a>（<a href=\"https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Interfaces.html#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B\">中文版</a>）</li>\n<li><a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/\">JS 函数式编程指南</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0\">ES6 中的箭头函数</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/function#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC\">ES6 中函数参数的默认值</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/function#rest%E5%8F%82%E6%95%B0\">ES6 中的 rest 参数</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"函数的类型\"><a href=\"#函数的类型\" class=\"headerlink\" title=\"函数的类型\"></a>函数的类型</h1><h2 id=\"函数的声明\"><a href=\"#函数的声明\" class=\"headerlink\" title=\"函数的声明\"></a>函数的声明</h2><p>一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function sum(x: number, y:number): number &#123;\n  return x + y\n&#125;</code></pre>\n\n<p>:::tip<br>输入多余的（或者少于要求的）参数，都是不被允许的<br>:::</p>\n<h2 id=\"函数表达式\"><a href=\"#函数表达式\" class=\"headerlink\" title=\"函数表达式\"></a>函数表达式</h2><p>我们现在写一个对函数的表达式( Function Expression ), 可能会写成这样</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let mySum &#x3D; function (x: number, y: number): number &#123;\n    return x + y;\n&#125;;</code></pre>\n\n<p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 <code>mySum</code>，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 <code>mySum</code> 添加类型，则应该是这样：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let mySum: (x: number, y: number) &#x3D;&gt; number &#x3D; function (x: number, y: number): number &#123;\n    return x + y;\n&#125;;</code></pre>\n\n<p>注意不要混淆了 TypeScript 中的 <code>=&gt;</code> 和 ES6 中的 <code>=&gt;</code>。</p>\n<p>在 TypeScript 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p>\n<p>在 ES6 中，<code>=&gt;</code> 叫做箭头函数，应用十分广泛，可以参考 <a href=\"http://es6.ruanyifeng.com/#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0\">ES6 中的箭头函数</a>。</p>\n<h2 id=\"用接口定义函数的形状\"><a href=\"#用接口定义函数的形状\" class=\"headerlink\" title=\"用接口定义函数的形状\"></a>用接口定义函数的形状</h2><p>我们也可以使用接口的方式来定义一个函数需要符合的形状：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface SearchFunc &#123;\n    (source: string, subString: string): boolean;\n&#125;\n\nlet mySearch: SearchFunc;\nmySearch &#x3D; function(source: string, subString: string) &#123;\n    return source.search(subString) !&#x3D;&#x3D; -1;\n&#125;</code></pre>\n\n<p>采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p>\n<h2 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h2><p>可选参数必须在必选参数的后面</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function buildName(firstName: string, lastName?: string) &#123;\n    if (lastName) &#123;\n        return firstName + &#39; &#39; + lastName;\n    &#125; else &#123;\n        return firstName;\n    &#125;\n&#125;</code></pre>\n\n<p>需要注意的是, <strong>可选参数后面不允许出现比选参数了</strong></p>\n<h2 id=\"参数默认值\"><a href=\"#参数默认值\" class=\"headerlink\" title=\"参数默认值\"></a>参数默认值</h2><p>在 ES6 中，我们允许给函数的参数添加默认值，<strong>TypeScript 会将添加了默认值的参数识别为可选参数</strong>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function buildName(firstName: string, lastName: string &#x3D; &#39;Cat&#39;) &#123;\n    return firstName + &#39; &#39; + lastName;\n&#125;</code></pre>\n\n<p> 给了参数默认值后就不受<strong>可选参数必须在必选参数的后面</strong>的限制了</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function buildName(firstName?: string &#x3D; &#39;dog&#39;, lastName: string) &#123;\n    return firstName + &#39; &#39; + lastName;\n&#125;</code></pre>\n\n<h2 id=\"剩余参数\"><a href=\"#剩余参数\" class=\"headerlink\" title=\"剩余参数\"></a>剩余参数</h2><p>在ES6中, 我们可以使用<code>...items</code>的方式来获取函数中的剩余参数(res参数)</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function push(array, ...items) &#123;\n    items.forEach(function(item) &#123;\n        array.push(item);\n    &#125;);\n&#125;\n\nlet a: any[] &#x3D; [];\npush(a, 1, 2, 3);</code></pre>\n\n<p>事实上<code>items</code>是一个数组, 我们可以用数组的形式来定义它</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function push(array: any[], ...items: any[]) &#123;\n    items.forEach(function(item) &#123;\n        array.push(item);\n    &#125;);\n&#125;\n\nlet a &#x3D; [];\npush(a, 1, 2, 3);</code></pre>\n\n<blockquote>\n<p>注意，rest 参数只能是最后一个参数，关于 rest 参数，可以参考 <a href=\"http://es6.ruanyifeng.com/#docs/function#rest%E5%8F%82%E6%95%B0\">ES6 中的 rest 参数</a>。</p>\n</blockquote>\n<h2 id=\"重载\"><a href=\"#重载\" class=\"headerlink\" title=\"重载\"></a>重载</h2><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p>\n<p>比如，我们需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 的时候，输出反转的数字 <code>321</code>，输入字符串 <code>&#39;hello&#39;</code> 的时候，输出反转的字符串 <code>&#39;olleh&#39;</code>。</p>\n<p>这时，我们可以使用重载定义多个 <code>reverse</code> 的函数类型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function reverse(x: number): number;\nfunction reverse(x: string): string;\nfunction reverse(x: number | string): number | string | void &#123;\n    if (typeof x &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;\n        return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));\n    &#125; else if (typeof x &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;\n        return x.split(&#39;&#39;).reverse().join(&#39;&#39;);\n    &#125;\n&#125;</code></pre>\n\n<p>上例中，我们重复定义了多次函数 <code>reverse</code>，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。</p>\n<p>注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/functions.html\">Functions</a>（<a href=\"https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Functions.html\">中文版</a>）</li>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/interfaces.html#function-types\">Functions # Function Types</a>（<a href=\"https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Interfaces.html#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B\">中文版</a>）</li>\n<li><a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/\">JS 函数式编程指南</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0\">ES6 中的箭头函数</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/function#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC\">ES6 中函数参数的默认值</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/function#rest%E5%8F%82%E6%95%B0\">ES6 中的 rest 参数</a></li>\n</ul>\n"},{"title":"基础 - 任意值","cover":"https://whitelabelcoders.com/app/uploads/18.jpg","_content":"\n# 任意值\n\n任意值（Any）用来表示允许赋值为任意类型。\n\n## 什么是任意值类型\n\n如果是一个普通类型，在赋值过程中改变类型是不被允许的：\n\n```TypeScript\nlet myFavoriteNumber: string = 'seven';\nmyFavoriteNumber = 7;\n\n// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.\n```\n\n但如果是 any 类型，则允许被赋值为任意类型\n\n```TypeScript\nlet myFavoriteNumber: any = 'seven';\nmyFavoriteNumber = 7;\n```\n\n## 任意值的属性和方法\n\n在任意值上访问任何属性都是允许的：\n\n```TypeScript\nlet anyThing: any = 'hello';\nconsole.log(anyThing.myName);\nconsole.log(anyThing.myName.firstName);\n```\n\n也可以调用任何方法\n\n```TypeScript\nlet anyThing: any = 'Tom';\nanyThing.setName('Jerry');\nanyThing.setName('Jerry').sayHello();\nanyThing.myName.setFirstName('Cat');\n```\n\n可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值\n\n## 未声明类型的变量\n\n变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：\n\n```TypeScript\nlet something;\nsomething = 'seven';\nsomething = 7;\n\nsomething.setName('Tom');\n```\n\n等价于\n\n```TypeScript\nlet something: any;\nsomething = 'seven';\nsomething = 7;\n\nsomething.setName('Tom');\n```\n\n## 参考\n\n- [Basic Types # Any（中文版）](https://www.typescriptlang.org/zh/docs/handbook/2/everyday-types.html)","source":"_posts/typescript/基础/任意值.md","raw":"---\ntitle: 基础 - 任意值\ncover: https://whitelabelcoders.com/app/uploads/18.jpg\ncategories:\n  - TypeScript入门\ntags:\n  - TypeScript\n  - 基础\n---\n\n# 任意值\n\n任意值（Any）用来表示允许赋值为任意类型。\n\n## 什么是任意值类型\n\n如果是一个普通类型，在赋值过程中改变类型是不被允许的：\n\n```TypeScript\nlet myFavoriteNumber: string = 'seven';\nmyFavoriteNumber = 7;\n\n// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.\n```\n\n但如果是 any 类型，则允许被赋值为任意类型\n\n```TypeScript\nlet myFavoriteNumber: any = 'seven';\nmyFavoriteNumber = 7;\n```\n\n## 任意值的属性和方法\n\n在任意值上访问任何属性都是允许的：\n\n```TypeScript\nlet anyThing: any = 'hello';\nconsole.log(anyThing.myName);\nconsole.log(anyThing.myName.firstName);\n```\n\n也可以调用任何方法\n\n```TypeScript\nlet anyThing: any = 'Tom';\nanyThing.setName('Jerry');\nanyThing.setName('Jerry').sayHello();\nanyThing.myName.setFirstName('Cat');\n```\n\n可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值\n\n## 未声明类型的变量\n\n变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：\n\n```TypeScript\nlet something;\nsomething = 'seven';\nsomething = 7;\n\nsomething.setName('Tom');\n```\n\n等价于\n\n```TypeScript\nlet something: any;\nsomething = 'seven';\nsomething = 7;\n\nsomething.setName('Tom');\n```\n\n## 参考\n\n- [Basic Types # Any（中文版）](https://www.typescriptlang.org/zh/docs/handbook/2/everyday-types.html)","slug":"typescript/基础/任意值","published":1,"date":"2023-01-05T07:02:13.455Z","updated":"2023-01-05T07:53:56.019Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcq06l01000mysvnavml8xpq","content":"<h1 id=\"任意值\"><a href=\"#任意值\" class=\"headerlink\" title=\"任意值\"></a>任意值</h1><p>任意值（Any）用来表示允许赋值为任意类型。</p>\n<h2 id=\"什么是任意值类型\"><a href=\"#什么是任意值类型\" class=\"headerlink\" title=\"什么是任意值类型\"></a>什么是任意值类型</h2><p>如果是一个普通类型，在赋值过程中改变类型是不被允许的：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: string &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre>\n\n<p>但如果是 any 类型，则允许被赋值为任意类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: any &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;</code></pre>\n\n<h2 id=\"任意值的属性和方法\"><a href=\"#任意值的属性和方法\" class=\"headerlink\" title=\"任意值的属性和方法\"></a>任意值的属性和方法</h2><p>在任意值上访问任何属性都是允许的：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let anyThing: any &#x3D; &#39;hello&#39;;\nconsole.log(anyThing.myName);\nconsole.log(anyThing.myName.firstName);</code></pre>\n\n<p>也可以调用任何方法</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let anyThing: any &#x3D; &#39;Tom&#39;;\nanyThing.setName(&#39;Jerry&#39;);\nanyThing.setName(&#39;Jerry&#39;).sayHello();\nanyThing.myName.setFirstName(&#39;Cat&#39;);</code></pre>\n\n<p>可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</p>\n<h2 id=\"未声明类型的变量\"><a href=\"#未声明类型的变量\" class=\"headerlink\" title=\"未声明类型的变量\"></a>未声明类型的变量</h2><p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let something;\nsomething &#x3D; &#39;seven&#39;;\nsomething &#x3D; 7;\n\nsomething.setName(&#39;Tom&#39;);</code></pre>\n\n<p>等价于</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let something: any;\nsomething &#x3D; &#39;seven&#39;;\nsomething &#x3D; 7;\n\nsomething.setName(&#39;Tom&#39;);</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.typescriptlang.org/zh/docs/handbook/2/everyday-types.html\">Basic Types # Any（中文版）</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"任意值\"><a href=\"#任意值\" class=\"headerlink\" title=\"任意值\"></a>任意值</h1><p>任意值（Any）用来表示允许赋值为任意类型。</p>\n<h2 id=\"什么是任意值类型\"><a href=\"#什么是任意值类型\" class=\"headerlink\" title=\"什么是任意值类型\"></a>什么是任意值类型</h2><p>如果是一个普通类型，在赋值过程中改变类型是不被允许的：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: string &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre>\n\n<p>但如果是 any 类型，则允许被赋值为任意类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: any &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;</code></pre>\n\n<h2 id=\"任意值的属性和方法\"><a href=\"#任意值的属性和方法\" class=\"headerlink\" title=\"任意值的属性和方法\"></a>任意值的属性和方法</h2><p>在任意值上访问任何属性都是允许的：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let anyThing: any &#x3D; &#39;hello&#39;;\nconsole.log(anyThing.myName);\nconsole.log(anyThing.myName.firstName);</code></pre>\n\n<p>也可以调用任何方法</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let anyThing: any &#x3D; &#39;Tom&#39;;\nanyThing.setName(&#39;Jerry&#39;);\nanyThing.setName(&#39;Jerry&#39;).sayHello();\nanyThing.myName.setFirstName(&#39;Cat&#39;);</code></pre>\n\n<p>可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</p>\n<h2 id=\"未声明类型的变量\"><a href=\"#未声明类型的变量\" class=\"headerlink\" title=\"未声明类型的变量\"></a>未声明类型的变量</h2><p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let something;\nsomething &#x3D; &#39;seven&#39;;\nsomething &#x3D; 7;\n\nsomething.setName(&#39;Tom&#39;);</code></pre>\n\n<p>等价于</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let something: any;\nsomething &#x3D; &#39;seven&#39;;\nsomething &#x3D; 7;\n\nsomething.setName(&#39;Tom&#39;);</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.typescriptlang.org/zh/docs/handbook/2/everyday-types.html\">Basic Types # Any（中文版）</a></li>\n</ul>\n"},{"title":"基础 - 原始数据类型","cover":"https://whitelabelcoders.com/app/uploads/18.jpg","_content":"\n# 基础 - 原始数据类型\n\nJavaScript的数据类型分为两种: 原始数据类型([Primitive Data types](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive))和对象类型(Object types)\n\n原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。\n\n## 布尔值\n\n布尔值是最基础的数据类型, 在TypeScript中, 使用 `boolean`布尔值类型\n\n```TypeScript\nlet isMan: boolean = true\n\n// 编译通过\n```\n\n:::tip\n注意，使用构造函数 Boolean 创造的对象不是布尔值：\n:::\n\n```TypeScript\nlet createByNewBoolean: boolean = new Boolean(1)\n\n// 此时会编译报错\n// Type 'Boolean' is not assignable to type 'boolean'.\n//   'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible.\n```\n\n事实上 `new Boolean()` 返回的是一个`Boolean`对象:\n\n:::tip\n直接调用`Boolean`也可以返回一个boolean类型\n\n```TypeScript\nlet createdByBoolean: boolean = Boolean(1);\n```\n\n:::\n\n在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。\n\n## 数值\n\n使用 `number`定义数值类型\n\n```TypeScript\nlet decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\n// ES6 中的二进制表示法\nlet binaryLiteral: number = 0b1010;\n// ES6 中的八进制表示法\nlet octalLiteral: number = 0o744;\nlet notANumber: number = NaN;\nlet infinityNumber: number = Infinity;\n```\n\ntsc的编译结果\n\n```TypeScript\nvar decLiteral = 6;\nvar hexLiteral = 0xf00d;\n// ES6 中的二进制表示法\nvar binaryLiteral = 10;\n// ES6 中的八进制表示法\nvar octalLiteral = 484;\nvar notANumber = NaN;\nvar infinityNumber = Infinity;\n```\n\n其中 0b1010 和 0o744 是 [ES6 中的二进制和八进制表示法](https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95)，它们会被编译为十进制数字。\n\n## 字符串\n\n使用 `string`定义字符串类型\n\n```TypeScript\nlet str: string = 'jeck'\n\n// 模板字符串\nlet str_o: string = `my name is ${str}`\n```\n\n编译结果:\n\n```TypeScript\nvar str = jeck\n\n// 模板字符串\nvar str_o = 'my name is' + str\n```\n\n## 空值\n\nJavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：\n\n```TypeScript\nfunction alertName(): void {\n    alert('My name is Tom');\n}\n```\n\n声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null（只在 --strictNullChecks 未指定时）：\n\n```TypeScript\nlet unusable: void = undefined;\n```\n\n## Null 和 Undefined\n\n在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：\n\n```TypeScript\nlet u: undefined = undefined;\nlet n: null = null;\n```\n\n> 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：\n\n```TypeScript\n// 这样不会报错\nlet num: number = undefined;\n```\n\n```TypeScript\n// 这样也不会报错\nlet u: undefined;\nlet num: number = u;\n```\n\n而 void 类型的变量不能赋值给 number 类型的变量：\n\n```TypeScript\nlet u: void;\nlet num: number = u;\n\n// Type 'void' is not assignable to type 'number'.\n```\n\n## 参考\n\n- [Basic Types（中文版）](https://www.typescriptlang.org/zh/docs/handbook/2/everyday-types.html)\n- [Primitive data types](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)\n- [ES6 中的新类型 Symbol](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n- [ES6 中的二进制和八进制表示法](https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95)\n- [ES6 中的模板字符串](http://es6.ruanyifeng.com/#docs/string#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2)","source":"_posts/typescript/基础/原始数据类型.md","raw":"---\ntitle: 基础 - 原始数据类型\ncover: https://whitelabelcoders.com/app/uploads/18.jpg\ncategories:\n  - TypeScript入门\ntags:\n  - TypeScript\n  - 基础\n---\n\n# 基础 - 原始数据类型\n\nJavaScript的数据类型分为两种: 原始数据类型([Primitive Data types](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive))和对象类型(Object types)\n\n原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。\n\n## 布尔值\n\n布尔值是最基础的数据类型, 在TypeScript中, 使用 `boolean`布尔值类型\n\n```TypeScript\nlet isMan: boolean = true\n\n// 编译通过\n```\n\n:::tip\n注意，使用构造函数 Boolean 创造的对象不是布尔值：\n:::\n\n```TypeScript\nlet createByNewBoolean: boolean = new Boolean(1)\n\n// 此时会编译报错\n// Type 'Boolean' is not assignable to type 'boolean'.\n//   'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible.\n```\n\n事实上 `new Boolean()` 返回的是一个`Boolean`对象:\n\n:::tip\n直接调用`Boolean`也可以返回一个boolean类型\n\n```TypeScript\nlet createdByBoolean: boolean = Boolean(1);\n```\n\n:::\n\n在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。\n\n## 数值\n\n使用 `number`定义数值类型\n\n```TypeScript\nlet decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\n// ES6 中的二进制表示法\nlet binaryLiteral: number = 0b1010;\n// ES6 中的八进制表示法\nlet octalLiteral: number = 0o744;\nlet notANumber: number = NaN;\nlet infinityNumber: number = Infinity;\n```\n\ntsc的编译结果\n\n```TypeScript\nvar decLiteral = 6;\nvar hexLiteral = 0xf00d;\n// ES6 中的二进制表示法\nvar binaryLiteral = 10;\n// ES6 中的八进制表示法\nvar octalLiteral = 484;\nvar notANumber = NaN;\nvar infinityNumber = Infinity;\n```\n\n其中 0b1010 和 0o744 是 [ES6 中的二进制和八进制表示法](https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95)，它们会被编译为十进制数字。\n\n## 字符串\n\n使用 `string`定义字符串类型\n\n```TypeScript\nlet str: string = 'jeck'\n\n// 模板字符串\nlet str_o: string = `my name is ${str}`\n```\n\n编译结果:\n\n```TypeScript\nvar str = jeck\n\n// 模板字符串\nvar str_o = 'my name is' + str\n```\n\n## 空值\n\nJavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：\n\n```TypeScript\nfunction alertName(): void {\n    alert('My name is Tom');\n}\n```\n\n声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null（只在 --strictNullChecks 未指定时）：\n\n```TypeScript\nlet unusable: void = undefined;\n```\n\n## Null 和 Undefined\n\n在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：\n\n```TypeScript\nlet u: undefined = undefined;\nlet n: null = null;\n```\n\n> 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：\n\n```TypeScript\n// 这样不会报错\nlet num: number = undefined;\n```\n\n```TypeScript\n// 这样也不会报错\nlet u: undefined;\nlet num: number = u;\n```\n\n而 void 类型的变量不能赋值给 number 类型的变量：\n\n```TypeScript\nlet u: void;\nlet num: number = u;\n\n// Type 'void' is not assignable to type 'number'.\n```\n\n## 参考\n\n- [Basic Types（中文版）](https://www.typescriptlang.org/zh/docs/handbook/2/everyday-types.html)\n- [Primitive data types](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)\n- [ES6 中的新类型 Symbol](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n- [ES6 中的二进制和八进制表示法](https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95)\n- [ES6 中的模板字符串](http://es6.ruanyifeng.com/#docs/string#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2)","slug":"typescript/基础/原始数据类型","published":1,"date":"2023-01-05T02:23:28.205Z","updated":"2023-01-05T07:54:11.780Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcq06l03000nysvn1hzx18y9","content":"<h1 id=\"基础-原始数据类型\"><a href=\"#基础-原始数据类型\" class=\"headerlink\" title=\"基础 - 原始数据类型\"></a>基础 - 原始数据类型</h1><p>JavaScript的数据类型分为两种: 原始数据类型(<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive\">Primitive Data types</a>)和对象类型(Object types)</p>\n<p>原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。</p>\n<h2 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h2><p>布尔值是最基础的数据类型, 在TypeScript中, 使用 <code>boolean</code>布尔值类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let isMan: boolean &#x3D; true\n\n&#x2F;&#x2F; 编译通过</code></pre>\n\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>注意，使用构造函数 Boolean 创造的对象不是布尔值：</p>\n</div>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let createByNewBoolean: boolean &#x3D; new Boolean(1)\n\n&#x2F;&#x2F; 此时会编译报错\n&#x2F;&#x2F; Type &#39;Boolean&#39; is not assignable to type &#39;boolean&#39;.\n&#x2F;&#x2F;   &#39;boolean&#39; is a primitive, but &#39;Boolean&#39; is a wrapper object. Prefer using &#39;boolean&#39; when possible.</code></pre>\n\n<p>事实上 <code>new Boolean()</code> 返回的是一个<code>Boolean</code>对象:</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>直接调用<code>Boolean</code>也可以返回一个boolean类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let createdByBoolean: boolean &#x3D; Boolean(1);</code></pre>\n\n</p>\n</div>\n<p>在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。</p>\n<h2 id=\"数值\"><a href=\"#数值\" class=\"headerlink\" title=\"数值\"></a>数值</h2><p>使用 <code>number</code>定义数值类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let decLiteral: number &#x3D; 6;\nlet hexLiteral: number &#x3D; 0xf00d;\n&#x2F;&#x2F; ES6 中的二进制表示法\nlet binaryLiteral: number &#x3D; 0b1010;\n&#x2F;&#x2F; ES6 中的八进制表示法\nlet octalLiteral: number &#x3D; 0o744;\nlet notANumber: number &#x3D; NaN;\nlet infinityNumber: number &#x3D; Infinity;</code></pre>\n\n<p>tsc的编译结果</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">var decLiteral &#x3D; 6;\nvar hexLiteral &#x3D; 0xf00d;\n&#x2F;&#x2F; ES6 中的二进制表示法\nvar binaryLiteral &#x3D; 10;\n&#x2F;&#x2F; ES6 中的八进制表示法\nvar octalLiteral &#x3D; 484;\nvar notANumber &#x3D; NaN;\nvar infinityNumber &#x3D; Infinity;</code></pre>\n\n<p>其中 0b1010 和 0o744 是 <a href=\"https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95\">ES6 中的二进制和八进制表示法</a>，它们会被编译为十进制数字。</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>使用 <code>string</code>定义字符串类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let str: string &#x3D; &#39;jeck&#39;\n\n&#x2F;&#x2F; 模板字符串\nlet str_o: string &#x3D; &#96;my name is $&#123;str&#125;&#96;</code></pre>\n\n<p>编译结果:</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">var str &#x3D; jeck\n\n&#x2F;&#x2F; 模板字符串\nvar str_o &#x3D; &#39;my name is&#39; + str</code></pre>\n\n<h2 id=\"空值\"><a href=\"#空值\" class=\"headerlink\" title=\"空值\"></a>空值</h2><p>JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function alertName(): void &#123;\n    alert(&#39;My name is Tom&#39;);\n&#125;</code></pre>\n\n<p>声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null（只在 –strictNullChecks 未指定时）：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let unusable: void &#x3D; undefined;</code></pre>\n\n<h2 id=\"Null-和-Undefined\"><a href=\"#Null-和-Undefined\" class=\"headerlink\" title=\"Null 和 Undefined\"></a>Null 和 Undefined</h2><p>在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let u: undefined &#x3D; undefined;\nlet n: null &#x3D; null;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：</p></blockquote>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">&#x2F;&#x2F; 这样不会报错\nlet num: number &#x3D; undefined;</code></pre>\n\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">&#x2F;&#x2F; 这样也不会报错\nlet u: undefined;\nlet num: number &#x3D; u;</code></pre>\n\n<p>而 void 类型的变量不能赋值给 number 类型的变量：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let u: void;\nlet num: number &#x3D; u;\n\n&#x2F;&#x2F; Type &#39;void&#39; is not assignable to type &#39;number&#39;.</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.typescriptlang.org/zh/docs/handbook/2/everyday-types.html\">Basic Types（中文版）</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive\">Primitive data types</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">ES6 中的新类型 Symbol</a></li>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95\">ES6 中的二进制和八进制表示法</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/string#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2\">ES6 中的模板字符串</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基础-原始数据类型\"><a href=\"#基础-原始数据类型\" class=\"headerlink\" title=\"基础 - 原始数据类型\"></a>基础 - 原始数据类型</h1><p>JavaScript的数据类型分为两种: 原始数据类型(<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive\">Primitive Data types</a>)和对象类型(Object types)</p>\n<p>原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。</p>\n<h2 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h2><p>布尔值是最基础的数据类型, 在TypeScript中, 使用 <code>boolean</code>布尔值类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let isMan: boolean &#x3D; true\n\n&#x2F;&#x2F; 编译通过</code></pre>\n\n<p>:::tip<br>注意，使用构造函数 Boolean 创造的对象不是布尔值：<br>:::</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let createByNewBoolean: boolean &#x3D; new Boolean(1)\n\n&#x2F;&#x2F; 此时会编译报错\n&#x2F;&#x2F; Type &#39;Boolean&#39; is not assignable to type &#39;boolean&#39;.\n&#x2F;&#x2F;   &#39;boolean&#39; is a primitive, but &#39;Boolean&#39; is a wrapper object. Prefer using &#39;boolean&#39; when possible.</code></pre>\n\n<p>事实上 <code>new Boolean()</code> 返回的是一个<code>Boolean</code>对象:</p>\n<p>:::tip<br>直接调用<code>Boolean</code>也可以返回一个boolean类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let createdByBoolean: boolean &#x3D; Boolean(1);</code></pre>\n\n<p>:::</p>\n<p>在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。</p>\n<h2 id=\"数值\"><a href=\"#数值\" class=\"headerlink\" title=\"数值\"></a>数值</h2><p>使用 <code>number</code>定义数值类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let decLiteral: number &#x3D; 6;\nlet hexLiteral: number &#x3D; 0xf00d;\n&#x2F;&#x2F; ES6 中的二进制表示法\nlet binaryLiteral: number &#x3D; 0b1010;\n&#x2F;&#x2F; ES6 中的八进制表示法\nlet octalLiteral: number &#x3D; 0o744;\nlet notANumber: number &#x3D; NaN;\nlet infinityNumber: number &#x3D; Infinity;</code></pre>\n\n<p>tsc的编译结果</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">var decLiteral &#x3D; 6;\nvar hexLiteral &#x3D; 0xf00d;\n&#x2F;&#x2F; ES6 中的二进制表示法\nvar binaryLiteral &#x3D; 10;\n&#x2F;&#x2F; ES6 中的八进制表示法\nvar octalLiteral &#x3D; 484;\nvar notANumber &#x3D; NaN;\nvar infinityNumber &#x3D; Infinity;</code></pre>\n\n<p>其中 0b1010 和 0o744 是 <a href=\"https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95\">ES6 中的二进制和八进制表示法</a>，它们会被编译为十进制数字。</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>使用 <code>string</code>定义字符串类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let str: string &#x3D; &#39;jeck&#39;\n\n&#x2F;&#x2F; 模板字符串\nlet str_o: string &#x3D; &#96;my name is $&#123;str&#125;&#96;</code></pre>\n\n<p>编译结果:</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">var str &#x3D; jeck\n\n&#x2F;&#x2F; 模板字符串\nvar str_o &#x3D; &#39;my name is&#39; + str</code></pre>\n\n<h2 id=\"空值\"><a href=\"#空值\" class=\"headerlink\" title=\"空值\"></a>空值</h2><p>JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function alertName(): void &#123;\n    alert(&#39;My name is Tom&#39;);\n&#125;</code></pre>\n\n<p>声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null（只在 –strictNullChecks 未指定时）：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let unusable: void &#x3D; undefined;</code></pre>\n\n<h2 id=\"Null-和-Undefined\"><a href=\"#Null-和-Undefined\" class=\"headerlink\" title=\"Null 和 Undefined\"></a>Null 和 Undefined</h2><p>在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let u: undefined &#x3D; undefined;\nlet n: null &#x3D; null;</code></pre>\n\n<blockquote>\n<p>与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：</p>\n</blockquote>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">&#x2F;&#x2F; 这样不会报错\nlet num: number &#x3D; undefined;</code></pre>\n\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">&#x2F;&#x2F; 这样也不会报错\nlet u: undefined;\nlet num: number &#x3D; u;</code></pre>\n\n<p>而 void 类型的变量不能赋值给 number 类型的变量：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let u: void;\nlet num: number &#x3D; u;\n\n&#x2F;&#x2F; Type &#39;void&#39; is not assignable to type &#39;number&#39;.</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.typescriptlang.org/zh/docs/handbook/2/everyday-types.html\">Basic Types（中文版）</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive\">Primitive data types</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">ES6 中的新类型 Symbol</a></li>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95\">ES6 中的二进制和八进制表示法</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/string#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2\">ES6 中的模板字符串</a></li>\n</ul>\n"},{"title":"基础","cover":"https://whitelabelcoders.com/app/uploads/18.jpg","_content":"\n# 基础\n\n> 本部分介绍了 TypeScript 中的常用类型和一些基本概念，旨在让大家对 TypeScript 有个初步的理解。具体内容包括：\n\n- [原始数据类型](/post/typescript/基础/原始数据类型)\n-\n- [任意值](/post/typescript/基础/任意值)\n-\n- [类型推论](/post/typescript/基础/类型推论)\n-\n- [联合类型](/post/typescript/基础/联合类型)\n-\n- [对象的类型——接口](/post/typescript/基础/对象的类型——接口)\n-\n- [数组的类型](/post/typescript/基础/数组的类型)\n-\n- [函数的类型](/post/typescript/基础/函数的类型)\n-\n- [类型断言](/post/typescript/基础/类型断言)\n-\n- [声明文件](/post/typescript/基础/声明文件)\n-\n- [内置对象](/post/typescript/基础/内置对象)","source":"_posts/typescript/基础/基础.md","raw":"---\ntitle: 基础\ncover: https://whitelabelcoders.com/app/uploads/18.jpg\ncategories:\n  - TypeScript入门\ntags:\n  - TypeScript\n  - 基础\n---\n\n# 基础\n\n> 本部分介绍了 TypeScript 中的常用类型和一些基本概念，旨在让大家对 TypeScript 有个初步的理解。具体内容包括：\n\n- [原始数据类型](/post/typescript/基础/原始数据类型)\n-\n- [任意值](/post/typescript/基础/任意值)\n-\n- [类型推论](/post/typescript/基础/类型推论)\n-\n- [联合类型](/post/typescript/基础/联合类型)\n-\n- [对象的类型——接口](/post/typescript/基础/对象的类型——接口)\n-\n- [数组的类型](/post/typescript/基础/数组的类型)\n-\n- [函数的类型](/post/typescript/基础/函数的类型)\n-\n- [类型断言](/post/typescript/基础/类型断言)\n-\n- [声明文件](/post/typescript/基础/声明文件)\n-\n- [内置对象](/post/typescript/基础/内置对象)","slug":"typescript/基础/基础","published":1,"date":"2023-01-05T02:27:24.372Z","updated":"2023-01-05T07:54:06.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcq06l04000rysvnat714gbw","content":"<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>本部分介绍了 TypeScript 中的常用类型和一些基本概念，旨在让大家对 TypeScript 有个初步的理解。具体内容包括：</p></blockquote>\n<ul>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\">原始数据类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E4%BB%BB%E6%84%8F%E5%80%BC\">任意值</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA\">类型推论</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B\">联合类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3\">对象的类型——接口</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84%E7%9A%84%E7%B1%BB%E5%9E%8B\">数组的类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B\">函数的类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80\">类型断言</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">声明文件</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1\">内置对象</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><blockquote>\n<p>本部分介绍了 TypeScript 中的常用类型和一些基本概念，旨在让大家对 TypeScript 有个初步的理解。具体内容包括：</p>\n</blockquote>\n<ul>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\">原始数据类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E4%BB%BB%E6%84%8F%E5%80%BC\">任意值</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA\">类型推论</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B\">联合类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3\">对象的类型——接口</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84%E7%9A%84%E7%B1%BB%E5%9E%8B\">数组的类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B\">函数的类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80\">类型断言</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">声明文件</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1\">内置对象</a></li>\n</ul>\n"},{"title":"基础 - 声明文件","cover":"https://whitelabelcoders.com/app/uploads/18.jpg","_content":"\n\n\n# 声明文件\n\n当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。\n\n## 新语法索引[§](/post/typescript/声明文件#新语法索引)\n\n由于本章涉及大量新语法，故在本章开头列出新语法的索引，方便大家在使用这些新语法时能快速查找到对应的讲解：\n\n- [`declare var`](/post/typescript/声明文件#declare-var) 声明全局变量\n- [`declare function`](/post/typescript/声明文件#declare-function) 声明全局方法\n- [`declare class`](/post/typescript/声明文件#declare-class) 声明全局类\n- [`declare enum`](/post/typescript/声明文件#declare-enum) 声明全局枚举类型\n- [`declare namespace`](/post/typescript/声明文件#declare-namespace) 声明（含有子属性的）全局对象\n- [`interface` 和 `type`](/post/typescript/声明文件#interface-和-type) 声明全局类型\n- [`export`](/post/typescript/声明文件#export) 导出变量\n- [`export namespace`](/post/typescript/声明文件#export-namespace) 导出（含有子属性的）对象\n- [`export default`](/post/typescript/声明文件#export-default) ES6 默认导出\n- [`export =`](/post/typescript/声明文件#export-1) commonjs 导出模块\n- [`export as namespace`](/post/typescript/声明文件#export-as-namespace) UMD 库声明全局变量\n- [`declare global`](/post/typescript/声明文件#declare-global) 扩展全局变量\n- [`declare module`](/post/typescript/声明文件#declare-module) 扩展模块\n- [`/// `](/post/typescript/声明文件#san-xie-xian-zhi-ling) 三斜线指令\n\n## 什么是声明语句[§](/post/typescript/声明文件#什么是声明语句)\n\n假如我们想使用第三方库 jQuery，一种常见的方式是在 html 中通过 `<script>` 标签引入 jQuery，然后就可以使用全局变量 `$` 或 `jQuery` 了。\n\n我们通常这样获取一个 `id` 是 `foo` 的元素：\n\n```js\n$('#foo');\n// or\njQuery('#foo');\n```\n\n但是在 ts 中，编译器并不知道 `$` 或 `jQuery` 是什么东西[1](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/01-jquery)：\n\n```ts\njQuery('#foo');\n// ERROR: Cannot find name 'jQuery'.\n```\n\n这时，我们需要使用 `declare var` 来定义它的类型[2](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/02-declare-var)：\n\n```ts\ndeclare var jQuery: (selector: string) => any;\n\njQuery('#foo');\n```\n\n上例中，`declare var` 并没有真的定义一个变量，只是定义了全局变量 `jQuery` 的类型，仅仅会用于编译时的检查，在编译结果中会被删除。它编译结果是：\n\n```js\njQuery('#foo');\n```\n\n除了 `declare var` 之外，还有其他很多种声明语句，将会在后面详细介绍。\n\n## 什么是声明文件[§](/post/typescript/声明文件#什么是声明文件)\n\n通常我们会把声明语句放到一个单独的文件（`jQuery.d.ts`）中，这就是声明文件[3](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/03-jquery-d-ts)：\n\n```ts\n// src/jQuery.d.ts\n\ndeclare var jQuery: (selector: string) => any;\n// src/index.ts\n\njQuery('#foo');\n```\n\n声明文件必需以 `.d.ts` 为后缀。\n\n一般来说，ts 会解析项目中所有的 `*.ts` 文件，当然也包含以 `.d.ts` 结尾的文件。所以当我们将 `jQuery.d.ts` 放到项目中时，其他所有 `*.ts` 文件就都可以获得 `jQuery` 的类型定义了。\n\n```autoit\n/path/to/project\n├── src\n|  ├── index.ts\n|  └── jQuery.d.ts\n└── tsconfig.json\n```\n\n假如仍然无法解析，那么可以检查下 `tsconfig.json` 中的 `files`、`include` 和 `exclude` 配置，确保其包含了 `jQuery.d.ts` 文件。\n\n这里只演示了全局变量这种模式的声明文件，假如是通过模块导入的方式使用第三方库的话，那么引入声明文件又是另一种方式了，将会在后面详细介绍。\n\n### 第三方声明文件[§](/post/typescript/声明文件#第三方声明文件)\n\n当然，jQuery 的声明文件不需要我们定义了，社区已经帮我们定义好了：[jQuery in DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/jquery/index.d.ts)。\n\n我们可以直接下载下来使用，但是更推荐的是使用 `@types` 统一管理第三方库的声明文件。\n\n`@types` 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例：\n\n```bash\nnpm install @types/jquery --save-dev\n```\n\n可以在[这个页面](https://microsoft.github.io/TypeSearch/)搜索你需要的声明文件。\n\n## 书写声明文件[§](/post/typescript/声明文件#书写声明文件)\n\n当一个第三方库没有提供声明文件时，我们就需要自己书写声明文件了。前面只介绍了最简单的声明文件内容，而真正书写一个声明文件并不是一件简单的事，以下会详细介绍如何书写声明文件。\n\n在不同的场景下，声明文件的内容和使用方式会有所区别。\n\n库的使用场景主要有以下几种：\n\n- [全局变量](/post/typescript/声明文件#quan-ju-bian-liang)：通过 `<script>` 标签引入第三方库，注入全局变量\n- [npm 包](/post/typescript/声明文件#npm-bao)：通过 `import foo from 'foo'` 导入，符合 ES6 模块规范\n- [UMD 库](/post/typescript/声明文件#umd-ku)：既可以通过 `<script>` 标签引入，又可以通过 `import` 导入\n- [直接扩展全局变量](/post/typescript/声明文件#zhi-jie-kuo-zhan-quan-ju-bian-liang)：通过 `<script>` 标签引入后，改变一个全局变量的结构\n- [在 npm 包或 UMD 库中扩展全局变量](/post/typescript/声明文件#zai-npm-bao-huo-umd-ku-zhong-kuo-zhan-quan-ju-bian-liang)：引用 npm 包或 UMD 库后，改变一个全局变量的结构\n- [模块插件](/post/typescript/声明文件#mo-kuai-cha-jian)：通过 `<script>` 或 `import` 导入后，改变另一个模块的结构\n\n### 全局变量[§](/post/typescript/声明文件#全局变量)\n\n全局变量是最简单的一种场景，之前举的例子就是通过 `<script>` 标签引入 jQuery，注入全局变量 `$` 和 `jQuery`。\n\n使用全局变量的声明文件时，如果是以 `npm install @types/xxx --save-dev` 安装的，则不需要任何配置。如果是将声明文件直接存放于当前项目中，则建议和其他源码一起放到 `src` 目录下（或者对应的源码目录下）：\n\n```autoit\n/path/to/project\n├── src\n|  ├── index.ts\n|  └── jQuery.d.ts\n└── tsconfig.json\n```\n\n如果没有生效，可以检查下 `tsconfig.json` 中的 `files`、`include` 和 `exclude` 配置，确保其包含了 `jQuery.d.ts` 文件。\n\n全局变量的声明文件主要有以下几种语法：\n\n- [`declare var`](/post/typescript/声明文件#declare-var) 声明全局变量\n- [`declare function`](/post/typescript/声明文件#declare-function) 声明全局方法\n- [`declare class`](/post/typescript/声明文件#declare-class) 声明全局类\n- [`declare enum`](/post/typescript/声明文件#declare-enum) 声明全局枚举类型\n- [`declare namespace`](/post/typescript/声明文件#declare-namespace) 声明（含有子属性的）全局对象\n- [`interface` 和 `type`](/post/typescript/声明文件#interface-he-type) 声明全局类型\n\n#### `declare var`[§](/post/typescript/声明文件#declare-var)\n\n在所有的声明语句中，`declare var` 是最简单的，如之前所学，它能够用来定义一个全局变量的类型。与其类似的，还有 `declare let` 和 `declare const`，使用 `let` 与使用 `var` 没有什么区别：\n\n```ts\n// src/jQuery.d.ts\n\ndeclare let jQuery: (selector: string) => any;\n// src/index.ts\n\njQuery('#foo');\n// 使用 declare let 定义的 jQuery 类型，允许修改这个全局变量\njQuery = function(selector) {\n    return document.querySelector(selector);\n};\n```\n\n而当我们使用 `const` 定义时，表示此时的全局变量是一个常量，不允许再去修改它的值了[4](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/04-declare-const-jquery)：\n\n```ts\n// src/jQuery.d.ts\n\ndeclare const jQuery: (selector: string) => any;\n\njQuery('#foo');\n// 使用 declare const 定义的 jQuery 类型，禁止修改这个全局变量\njQuery = function(selector) {\n    return document.querySelector(selector);\n};\n// ERROR: Cannot assign to 'jQuery' because it is a constant or a read-only property.\n```\n\n一般来说，全局变量都是禁止修改的常量，所以大部分情况都应该使用 `const` 而不是 `var` 或 `let`。\n\n需要注意的是，声明语句中只能定义类型，切勿在声明语句中定义具体的实现[5](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/05-declare-jquery-value)：\n\n```ts\ndeclare const jQuery = function(selector) {\n    return document.querySelector(selector);\n};\n// ERROR: An implementation cannot be declared in ambient contexts.\n```\n\n#### `declare function`[§](/post/typescript/声明文件#declare-function)\n\n`declare function` 用来定义全局函数的类型。jQuery 其实就是一个函数，所以也可以用 `function` 来定义：\n\n```ts\n// src/jQuery.d.ts\n\ndeclare function jQuery(selector: string): any;\n// src/index.ts\n\njQuery('#foo');\n```\n\n在函数类型的声明语句中，函数重载也是支持的[6](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/06-declare-function)：\n\n```ts\n// src/jQuery.d.ts\n\ndeclare function jQuery(selector: string): any;\ndeclare function jQuery(domReadyCallback: () => any): any;\n// src/index.ts\n\njQuery('#foo');\njQuery(function() {\n    alert('Dom Ready!');\n});\n```\n\n#### `declare class`[§](/post/typescript/声明文件#declare-class)\n\n当全局变量是一个类的时候，我们用 `declare class` 来定义它的类型[7](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/07-declare-class)：\n\n```ts\n// src/Animal.d.ts\n\ndeclare class Animal {\n    name: string;\n    constructor(name: string);\n    sayHi(): string;\n}\n// src/index.ts\n\nlet cat = new Animal('Tom');\n```\n\n同样的，`declare class` 语句也只能用来定义类型，不能用来定义具体的实现，比如定义 `sayHi` 方法的具体实现则会报错：\n\n```ts\n// src/Animal.d.ts\n\ndeclare class Animal {\n    name: string;\n    constructor(name: string);\n    sayHi() {\n        return `My name is ${this.name}`;\n    };\n    // ERROR: An implementation cannot be declared in ambient contexts.\n}\n```\n\n#### `declare enum`[§](/post/typescript/声明文件#declare-enum)\n\n使用 `declare enum` 定义的枚举类型也称作外部枚举（Ambient Enums），举例如下[8](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/08-declare-enum)：\n\n```ts\n// src/Directions.d.ts\n\ndeclare enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\n// src/index.ts\n\nlet directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n```\n\n与其他全局变量的类型声明一致，`declare enum` 仅用来定义类型，而不是具体的值。\n\n`Directions.d.ts` 仅仅会用于编译时的检查，声明文件里的内容在编译结果中会被删除。它编译结果是：\n\n```js\nvar directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n```\n\n其中 `Directions` 是由第三方库定义好的全局变量。\n\n#### `declare namespace`[§](/post/typescript/声明文件#declare-namespace)\n\n`namespace` 是 ts 早期时为了解决模块化而创造的关键字，中文称为命名空间。\n\n由于历史遗留原因，在早期还没有 ES6 的时候，ts 提供了一种模块化方案，使用 `module` 关键字表示内部模块。但由于后来 ES6 也使用了 `module` 关键字，ts 为了兼容 ES6，使用 `namespace` 替代了自己的 `module`，更名为命名空间。\n\n随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的 `namespace`，而推荐使用 ES6 的模块化方案了，故我们不再需要学习 `namespace` 的使用了。\n\n`namespace` 被淘汰了，但是在声明文件中，`declare namespace` 还是比较常用的，它用来表示全局变量是一个对象，包含很多子属性。\n\n比如 `jQuery` 是一个全局变量，它是一个对象，提供了一个 `jQuery.ajax` 方法可以调用，那么我们就应该使用 `declare namespace jQuery` 来声明这个拥有多个子属性的全局变量。\n\n```ts\n// src/jQuery.d.ts\n\ndeclare namespace jQuery {\n    function ajax(url: string, settings?: any): void;\n}\n// src/index.ts\n\njQuery.ajax('/api/get_something');\n```\n\n注意，在 `declare namespace` 内部，我们直接使用 `function ajax` 来声明函数，而不是使用 `declare function ajax`。类似的，也可以使用 `const`, `class`, `enum` 等语句[9](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/09-declare-namespace)：\n\n```ts\n// src/jQuery.d.ts\n\ndeclare namespace jQuery {\n    function ajax(url: string, settings?: any): void;\n    const version: number;\n    class Event {\n        blur(eventType: EventType): void\n    }\n    enum EventType {\n        CustomClick\n    }\n}\n// src/index.ts\n\njQuery.ajax('/api/get_something');\nconsole.log(jQuery.version);\nconst e = new jQuery.Event();\ne.blur(jQuery.EventType.CustomClick);\n```\n\n##### 嵌套的命名空间[§](/post/typescript/声明文件#嵌套的命名空间)\n\n如果对象拥有深层的层级，则需要用嵌套的 `namespace` 来声明深层的属性的类型[10](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/10-declare-namespace-nesting)：\n\n```ts\n// src/jQuery.d.ts\n\ndeclare namespace jQuery {\n    function ajax(url: string, settings?: any): void;\n    namespace fn {\n        function extend(object: any): void;\n    }\n}\n// src/index.ts\n\njQuery.ajax('/api/get_something');\njQuery.fn.extend({\n    check: function() {\n        return this.each(function() {\n            this.checked = true;\n        });\n    }\n});\n```\n\n假如 `jQuery` 下仅有 `fn` 这一个属性（没有 `ajax` 等其他属性或方法），则可以不需要嵌套 `namespace`[11](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/11-declare-namespace-dot)：\n\n```ts\n// src/jQuery.d.ts\n\ndeclare namespace jQuery.fn {\n    function extend(object: any): void;\n}\n// src/index.ts\n\njQuery.fn.extend({\n    check: function() {\n        return this.each(function() {\n            this.checked = true;\n        });\n    }\n});\n```\n\n#### `interface` 和 `type`[§](/post/typescript/声明文件#interface-和-type)\n\n除了全局变量之外，可能有一些类型我们也希望能暴露出来。在类型声明文件中，我们可以直接使用 `interface` 或 `type` 来声明一个全局的接口或类型[12](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/12-interface)：\n\n```ts\n// src/jQuery.d.ts\n\ninterface AjaxSettings {\n    method?: 'GET' | 'POST'\n    data?: any;\n}\ndeclare namespace jQuery {\n    function ajax(url: string, settings?: AjaxSettings): void;\n}\n```\n\n这样的话，在其他文件中也可以使用这个接口或类型了：\n\n```ts\n// src/index.ts\n\nlet settings: AjaxSettings = {\n    method: 'POST',\n    data: {\n        name: 'foo'\n    }\n};\njQuery.ajax('/api/post_something', settings);\n```\n\n`type` 与 `interface` 类似，不再赘述。\n\n##### 防止命名冲突[§](/post/typescript/声明文件#防止命名冲突)\n\n暴露在最外层的 `interface` 或 `type` 会作为全局类型作用于整个项目中，我们应该尽可能的减少全局变量或全局类型的数量。故最好将他们放到 `namespace` 下[13](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/13-avoid-name-conflict)：\n\n```ts\n// src/jQuery.d.ts\n\ndeclare namespace jQuery {\n    interface AjaxSettings {\n        method?: 'GET' | 'POST'\n        data?: any;\n    }\n    function ajax(url: string, settings?: AjaxSettings): void;\n}\n```\n\n注意，在使用这个 `interface` 的时候，也应该加上 `jQuery` 前缀：\n\n```ts\n// src/index.ts\n\nlet settings: jQuery.AjaxSettings = {\n    method: 'POST',\n    data: {\n        name: 'foo'\n    }\n};\njQuery.ajax('/api/post_something', settings);\n```\n\n#### 声明合并[§](/post/typescript/声明文件#声明合并)\n\n假如 jQuery 既是一个函数，可以直接被调用 `jQuery('#foo')`，又是一个对象，拥有子属性 `jQuery.ajax()`（事实确实如此），那么我们可以组合多个声明语句，它们会不冲突的合并起来[14](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/14-declaration-merging)：\n\n```ts\n// src/jQuery.d.ts\n\ndeclare function jQuery(selector: string): any;\ndeclare namespace jQuery {\n    function ajax(url: string, settings?: any): void;\n}\n// src/index.ts\n\njQuery('#foo');\njQuery.ajax('/api/get_something');\n```\n\n关于声明合并的更多用法，可以查看[声明合并](https://ts.xcatliu.com/advanced/declaration-merging.html)章节。\n\n### npm 包[§](/post/typescript/声明文件#npm-包)\n\n一般我们通过 `import foo from 'foo'` 导入一个 npm 包，这是符合 ES6 模块规范的。\n\n在我们尝试给一个 npm 包创建声明文件之前，需要先看看它的声明文件是否已经存在。一般来说，npm 包的声明文件可能存在于两个地方：\n\n1. 与该 npm 包绑定在一起。判断依据是 `package.json` 中有 `types` 字段，或者有一个 `index.d.ts` 声明文件。这种模式不需要额外安装其他包，是最为推荐的，所以以后我们自己创建 npm 包的时候，最好也将声明文件与 npm 包绑定在一起。\n2. 发布到 `@types` 里。我们只需要尝试安装一下对应的 `@types` 包就知道是否存在该声明文件，安装命令是 `npm install @types/foo --save-dev`。这种模式一般是由于 npm 包的维护者没有提供声明文件，所以只能由其他人将声明文件发布到 `@types` 里了。\n\n假如以上两种方式都没有找到对应的声明文件，那么我们就需要自己为它写声明文件了。由于是通过 `import` 语句导入的模块，所以声明文件存放的位置也有所约束，一般有两种方案：\n\n1. 创建一个 `node_modules/@types/foo/index.d.ts` 文件，存放 `foo` 模块的声明文件。这种方式不需要额外的配置，但是 `node_modules` 目录不稳定，代码也没有被保存到仓库中，无法回溯版本，有不小心被删除的风险，故不太建议用这种方案，一般只用作临时测试。\n2. 创建一个 `types` 目录，专门用来管理自己写的声明文件，将 `foo` 的声明文件放到 `types/foo/index.d.ts` 中。这种方式需要配置下 `tsconfig.json` 中的 `paths` 和 `baseUrl` 字段。\n\n目录结构：\n\n```autoit\n/path/to/project\n├── src\n|  └── index.ts\n├── types\n|  └── foo\n|     └── index.d.ts\n└── tsconfig.json\n```\n\n`tsconfig.json` 内容：\n\n```json\n{\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"baseUrl\": \"./\",\n        \"paths\": {\n            \"*\": [\"types/*\"]\n        }\n    }\n}\n```\n\n如此配置之后，通过 `import` 导入 `foo` 的时候，也会去 `types` 目录下寻找对应的模块的声明文件了。\n\n注意 `module` 配置可以有很多种选项，不同的选项会影响模块的导入导出模式。这里我们使用了 `commonjs` 这个最常用的选项，后面的教程也都默认使用的这个选项。\n\n不管采用了以上两种方式中的哪一种，我都**强烈建议**大家将书写好的声明文件（通过给第三方库发 pull request，或者直接提交到 `@types` 里）发布到开源社区中，享受了这么多社区的优秀的资源，就应该在力所能及的时候给出一些回馈。只有所有人都参与进来，才能让 ts 社区更加繁荣。\n\nnpm 包的声明文件主要有以下几种语法：\n\n- [`export`](/post/typescript/声明文件#export) 导出变量\n- [`export namespace`](/post/typescript/声明文件#export-namespace) 导出（含有子属性的）对象\n- [`export default`](/post/typescript/声明文件#export-default) ES6 默认导出\n- [`export =`](/post/typescript/声明文件#export-1) commonjs 导出模块\n\n#### `export`[§](/post/typescript/声明文件#export)\n\nnpm 包的声明文件与全局变量的声明文件有很大区别。在 npm 包的声明文件中，使用 `declare` 不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。只有在声明文件中使用 `export` 导出，然后在使用方 `import` 导入后，才会应用到这些类型声明。\n\n`export` 的语法与普通的 ts 中的语法类似，区别仅在于声明文件中禁止定义具体的实现[15](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/15-export)：\n\n```ts\n// types/foo/index.d.ts\n\nexport const name: string;\nexport function getName(): string;\nexport class Animal {\n    constructor(name: string);\n    sayHi(): string;\n}\nexport enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\nexport interface Options {\n    data: any;\n}\n```\n\n对应的导入和使用模块应该是这样：\n\n```ts\n// src/index.ts\n\nimport { name, getName, Animal, Directions, Options } from 'foo';\n\nconsole.log(name);\nlet myName = getName();\nlet cat = new Animal('Tom');\nlet directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\nlet options: Options = {\n    data: {\n        name: 'foo'\n    }\n};\n```\n\n##### 混用 `declare` 和 `export`[§](/post/typescript/声明文件#混用-declare-和-export)\n\n我们也可以使用 `declare` 先声明多个变量，最后再用 `export` 一次性导出。上例的声明文件可以等价的改写为[16](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/16-declare-and-export)：\n\n```ts\n// types/foo/index.d.ts\n\ndeclare const name: string;\ndeclare function getName(): string;\ndeclare class Animal {\n    constructor(name: string);\n    sayHi(): string;\n}\ndeclare enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\ninterface Options {\n    data: any;\n}\n\nexport { name, getName, Animal, Directions, Options };\n```\n\n注意，与全局变量的声明文件类似，`interface` 前是不需要 `declare` 的。\n\n#### `export namespace`[§](/post/typescript/声明文件#export-namespace)\n\n与 `declare namespace` 类似，`export namespace` 用来导出一个拥有子属性的对象[17](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/17-export-namespace)：\n\n```ts\n// types/foo/index.d.ts\n\nexport namespace foo {\n    const name: string;\n    namespace bar {\n        function baz(): string;\n    }\n}\n// src/index.ts\n\nimport { foo } from 'foo';\n\nconsole.log(foo.name);\nfoo.bar.baz();\n```\n\n#### `export default`[§](/post/typescript/声明文件#export-default)\n\n在 ES6 模块系统中，使用 `export default` 可以导出一个默认值，使用方可以用 `import foo from 'foo'` 而不是 `import { foo } from 'foo'` 来导入这个默认值。\n\n在类型声明文件中，`export default` 用来导出默认值的类型[18](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/18-export-default)：\n\n```ts\n// types/foo/index.d.ts\n\nexport default function foo(): string;\n// src/index.ts\n\nimport foo from 'foo';\n\nfoo();\n```\n\n注意，只有 `function`、`class` 和 `interface` 可以直接默认导出，其他的变量需要先定义出来，再默认导出[19](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/19-export-default-enum-error)：\n\n```ts\n// types/foo/index.d.ts\n\nexport default enum Directions {\n// ERROR: Expression expected.\n    Up,\n    Down,\n    Left,\n    Right\n}\n```\n\n上例中 `export default enum` 是错误的语法，需要使用 `declare enum` 定义出来，然后使用 `export default` 导出：\n\n```ts\n// types/foo/index.d.ts\n\ndeclare enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\n\nexport default Directions;\n```\n\n针对这种默认导出，我们一般会将导出语句放在整个声明文件的最前面[20](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/20-export-default-enum)：\n\n```ts\n// types/foo/index.d.ts\n\nexport default Directions;\n\ndeclare enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\n```\n\n#### `export =`[§](/post/typescript/声明文件#export-)\n\n在 commonjs 规范中，我们用以下方式来导出一个模块：\n\n```js\n// 整体导出\nmodule.exports = foo;\n// 单个导出\nexports.bar = bar;\n```\n\n在 ts 中，针对这种模块导出，有多种方式可以导入，第一种方式是 `const ... = require`：\n\n```js\n// 整体导入\nconst foo = require('foo');\n// 单个导入\nconst bar = require('foo').bar;\n```\n\n第二种方式是 `import ... from`，注意针对整体导出，需要使用 `import * as` 来导入：\n\n```ts\n// 整体导入\nimport * as foo from 'foo';\n// 单个导入\nimport { bar } from 'foo';\n```\n\n第三种方式是 `import ... require`，这也是 ts 官方推荐的方式：\n\n```ts\n// 整体导入\nimport foo = require('foo');\n// 单个导入\nimport bar = foo.bar;\n```\n\n对于这种使用 commonjs 规范的库，假如要为它写类型声明文件的话，就需要使用到 `export =` 这种语法了[21](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/21-export-equal)：\n\n```ts\n// types/foo/index.d.ts\n\nexport = foo;\n\ndeclare function foo(): string;\ndeclare namespace foo {\n    const bar: number;\n}\n```\n\n需要注意的是，上例中使用了 `export =` 之后，就不能再单个导出 `export { bar }` 了。所以我们通过声明合并，使用 `declare namespace foo` 来将 `bar` 合并到 `foo` 里。\n\n准确地讲，`export =` 不仅可以用在声明文件中，也可以用在普通的 ts 文件中。实际上，`import ... require` 和 `export =` 都是 ts 为了兼容 AMD 规范和 commonjs 规范而创立的新语法，由于并不常用也不推荐使用，所以这里就不详细介绍了，感兴趣的可以看[官方文档](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require)。\n\n由于很多第三方库是 commonjs 规范的，所以声明文件也就不得不用到 `export =` 这种语法了。但是还是需要再强调下，相比与 `export =`，我们更推荐使用 ES6 标准的 `export default` 和 `export`。\n\n### UMD 库[§](/post/typescript/声明文件#umd-库)\n\n既可以通过 `<script>` 标签引入，又可以通过 `import` 导入的库，称为 UMD 库。相比于 npm 包的类型声明文件，我们需要额外声明一个全局变量，为了实现这种方式，ts 提供了一个新语法 `export as namespace`。\n\n#### `export as namespace`[§](/post/typescript/声明文件#export-as-namespace)\n\n一般使用 `export as namespace` 时，都是先有了 npm 包的声明文件，再基于它添加一条 `export as namespace` 语句，即可将声明好的一个变量声明为全局变量，举例如下[22](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/22-export-as-namespace)：\n\n```ts\n// types/foo/index.d.ts\n\nexport as namespace foo;\nexport = foo;\n\ndeclare function foo(): string;\ndeclare namespace foo {\n    const bar: number;\n}\n```\n\n当然它也可以与 `export default` 一起使用：\n\n```ts\n// types/foo/index.d.ts\n\nexport as namespace foo;\nexport default foo;\n\ndeclare function foo(): string;\ndeclare namespace foo {\n    const bar: number;\n}\n```\n\n### 直接扩展全局变量[§](/post/typescript/声明文件#直接扩展全局变量)\n\n有的第三方库扩展了一个全局变量，可是此全局变量的类型却没有相应的更新过来，就会导致 ts 编译错误，此时就需要扩展全局变量的类型。比如扩展 `String` 类型[23](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/23-merge-global-interface)：\n\n```ts\ninterface String {\n    prependHello(): string;\n}\n\n'foo'.prependHello();\n```\n\n通过声明合并，使用 `interface String` 即可给 `String` 添加属性或方法。\n\n也可以使用 `declare namespace` 给已有的命名空间添加类型声明[24](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/24-merge-global-namespace)：\n\n```ts\n// types/jquery-plugin/index.d.ts\n\ndeclare namespace JQuery {\n    interface CustomOptions {\n        bar: string;\n    }\n}\n\ninterface JQueryStatic {\n    foo(options: JQuery.CustomOptions): string;\n}\n// src/index.ts\n\njQuery.foo({\n    bar: ''\n});\n```\n\n### 在 npm 包或 UMD 库中扩展全局变量[§](/post/typescript/声明文件#在-npm-包或-umd-库中扩展全局变量)\n\n如之前所说，对于一个 npm 包或者 UMD 库的声明文件，只有 `export` 导出的类型声明才能被导入。所以对于 npm 包或 UMD 库，如果导入此库之后会扩展全局变量，则需要使用另一种语法在声明文件中扩展全局变量的类型，那就是 `declare global`。\n\n#### `declare global`[§](/post/typescript/声明文件#declare-global)\n\n使用 `declare global` 可以在 npm 包或者 UMD 库的声明文件中扩展全局变量的类型[25](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/25-declare-global)：\n\n```ts\n// types/foo/index.d.ts\n\ndeclare global {\n    interface String {\n        prependHello(): string;\n    }\n}\n\nexport {};\n// src/index.ts\n\n'bar'.prependHello();\n```\n\n注意即使此声明文件不需要导出任何东西，仍然需要导出一个空对象，用来告诉编译器这是一个模块的声明文件，而不是一个全局变量的声明文件。\n\n### 模块插件[§](/post/typescript/声明文件#模块插件)\n\n有时通过 `import` 导入一个模块插件，可以改变另一个原有模块的结构。此时如果原有模块已经有了类型声明文件，而插件模块没有类型声明文件，就会导致类型不完整，缺少插件部分的类型。ts 提供了一个语法 `declare module`，它可以用来扩展原有模块的类型。\n\n#### `declare module`[§](/post/typescript/声明文件#declare-module)\n\n如果是需要扩展原有模块的话，需要在类型声明文件中先引用原有模块，再使用 `declare module` 扩展原有模块[26](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/26-declare-module)：\n\n```ts\n// types/moment-plugin/index.d.ts\n\nimport * as moment from 'moment';\n\ndeclare module 'moment' {\n    export function foo(): moment.CalendarKey;\n}\n// src/index.ts\n\nimport * as moment from 'moment';\nimport 'moment-plugin';\n\nmoment.foo();\n```\n\n`declare module` 也可用于在一个文件中一次性声明多个模块的类型[27](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/27-multiple-declare-module)：\n\n```ts\n// types/foo-bar.d.ts\n\ndeclare module 'foo' {\n    export interface Foo {\n        foo: string;\n    }\n}\n\ndeclare module 'bar' {\n    export function bar(): string;\n}\n// src/index.ts\n\nimport { Foo } from 'foo';\nimport * as bar from 'bar';\n\nlet f: Foo;\nbar.bar();\n```\n\n### 声明文件中的依赖[§](/post/typescript/声明文件#声明文件中的依赖)\n\n一个声明文件有时会依赖另一个声明文件中的类型，比如在前面的 `declare module` 的例子中，我们就在声明文件中导入了 `moment`，并且使用了 `moment.CalendarKey` 这个类型：\n\n```ts\n// types/moment-plugin/index.d.ts\n\nimport * as moment from 'moment';\n\ndeclare module 'moment' {\n    export function foo(): moment.CalendarKey;\n}\n```\n\n除了可以在声明文件中通过 `import` 导入另一个声明文件中的类型之外，还有一个语法也可以用来导入另一个声明文件，那就是三斜线指令。\n\n#### 三斜线指令[§](/post/typescript/声明文件#三斜线指令)\n\n与 `namespace` 类似，三斜线指令也是 ts 在早期版本中为了描述模块之间的依赖关系而创造的语法。随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的三斜线指令来声明模块之间的依赖关系了。\n\n但是在声明文件中，它还是有一定的用武之地。\n\n类似于声明文件中的 `import`，它可以用来导入另一个声明文件。与 `import` 的区别是，当且仅当在以下几个场景下，我们才需要使用三斜线指令替代 `import`：\n\n- 当我们在**书写**一个全局变量的声明文件时\n- 当我们需要**依赖**一个全局变量的声明文件时\n\n##### **书写**一个全局变量的声明文件[§](/post/typescript/声明文件#书写一个全局变量的声明文件)\n\n这些场景听上去很拗口，但实际上很好理解——在全局变量的声明文件中，是不允许出现 `import`, `export` 关键字的。一旦出现了，那么他就会被视为一个 npm 包或 UMD 库，就不再是全局变量的声明文件了。故当我们在书写一个全局变量的声明文件时，如果需要引用另一个库的类型，那么就必须用三斜线指令了[28](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/28-triple-slash-directives)：\n\n```ts\n// types/jquery-plugin/index.d.ts\n\n/// <reference types=\"jquery\" />\n\ndeclare function foo(options: JQuery.AjaxSettings): string;\n// src/index.ts\n\nfoo({});\n```\n\n三斜线指令的语法如上，`///` 后面使用 xml 的格式添加了对 `jquery` 类型的依赖，这样就可以在声明文件中使用 `JQuery.AjaxSettings` 类型了。\n\n注意，三斜线指令必须放在文件的最顶端，三斜线指令的前面只允许出现单行或多行注释。\n\n##### **依赖**一个全局变量的声明文件[§](/post/typescript/声明文件#依赖一个全局变量的声明文件)\n\n在另一个场景下，当我们需要依赖一个全局变量的声明文件时，由于全局变量不支持通过 `import` 导入，当然也就必须使用三斜线指令来引入了[29](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/29-triple-slash-directives-global)：\n\n```ts\n// types/node-plugin/index.d.ts\n\n/// <reference types=\"node\" />\n\nexport function foo(p: NodeJS.Process): string;\n// src/index.ts\n\nimport { foo } from 'node-plugin';\n\nfoo(global.process);\n```\n\n在上面的例子中，我们通过三斜线指引入了 `node` 的类型，然后在声明文件中使用了 `NodeJS.Process` 这个类型。最后在使用到 `foo` 的时候，传入了 `node` 中的全局变量 `process`。\n\n由于引入的 `node` 中的类型都是全局变量的类型，它们是没有办法通过 `import` 来导入的，所以这种场景下也只能通过三斜线指令来引入了。\n\n以上两种使用场景下，都是由于需要书写或需要依赖全局变量的声明文件，所以必须使用三斜线指令。在其他的一些不是必要使用三斜线指令的情况下，就都需要使用 `import` 来导入。\n\n##### 拆分声明文件[§](/post/typescript/声明文件#拆分声明文件)\n\n当我们的全局变量的声明文件太大时，可以通过拆分为多个文件，然后在一个入口文件中将它们一一引入，来提高代码的可维护性。比如 `jQuery` 的声明文件就是这样的：\n\n```ts\n// node_modules/@types/jquery/index.d.ts\n\n/// <reference types=\"sizzle\" />\n/// <reference path=\"JQueryStatic.d.ts\" />\n/// <reference path=\"JQuery.d.ts\" />\n/// <reference path=\"misc.d.ts\" />\n/// <reference path=\"legacy.d.ts\" />\n\nexport = jQuery;\n```\n\n其中用到了 `types` 和 `path` 两种不同的指令。它们的区别是：`types` 用于声明对另一个库的依赖，而 `path` 用于声明对另一个文件的依赖。\n\n上例中，`sizzle` 是与 `jquery` 平行的另一个库，所以需要使用 `types=\"sizzle\"` 来声明对它的依赖。而其他的三斜线指令就是将 `jquery` 的声明拆分到不同的文件中了，然后在这个入口文件中使用 `path=\"foo\"` 将它们一一引入。\n\n##### 其他三斜线指令[§](/post/typescript/声明文件#其他三斜线指令)\n\n除了这两种三斜线指令之外，还有其他的三斜线指令，比如 `/// <reference no-default-lib=\"true\"/>`, `/// <amd-module />` 等，但它们都是废弃的语法，故这里就不介绍了，详情可见[官网](http://www.typescriptlang.org/docs/handbook/triple-slash-directives.html)。\n\n### 自动生成声明文件[§](/post/typescript/声明文件#自动生成声明文件)\n\n如果库的源码本身就是由 ts 写的，那么在使用 `tsc` 脚本将 ts 编译为 js 的时候，添加 `declaration` 选项，就可以同时也生成 `.d.ts` 声明文件了。\n\n我们可以在命令行中添加 `--declaration`（简写 `-d`），或者在 `tsconfig.json` 中添加 `declaration` 选项。这里以 `tsconfig.json` 为例：\n\n```json\n{\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"outDir\": \"lib\",\n        \"declaration\": true,\n    }\n}\n```\n\n上例中我们添加了 `outDir` 选项，将 ts 文件的编译结果输出到 `lib` 目录下，然后添加了 `declaration` 选项，设置为 `true`，表示将会由 ts 文件自动生成 `.d.ts` 声明文件，也会输出到 `lib` 目录下。\n\n运行 `tsc` 之后，目录结构如下[30](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/30-auto-d-ts)：\n\n```autoit\n/path/to/project\n├── lib\n|  ├── bar\n|  |  ├── index.d.ts\n|  |  └── index.js\n|  ├── index.d.ts\n|  └── index.js\n├── src\n|  ├── bar\n|  |  └── index.ts\n|  └── index.ts\n├── package.json\n└── tsconfig.json\n```\n\n在这个例子中，`src` 目录下有两个 ts 文件，分别是 `src/index.ts` 和 `src/bar/index.ts`，它们被编译到 `lib` 目录下的同时，也会生成对应的两个声明文件 `lib/index.d.ts` 和 `lib/bar/index.d.ts`。它们的内容分别是：\n\n```ts\n// src/index.ts\n\nexport * from './bar';\n\nexport default function foo() {\n    return 'foo';\n}\n// src/bar/index.ts\n\nexport function bar() {\n    return 'bar';\n}\n// lib/index.d.ts\n\nexport * from './bar';\nexport default function foo(): string;\n// lib/bar/index.d.ts\n\nexport declare function bar(): string;\n```\n\n可见，自动生成的声明文件基本保持了源码的结构，而将具体实现去掉了，生成了对应的类型声明。\n\n使用 `tsc` 自动生成声明文件时，每个 ts 文件都会对应一个 `.d.ts` 声明文件。这样的好处是，使用方不仅可以在使用 `import foo from 'foo'` 导入默认的模块时获得类型提示，还可以在使用 `import bar from 'foo/lib/bar'` 导入一个子模块时，也获得对应的类型提示。\n\n除了 `declaration` 选项之外，还有几个选项也与自动生成声明文件有关，这里只简单列举出来，不做详细演示了：\n\n- `declarationDir` 设置生成 `.d.ts` 文件的目录\n- `declarationMap` 对每个 `.d.ts` 文件，都生成对应的 `.d.ts.map`（sourcemap）文件\n- `emitDeclarationOnly` 仅生成 `.d.ts` 文件，不生成 `.js` 文件\n\n## 发布声明文件[§](/post/typescript/声明文件#发布声明文件)\n\n当我们为一个库写好了声明文件之后，下一步就是将它发布出去了。\n\n此时有两种方案：\n\n1. 将声明文件和源码放在一起\n2. 将声明文件发布到 `@types` 下\n\n这两种方案中优先选择第一种方案。保持声明文件与源码在一起，使用时就不需要额外增加单独的声明文件库的依赖了，而且也能保证声明文件的版本与源码的版本保持一致。\n\n仅当我们在给别人的仓库添加类型声明文件，但原作者不愿意合并 pull request 时，才需要使用第二种方案，将声明文件发布到 `@types` 下。\n\n### 将声明文件和源码放在一起[§](/post/typescript/声明文件#将声明文件和源码放在一起)\n\n如果声明文件是通过 `tsc` 自动生成的，那么无需做任何其他配置，只需要把编译好的文件也发布到 npm 上，使用方就可以获取到类型提示了。\n\n如果是手动写的声明文件，那么需要满足以下条件之一，才能被正确的识别：\n\n- 给 `package.json` 中的 `types` 或 `typings` 字段指定一个类型声明文件地址\n- 在项目根目录下，编写一个 `index.d.ts` 文件\n- 针对入口文件（`package.json` 中的 `main` 字段指定的入口文件），编写一个同名不同后缀的 `.d.ts` 文件\n\n第一种方式是给 `package.json` 中的 `types` 或 `typings` 字段指定一个类型声明文件地址。比如：\n\n```json\n{\n    \"name\": \"foo\",\n    \"version\": \"1.0.0\",\n    \"main\": \"lib/index.js\",\n    \"types\": \"foo.d.ts\",\n}\n```\n\n指定了 `types` 为 `foo.d.ts` 之后，导入此库的时候，就会去找 `foo.d.ts` 作为此库的类型声明文件了。\n\n`typings` 与 `types` 一样，只是另一种写法。\n\n如果没有指定 `types` 或 `typings`，那么就会在根目录下寻找 `index.d.ts` 文件，将它视为此库的类型声明文件。\n\n如果没有找到 `index.d.ts` 文件，那么就会寻找入口文件（`package.json` 中的 `main` 字段指定的入口文件）是否存在对应同名不同后缀的 `.d.ts` 文件。\n\n比如 `package.json` 是这样时：\n\n```json\n{\n    \"name\": \"foo\",\n    \"version\": \"1.0.0\",\n    \"main\": \"lib/index.js\"\n}\n```\n\n就会先识别 `package.json` 中是否存在 `types` 或 `typings` 字段。发现不存在，那么就会寻找是否存在 `index.d.ts` 文件。如果还是不存在，那么就会寻找是否存在 `lib/index.d.ts` 文件。假如说连 `lib/index.d.ts` 都不存在的话，就会被认为是一个没有提供类型声明文件的库了。\n\n有的库为了支持导入子模块，比如 `import bar from 'foo/lib/bar'`，就需要额外再编写一个类型声明文件 `lib/bar.d.ts` 或者 `lib/bar/index.d.ts`，这与自动生成声明文件类似，一个库中同时包含了多个类型声明文件。\n\n### 将声明文件发布到 `@types` 下[§](/post/typescript/声明文件#将声明文件发布到-types-下)\n\n如果我们是在给别人的仓库添加类型声明文件，但原作者不愿意合并 pull request，那么就需要将声明文件发布到 `@types` 下。\n\n与普通的 npm 模块不同，`@types` 是统一由 [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/) 管理的。要将声明文件发布到 `@types` 下，就需要给 [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/) 创建一个 pull-request，其中包含了类型声明文件，测试代码，以及 `tsconfig.json` 等。\n\npull-request 需要符合它们的规范，并且通过测试，才能被合并，稍后就会被自动发布到 `@types` 下。\n\n在 [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/) 中创建一个新的类型声明，需要用到一些工具，[DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/) 的文档中已经有了[详细的介绍](https://github.com/DefinitelyTyped/DefinitelyTyped#create-a-new-package)，这里就不赘述了，以官方文档为准。\n\n如果大家有此类需求，可以参考下笔者[提交的 pull-request](https://github.com/DefinitelyTyped/DefinitelyTyped/pull/30336/files) 。\n\n## 参考[§](/post/typescript/声明文件#参考)\n\n- [Writing Declaration Files](http://www.typescriptlang.org/docs/handbook/writing-declaration-files.html)（[中文版](https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/declaration files/Introduction.html)）\n- [Triple-Slash Directives](http://www.typescriptlang.org/docs/handbook/triple-slash-directives.html)（[中文版](https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Triple-Slash Directives.html)）\n- [typeRoots or paths](https://github.com/Microsoft/TypeScript/issues/22217#issuecomment-369783776)\n- [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/)","source":"_posts/typescript/基础/声明文件.md","raw":"---\ntitle: 基础 - 声明文件\ncover: https://whitelabelcoders.com/app/uploads/18.jpg\ncategories:\n  - TypeScript入门\ntags:\n  - TypeScript\n---\n\n\n\n# 声明文件\n\n当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。\n\n## 新语法索引[§](/post/typescript/声明文件#新语法索引)\n\n由于本章涉及大量新语法，故在本章开头列出新语法的索引，方便大家在使用这些新语法时能快速查找到对应的讲解：\n\n- [`declare var`](/post/typescript/声明文件#declare-var) 声明全局变量\n- [`declare function`](/post/typescript/声明文件#declare-function) 声明全局方法\n- [`declare class`](/post/typescript/声明文件#declare-class) 声明全局类\n- [`declare enum`](/post/typescript/声明文件#declare-enum) 声明全局枚举类型\n- [`declare namespace`](/post/typescript/声明文件#declare-namespace) 声明（含有子属性的）全局对象\n- [`interface` 和 `type`](/post/typescript/声明文件#interface-和-type) 声明全局类型\n- [`export`](/post/typescript/声明文件#export) 导出变量\n- [`export namespace`](/post/typescript/声明文件#export-namespace) 导出（含有子属性的）对象\n- [`export default`](/post/typescript/声明文件#export-default) ES6 默认导出\n- [`export =`](/post/typescript/声明文件#export-1) commonjs 导出模块\n- [`export as namespace`](/post/typescript/声明文件#export-as-namespace) UMD 库声明全局变量\n- [`declare global`](/post/typescript/声明文件#declare-global) 扩展全局变量\n- [`declare module`](/post/typescript/声明文件#declare-module) 扩展模块\n- [`/// `](/post/typescript/声明文件#san-xie-xian-zhi-ling) 三斜线指令\n\n## 什么是声明语句[§](/post/typescript/声明文件#什么是声明语句)\n\n假如我们想使用第三方库 jQuery，一种常见的方式是在 html 中通过 `<script>` 标签引入 jQuery，然后就可以使用全局变量 `$` 或 `jQuery` 了。\n\n我们通常这样获取一个 `id` 是 `foo` 的元素：\n\n```js\n$('#foo');\n// or\njQuery('#foo');\n```\n\n但是在 ts 中，编译器并不知道 `$` 或 `jQuery` 是什么东西[1](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/01-jquery)：\n\n```ts\njQuery('#foo');\n// ERROR: Cannot find name 'jQuery'.\n```\n\n这时，我们需要使用 `declare var` 来定义它的类型[2](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/02-declare-var)：\n\n```ts\ndeclare var jQuery: (selector: string) => any;\n\njQuery('#foo');\n```\n\n上例中，`declare var` 并没有真的定义一个变量，只是定义了全局变量 `jQuery` 的类型，仅仅会用于编译时的检查，在编译结果中会被删除。它编译结果是：\n\n```js\njQuery('#foo');\n```\n\n除了 `declare var` 之外，还有其他很多种声明语句，将会在后面详细介绍。\n\n## 什么是声明文件[§](/post/typescript/声明文件#什么是声明文件)\n\n通常我们会把声明语句放到一个单独的文件（`jQuery.d.ts`）中，这就是声明文件[3](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/03-jquery-d-ts)：\n\n```ts\n// src/jQuery.d.ts\n\ndeclare var jQuery: (selector: string) => any;\n// src/index.ts\n\njQuery('#foo');\n```\n\n声明文件必需以 `.d.ts` 为后缀。\n\n一般来说，ts 会解析项目中所有的 `*.ts` 文件，当然也包含以 `.d.ts` 结尾的文件。所以当我们将 `jQuery.d.ts` 放到项目中时，其他所有 `*.ts` 文件就都可以获得 `jQuery` 的类型定义了。\n\n```autoit\n/path/to/project\n├── src\n|  ├── index.ts\n|  └── jQuery.d.ts\n└── tsconfig.json\n```\n\n假如仍然无法解析，那么可以检查下 `tsconfig.json` 中的 `files`、`include` 和 `exclude` 配置，确保其包含了 `jQuery.d.ts` 文件。\n\n这里只演示了全局变量这种模式的声明文件，假如是通过模块导入的方式使用第三方库的话，那么引入声明文件又是另一种方式了，将会在后面详细介绍。\n\n### 第三方声明文件[§](/post/typescript/声明文件#第三方声明文件)\n\n当然，jQuery 的声明文件不需要我们定义了，社区已经帮我们定义好了：[jQuery in DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/jquery/index.d.ts)。\n\n我们可以直接下载下来使用，但是更推荐的是使用 `@types` 统一管理第三方库的声明文件。\n\n`@types` 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例：\n\n```bash\nnpm install @types/jquery --save-dev\n```\n\n可以在[这个页面](https://microsoft.github.io/TypeSearch/)搜索你需要的声明文件。\n\n## 书写声明文件[§](/post/typescript/声明文件#书写声明文件)\n\n当一个第三方库没有提供声明文件时，我们就需要自己书写声明文件了。前面只介绍了最简单的声明文件内容，而真正书写一个声明文件并不是一件简单的事，以下会详细介绍如何书写声明文件。\n\n在不同的场景下，声明文件的内容和使用方式会有所区别。\n\n库的使用场景主要有以下几种：\n\n- [全局变量](/post/typescript/声明文件#quan-ju-bian-liang)：通过 `<script>` 标签引入第三方库，注入全局变量\n- [npm 包](/post/typescript/声明文件#npm-bao)：通过 `import foo from 'foo'` 导入，符合 ES6 模块规范\n- [UMD 库](/post/typescript/声明文件#umd-ku)：既可以通过 `<script>` 标签引入，又可以通过 `import` 导入\n- [直接扩展全局变量](/post/typescript/声明文件#zhi-jie-kuo-zhan-quan-ju-bian-liang)：通过 `<script>` 标签引入后，改变一个全局变量的结构\n- [在 npm 包或 UMD 库中扩展全局变量](/post/typescript/声明文件#zai-npm-bao-huo-umd-ku-zhong-kuo-zhan-quan-ju-bian-liang)：引用 npm 包或 UMD 库后，改变一个全局变量的结构\n- [模块插件](/post/typescript/声明文件#mo-kuai-cha-jian)：通过 `<script>` 或 `import` 导入后，改变另一个模块的结构\n\n### 全局变量[§](/post/typescript/声明文件#全局变量)\n\n全局变量是最简单的一种场景，之前举的例子就是通过 `<script>` 标签引入 jQuery，注入全局变量 `$` 和 `jQuery`。\n\n使用全局变量的声明文件时，如果是以 `npm install @types/xxx --save-dev` 安装的，则不需要任何配置。如果是将声明文件直接存放于当前项目中，则建议和其他源码一起放到 `src` 目录下（或者对应的源码目录下）：\n\n```autoit\n/path/to/project\n├── src\n|  ├── index.ts\n|  └── jQuery.d.ts\n└── tsconfig.json\n```\n\n如果没有生效，可以检查下 `tsconfig.json` 中的 `files`、`include` 和 `exclude` 配置，确保其包含了 `jQuery.d.ts` 文件。\n\n全局变量的声明文件主要有以下几种语法：\n\n- [`declare var`](/post/typescript/声明文件#declare-var) 声明全局变量\n- [`declare function`](/post/typescript/声明文件#declare-function) 声明全局方法\n- [`declare class`](/post/typescript/声明文件#declare-class) 声明全局类\n- [`declare enum`](/post/typescript/声明文件#declare-enum) 声明全局枚举类型\n- [`declare namespace`](/post/typescript/声明文件#declare-namespace) 声明（含有子属性的）全局对象\n- [`interface` 和 `type`](/post/typescript/声明文件#interface-he-type) 声明全局类型\n\n#### `declare var`[§](/post/typescript/声明文件#declare-var)\n\n在所有的声明语句中，`declare var` 是最简单的，如之前所学，它能够用来定义一个全局变量的类型。与其类似的，还有 `declare let` 和 `declare const`，使用 `let` 与使用 `var` 没有什么区别：\n\n```ts\n// src/jQuery.d.ts\n\ndeclare let jQuery: (selector: string) => any;\n// src/index.ts\n\njQuery('#foo');\n// 使用 declare let 定义的 jQuery 类型，允许修改这个全局变量\njQuery = function(selector) {\n    return document.querySelector(selector);\n};\n```\n\n而当我们使用 `const` 定义时，表示此时的全局变量是一个常量，不允许再去修改它的值了[4](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/04-declare-const-jquery)：\n\n```ts\n// src/jQuery.d.ts\n\ndeclare const jQuery: (selector: string) => any;\n\njQuery('#foo');\n// 使用 declare const 定义的 jQuery 类型，禁止修改这个全局变量\njQuery = function(selector) {\n    return document.querySelector(selector);\n};\n// ERROR: Cannot assign to 'jQuery' because it is a constant or a read-only property.\n```\n\n一般来说，全局变量都是禁止修改的常量，所以大部分情况都应该使用 `const` 而不是 `var` 或 `let`。\n\n需要注意的是，声明语句中只能定义类型，切勿在声明语句中定义具体的实现[5](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/05-declare-jquery-value)：\n\n```ts\ndeclare const jQuery = function(selector) {\n    return document.querySelector(selector);\n};\n// ERROR: An implementation cannot be declared in ambient contexts.\n```\n\n#### `declare function`[§](/post/typescript/声明文件#declare-function)\n\n`declare function` 用来定义全局函数的类型。jQuery 其实就是一个函数，所以也可以用 `function` 来定义：\n\n```ts\n// src/jQuery.d.ts\n\ndeclare function jQuery(selector: string): any;\n// src/index.ts\n\njQuery('#foo');\n```\n\n在函数类型的声明语句中，函数重载也是支持的[6](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/06-declare-function)：\n\n```ts\n// src/jQuery.d.ts\n\ndeclare function jQuery(selector: string): any;\ndeclare function jQuery(domReadyCallback: () => any): any;\n// src/index.ts\n\njQuery('#foo');\njQuery(function() {\n    alert('Dom Ready!');\n});\n```\n\n#### `declare class`[§](/post/typescript/声明文件#declare-class)\n\n当全局变量是一个类的时候，我们用 `declare class` 来定义它的类型[7](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/07-declare-class)：\n\n```ts\n// src/Animal.d.ts\n\ndeclare class Animal {\n    name: string;\n    constructor(name: string);\n    sayHi(): string;\n}\n// src/index.ts\n\nlet cat = new Animal('Tom');\n```\n\n同样的，`declare class` 语句也只能用来定义类型，不能用来定义具体的实现，比如定义 `sayHi` 方法的具体实现则会报错：\n\n```ts\n// src/Animal.d.ts\n\ndeclare class Animal {\n    name: string;\n    constructor(name: string);\n    sayHi() {\n        return `My name is ${this.name}`;\n    };\n    // ERROR: An implementation cannot be declared in ambient contexts.\n}\n```\n\n#### `declare enum`[§](/post/typescript/声明文件#declare-enum)\n\n使用 `declare enum` 定义的枚举类型也称作外部枚举（Ambient Enums），举例如下[8](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/08-declare-enum)：\n\n```ts\n// src/Directions.d.ts\n\ndeclare enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\n// src/index.ts\n\nlet directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n```\n\n与其他全局变量的类型声明一致，`declare enum` 仅用来定义类型，而不是具体的值。\n\n`Directions.d.ts` 仅仅会用于编译时的检查，声明文件里的内容在编译结果中会被删除。它编译结果是：\n\n```js\nvar directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n```\n\n其中 `Directions` 是由第三方库定义好的全局变量。\n\n#### `declare namespace`[§](/post/typescript/声明文件#declare-namespace)\n\n`namespace` 是 ts 早期时为了解决模块化而创造的关键字，中文称为命名空间。\n\n由于历史遗留原因，在早期还没有 ES6 的时候，ts 提供了一种模块化方案，使用 `module` 关键字表示内部模块。但由于后来 ES6 也使用了 `module` 关键字，ts 为了兼容 ES6，使用 `namespace` 替代了自己的 `module`，更名为命名空间。\n\n随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的 `namespace`，而推荐使用 ES6 的模块化方案了，故我们不再需要学习 `namespace` 的使用了。\n\n`namespace` 被淘汰了，但是在声明文件中，`declare namespace` 还是比较常用的，它用来表示全局变量是一个对象，包含很多子属性。\n\n比如 `jQuery` 是一个全局变量，它是一个对象，提供了一个 `jQuery.ajax` 方法可以调用，那么我们就应该使用 `declare namespace jQuery` 来声明这个拥有多个子属性的全局变量。\n\n```ts\n// src/jQuery.d.ts\n\ndeclare namespace jQuery {\n    function ajax(url: string, settings?: any): void;\n}\n// src/index.ts\n\njQuery.ajax('/api/get_something');\n```\n\n注意，在 `declare namespace` 内部，我们直接使用 `function ajax` 来声明函数，而不是使用 `declare function ajax`。类似的，也可以使用 `const`, `class`, `enum` 等语句[9](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/09-declare-namespace)：\n\n```ts\n// src/jQuery.d.ts\n\ndeclare namespace jQuery {\n    function ajax(url: string, settings?: any): void;\n    const version: number;\n    class Event {\n        blur(eventType: EventType): void\n    }\n    enum EventType {\n        CustomClick\n    }\n}\n// src/index.ts\n\njQuery.ajax('/api/get_something');\nconsole.log(jQuery.version);\nconst e = new jQuery.Event();\ne.blur(jQuery.EventType.CustomClick);\n```\n\n##### 嵌套的命名空间[§](/post/typescript/声明文件#嵌套的命名空间)\n\n如果对象拥有深层的层级，则需要用嵌套的 `namespace` 来声明深层的属性的类型[10](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/10-declare-namespace-nesting)：\n\n```ts\n// src/jQuery.d.ts\n\ndeclare namespace jQuery {\n    function ajax(url: string, settings?: any): void;\n    namespace fn {\n        function extend(object: any): void;\n    }\n}\n// src/index.ts\n\njQuery.ajax('/api/get_something');\njQuery.fn.extend({\n    check: function() {\n        return this.each(function() {\n            this.checked = true;\n        });\n    }\n});\n```\n\n假如 `jQuery` 下仅有 `fn` 这一个属性（没有 `ajax` 等其他属性或方法），则可以不需要嵌套 `namespace`[11](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/11-declare-namespace-dot)：\n\n```ts\n// src/jQuery.d.ts\n\ndeclare namespace jQuery.fn {\n    function extend(object: any): void;\n}\n// src/index.ts\n\njQuery.fn.extend({\n    check: function() {\n        return this.each(function() {\n            this.checked = true;\n        });\n    }\n});\n```\n\n#### `interface` 和 `type`[§](/post/typescript/声明文件#interface-和-type)\n\n除了全局变量之外，可能有一些类型我们也希望能暴露出来。在类型声明文件中，我们可以直接使用 `interface` 或 `type` 来声明一个全局的接口或类型[12](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/12-interface)：\n\n```ts\n// src/jQuery.d.ts\n\ninterface AjaxSettings {\n    method?: 'GET' | 'POST'\n    data?: any;\n}\ndeclare namespace jQuery {\n    function ajax(url: string, settings?: AjaxSettings): void;\n}\n```\n\n这样的话，在其他文件中也可以使用这个接口或类型了：\n\n```ts\n// src/index.ts\n\nlet settings: AjaxSettings = {\n    method: 'POST',\n    data: {\n        name: 'foo'\n    }\n};\njQuery.ajax('/api/post_something', settings);\n```\n\n`type` 与 `interface` 类似，不再赘述。\n\n##### 防止命名冲突[§](/post/typescript/声明文件#防止命名冲突)\n\n暴露在最外层的 `interface` 或 `type` 会作为全局类型作用于整个项目中，我们应该尽可能的减少全局变量或全局类型的数量。故最好将他们放到 `namespace` 下[13](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/13-avoid-name-conflict)：\n\n```ts\n// src/jQuery.d.ts\n\ndeclare namespace jQuery {\n    interface AjaxSettings {\n        method?: 'GET' | 'POST'\n        data?: any;\n    }\n    function ajax(url: string, settings?: AjaxSettings): void;\n}\n```\n\n注意，在使用这个 `interface` 的时候，也应该加上 `jQuery` 前缀：\n\n```ts\n// src/index.ts\n\nlet settings: jQuery.AjaxSettings = {\n    method: 'POST',\n    data: {\n        name: 'foo'\n    }\n};\njQuery.ajax('/api/post_something', settings);\n```\n\n#### 声明合并[§](/post/typescript/声明文件#声明合并)\n\n假如 jQuery 既是一个函数，可以直接被调用 `jQuery('#foo')`，又是一个对象，拥有子属性 `jQuery.ajax()`（事实确实如此），那么我们可以组合多个声明语句，它们会不冲突的合并起来[14](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/14-declaration-merging)：\n\n```ts\n// src/jQuery.d.ts\n\ndeclare function jQuery(selector: string): any;\ndeclare namespace jQuery {\n    function ajax(url: string, settings?: any): void;\n}\n// src/index.ts\n\njQuery('#foo');\njQuery.ajax('/api/get_something');\n```\n\n关于声明合并的更多用法，可以查看[声明合并](https://ts.xcatliu.com/advanced/declaration-merging.html)章节。\n\n### npm 包[§](/post/typescript/声明文件#npm-包)\n\n一般我们通过 `import foo from 'foo'` 导入一个 npm 包，这是符合 ES6 模块规范的。\n\n在我们尝试给一个 npm 包创建声明文件之前，需要先看看它的声明文件是否已经存在。一般来说，npm 包的声明文件可能存在于两个地方：\n\n1. 与该 npm 包绑定在一起。判断依据是 `package.json` 中有 `types` 字段，或者有一个 `index.d.ts` 声明文件。这种模式不需要额外安装其他包，是最为推荐的，所以以后我们自己创建 npm 包的时候，最好也将声明文件与 npm 包绑定在一起。\n2. 发布到 `@types` 里。我们只需要尝试安装一下对应的 `@types` 包就知道是否存在该声明文件，安装命令是 `npm install @types/foo --save-dev`。这种模式一般是由于 npm 包的维护者没有提供声明文件，所以只能由其他人将声明文件发布到 `@types` 里了。\n\n假如以上两种方式都没有找到对应的声明文件，那么我们就需要自己为它写声明文件了。由于是通过 `import` 语句导入的模块，所以声明文件存放的位置也有所约束，一般有两种方案：\n\n1. 创建一个 `node_modules/@types/foo/index.d.ts` 文件，存放 `foo` 模块的声明文件。这种方式不需要额外的配置，但是 `node_modules` 目录不稳定，代码也没有被保存到仓库中，无法回溯版本，有不小心被删除的风险，故不太建议用这种方案，一般只用作临时测试。\n2. 创建一个 `types` 目录，专门用来管理自己写的声明文件，将 `foo` 的声明文件放到 `types/foo/index.d.ts` 中。这种方式需要配置下 `tsconfig.json` 中的 `paths` 和 `baseUrl` 字段。\n\n目录结构：\n\n```autoit\n/path/to/project\n├── src\n|  └── index.ts\n├── types\n|  └── foo\n|     └── index.d.ts\n└── tsconfig.json\n```\n\n`tsconfig.json` 内容：\n\n```json\n{\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"baseUrl\": \"./\",\n        \"paths\": {\n            \"*\": [\"types/*\"]\n        }\n    }\n}\n```\n\n如此配置之后，通过 `import` 导入 `foo` 的时候，也会去 `types` 目录下寻找对应的模块的声明文件了。\n\n注意 `module` 配置可以有很多种选项，不同的选项会影响模块的导入导出模式。这里我们使用了 `commonjs` 这个最常用的选项，后面的教程也都默认使用的这个选项。\n\n不管采用了以上两种方式中的哪一种，我都**强烈建议**大家将书写好的声明文件（通过给第三方库发 pull request，或者直接提交到 `@types` 里）发布到开源社区中，享受了这么多社区的优秀的资源，就应该在力所能及的时候给出一些回馈。只有所有人都参与进来，才能让 ts 社区更加繁荣。\n\nnpm 包的声明文件主要有以下几种语法：\n\n- [`export`](/post/typescript/声明文件#export) 导出变量\n- [`export namespace`](/post/typescript/声明文件#export-namespace) 导出（含有子属性的）对象\n- [`export default`](/post/typescript/声明文件#export-default) ES6 默认导出\n- [`export =`](/post/typescript/声明文件#export-1) commonjs 导出模块\n\n#### `export`[§](/post/typescript/声明文件#export)\n\nnpm 包的声明文件与全局变量的声明文件有很大区别。在 npm 包的声明文件中，使用 `declare` 不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。只有在声明文件中使用 `export` 导出，然后在使用方 `import` 导入后，才会应用到这些类型声明。\n\n`export` 的语法与普通的 ts 中的语法类似，区别仅在于声明文件中禁止定义具体的实现[15](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/15-export)：\n\n```ts\n// types/foo/index.d.ts\n\nexport const name: string;\nexport function getName(): string;\nexport class Animal {\n    constructor(name: string);\n    sayHi(): string;\n}\nexport enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\nexport interface Options {\n    data: any;\n}\n```\n\n对应的导入和使用模块应该是这样：\n\n```ts\n// src/index.ts\n\nimport { name, getName, Animal, Directions, Options } from 'foo';\n\nconsole.log(name);\nlet myName = getName();\nlet cat = new Animal('Tom');\nlet directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\nlet options: Options = {\n    data: {\n        name: 'foo'\n    }\n};\n```\n\n##### 混用 `declare` 和 `export`[§](/post/typescript/声明文件#混用-declare-和-export)\n\n我们也可以使用 `declare` 先声明多个变量，最后再用 `export` 一次性导出。上例的声明文件可以等价的改写为[16](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/16-declare-and-export)：\n\n```ts\n// types/foo/index.d.ts\n\ndeclare const name: string;\ndeclare function getName(): string;\ndeclare class Animal {\n    constructor(name: string);\n    sayHi(): string;\n}\ndeclare enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\ninterface Options {\n    data: any;\n}\n\nexport { name, getName, Animal, Directions, Options };\n```\n\n注意，与全局变量的声明文件类似，`interface` 前是不需要 `declare` 的。\n\n#### `export namespace`[§](/post/typescript/声明文件#export-namespace)\n\n与 `declare namespace` 类似，`export namespace` 用来导出一个拥有子属性的对象[17](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/17-export-namespace)：\n\n```ts\n// types/foo/index.d.ts\n\nexport namespace foo {\n    const name: string;\n    namespace bar {\n        function baz(): string;\n    }\n}\n// src/index.ts\n\nimport { foo } from 'foo';\n\nconsole.log(foo.name);\nfoo.bar.baz();\n```\n\n#### `export default`[§](/post/typescript/声明文件#export-default)\n\n在 ES6 模块系统中，使用 `export default` 可以导出一个默认值，使用方可以用 `import foo from 'foo'` 而不是 `import { foo } from 'foo'` 来导入这个默认值。\n\n在类型声明文件中，`export default` 用来导出默认值的类型[18](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/18-export-default)：\n\n```ts\n// types/foo/index.d.ts\n\nexport default function foo(): string;\n// src/index.ts\n\nimport foo from 'foo';\n\nfoo();\n```\n\n注意，只有 `function`、`class` 和 `interface` 可以直接默认导出，其他的变量需要先定义出来，再默认导出[19](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/19-export-default-enum-error)：\n\n```ts\n// types/foo/index.d.ts\n\nexport default enum Directions {\n// ERROR: Expression expected.\n    Up,\n    Down,\n    Left,\n    Right\n}\n```\n\n上例中 `export default enum` 是错误的语法，需要使用 `declare enum` 定义出来，然后使用 `export default` 导出：\n\n```ts\n// types/foo/index.d.ts\n\ndeclare enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\n\nexport default Directions;\n```\n\n针对这种默认导出，我们一般会将导出语句放在整个声明文件的最前面[20](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/20-export-default-enum)：\n\n```ts\n// types/foo/index.d.ts\n\nexport default Directions;\n\ndeclare enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\n```\n\n#### `export =`[§](/post/typescript/声明文件#export-)\n\n在 commonjs 规范中，我们用以下方式来导出一个模块：\n\n```js\n// 整体导出\nmodule.exports = foo;\n// 单个导出\nexports.bar = bar;\n```\n\n在 ts 中，针对这种模块导出，有多种方式可以导入，第一种方式是 `const ... = require`：\n\n```js\n// 整体导入\nconst foo = require('foo');\n// 单个导入\nconst bar = require('foo').bar;\n```\n\n第二种方式是 `import ... from`，注意针对整体导出，需要使用 `import * as` 来导入：\n\n```ts\n// 整体导入\nimport * as foo from 'foo';\n// 单个导入\nimport { bar } from 'foo';\n```\n\n第三种方式是 `import ... require`，这也是 ts 官方推荐的方式：\n\n```ts\n// 整体导入\nimport foo = require('foo');\n// 单个导入\nimport bar = foo.bar;\n```\n\n对于这种使用 commonjs 规范的库，假如要为它写类型声明文件的话，就需要使用到 `export =` 这种语法了[21](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/21-export-equal)：\n\n```ts\n// types/foo/index.d.ts\n\nexport = foo;\n\ndeclare function foo(): string;\ndeclare namespace foo {\n    const bar: number;\n}\n```\n\n需要注意的是，上例中使用了 `export =` 之后，就不能再单个导出 `export { bar }` 了。所以我们通过声明合并，使用 `declare namespace foo` 来将 `bar` 合并到 `foo` 里。\n\n准确地讲，`export =` 不仅可以用在声明文件中，也可以用在普通的 ts 文件中。实际上，`import ... require` 和 `export =` 都是 ts 为了兼容 AMD 规范和 commonjs 规范而创立的新语法，由于并不常用也不推荐使用，所以这里就不详细介绍了，感兴趣的可以看[官方文档](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require)。\n\n由于很多第三方库是 commonjs 规范的，所以声明文件也就不得不用到 `export =` 这种语法了。但是还是需要再强调下，相比与 `export =`，我们更推荐使用 ES6 标准的 `export default` 和 `export`。\n\n### UMD 库[§](/post/typescript/声明文件#umd-库)\n\n既可以通过 `<script>` 标签引入，又可以通过 `import` 导入的库，称为 UMD 库。相比于 npm 包的类型声明文件，我们需要额外声明一个全局变量，为了实现这种方式，ts 提供了一个新语法 `export as namespace`。\n\n#### `export as namespace`[§](/post/typescript/声明文件#export-as-namespace)\n\n一般使用 `export as namespace` 时，都是先有了 npm 包的声明文件，再基于它添加一条 `export as namespace` 语句，即可将声明好的一个变量声明为全局变量，举例如下[22](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/22-export-as-namespace)：\n\n```ts\n// types/foo/index.d.ts\n\nexport as namespace foo;\nexport = foo;\n\ndeclare function foo(): string;\ndeclare namespace foo {\n    const bar: number;\n}\n```\n\n当然它也可以与 `export default` 一起使用：\n\n```ts\n// types/foo/index.d.ts\n\nexport as namespace foo;\nexport default foo;\n\ndeclare function foo(): string;\ndeclare namespace foo {\n    const bar: number;\n}\n```\n\n### 直接扩展全局变量[§](/post/typescript/声明文件#直接扩展全局变量)\n\n有的第三方库扩展了一个全局变量，可是此全局变量的类型却没有相应的更新过来，就会导致 ts 编译错误，此时就需要扩展全局变量的类型。比如扩展 `String` 类型[23](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/23-merge-global-interface)：\n\n```ts\ninterface String {\n    prependHello(): string;\n}\n\n'foo'.prependHello();\n```\n\n通过声明合并，使用 `interface String` 即可给 `String` 添加属性或方法。\n\n也可以使用 `declare namespace` 给已有的命名空间添加类型声明[24](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/24-merge-global-namespace)：\n\n```ts\n// types/jquery-plugin/index.d.ts\n\ndeclare namespace JQuery {\n    interface CustomOptions {\n        bar: string;\n    }\n}\n\ninterface JQueryStatic {\n    foo(options: JQuery.CustomOptions): string;\n}\n// src/index.ts\n\njQuery.foo({\n    bar: ''\n});\n```\n\n### 在 npm 包或 UMD 库中扩展全局变量[§](/post/typescript/声明文件#在-npm-包或-umd-库中扩展全局变量)\n\n如之前所说，对于一个 npm 包或者 UMD 库的声明文件，只有 `export` 导出的类型声明才能被导入。所以对于 npm 包或 UMD 库，如果导入此库之后会扩展全局变量，则需要使用另一种语法在声明文件中扩展全局变量的类型，那就是 `declare global`。\n\n#### `declare global`[§](/post/typescript/声明文件#declare-global)\n\n使用 `declare global` 可以在 npm 包或者 UMD 库的声明文件中扩展全局变量的类型[25](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/25-declare-global)：\n\n```ts\n// types/foo/index.d.ts\n\ndeclare global {\n    interface String {\n        prependHello(): string;\n    }\n}\n\nexport {};\n// src/index.ts\n\n'bar'.prependHello();\n```\n\n注意即使此声明文件不需要导出任何东西，仍然需要导出一个空对象，用来告诉编译器这是一个模块的声明文件，而不是一个全局变量的声明文件。\n\n### 模块插件[§](/post/typescript/声明文件#模块插件)\n\n有时通过 `import` 导入一个模块插件，可以改变另一个原有模块的结构。此时如果原有模块已经有了类型声明文件，而插件模块没有类型声明文件，就会导致类型不完整，缺少插件部分的类型。ts 提供了一个语法 `declare module`，它可以用来扩展原有模块的类型。\n\n#### `declare module`[§](/post/typescript/声明文件#declare-module)\n\n如果是需要扩展原有模块的话，需要在类型声明文件中先引用原有模块，再使用 `declare module` 扩展原有模块[26](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/26-declare-module)：\n\n```ts\n// types/moment-plugin/index.d.ts\n\nimport * as moment from 'moment';\n\ndeclare module 'moment' {\n    export function foo(): moment.CalendarKey;\n}\n// src/index.ts\n\nimport * as moment from 'moment';\nimport 'moment-plugin';\n\nmoment.foo();\n```\n\n`declare module` 也可用于在一个文件中一次性声明多个模块的类型[27](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/27-multiple-declare-module)：\n\n```ts\n// types/foo-bar.d.ts\n\ndeclare module 'foo' {\n    export interface Foo {\n        foo: string;\n    }\n}\n\ndeclare module 'bar' {\n    export function bar(): string;\n}\n// src/index.ts\n\nimport { Foo } from 'foo';\nimport * as bar from 'bar';\n\nlet f: Foo;\nbar.bar();\n```\n\n### 声明文件中的依赖[§](/post/typescript/声明文件#声明文件中的依赖)\n\n一个声明文件有时会依赖另一个声明文件中的类型，比如在前面的 `declare module` 的例子中，我们就在声明文件中导入了 `moment`，并且使用了 `moment.CalendarKey` 这个类型：\n\n```ts\n// types/moment-plugin/index.d.ts\n\nimport * as moment from 'moment';\n\ndeclare module 'moment' {\n    export function foo(): moment.CalendarKey;\n}\n```\n\n除了可以在声明文件中通过 `import` 导入另一个声明文件中的类型之外，还有一个语法也可以用来导入另一个声明文件，那就是三斜线指令。\n\n#### 三斜线指令[§](/post/typescript/声明文件#三斜线指令)\n\n与 `namespace` 类似，三斜线指令也是 ts 在早期版本中为了描述模块之间的依赖关系而创造的语法。随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的三斜线指令来声明模块之间的依赖关系了。\n\n但是在声明文件中，它还是有一定的用武之地。\n\n类似于声明文件中的 `import`，它可以用来导入另一个声明文件。与 `import` 的区别是，当且仅当在以下几个场景下，我们才需要使用三斜线指令替代 `import`：\n\n- 当我们在**书写**一个全局变量的声明文件时\n- 当我们需要**依赖**一个全局变量的声明文件时\n\n##### **书写**一个全局变量的声明文件[§](/post/typescript/声明文件#书写一个全局变量的声明文件)\n\n这些场景听上去很拗口，但实际上很好理解——在全局变量的声明文件中，是不允许出现 `import`, `export` 关键字的。一旦出现了，那么他就会被视为一个 npm 包或 UMD 库，就不再是全局变量的声明文件了。故当我们在书写一个全局变量的声明文件时，如果需要引用另一个库的类型，那么就必须用三斜线指令了[28](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/28-triple-slash-directives)：\n\n```ts\n// types/jquery-plugin/index.d.ts\n\n/// <reference types=\"jquery\" />\n\ndeclare function foo(options: JQuery.AjaxSettings): string;\n// src/index.ts\n\nfoo({});\n```\n\n三斜线指令的语法如上，`///` 后面使用 xml 的格式添加了对 `jquery` 类型的依赖，这样就可以在声明文件中使用 `JQuery.AjaxSettings` 类型了。\n\n注意，三斜线指令必须放在文件的最顶端，三斜线指令的前面只允许出现单行或多行注释。\n\n##### **依赖**一个全局变量的声明文件[§](/post/typescript/声明文件#依赖一个全局变量的声明文件)\n\n在另一个场景下，当我们需要依赖一个全局变量的声明文件时，由于全局变量不支持通过 `import` 导入，当然也就必须使用三斜线指令来引入了[29](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/29-triple-slash-directives-global)：\n\n```ts\n// types/node-plugin/index.d.ts\n\n/// <reference types=\"node\" />\n\nexport function foo(p: NodeJS.Process): string;\n// src/index.ts\n\nimport { foo } from 'node-plugin';\n\nfoo(global.process);\n```\n\n在上面的例子中，我们通过三斜线指引入了 `node` 的类型，然后在声明文件中使用了 `NodeJS.Process` 这个类型。最后在使用到 `foo` 的时候，传入了 `node` 中的全局变量 `process`。\n\n由于引入的 `node` 中的类型都是全局变量的类型，它们是没有办法通过 `import` 来导入的，所以这种场景下也只能通过三斜线指令来引入了。\n\n以上两种使用场景下，都是由于需要书写或需要依赖全局变量的声明文件，所以必须使用三斜线指令。在其他的一些不是必要使用三斜线指令的情况下，就都需要使用 `import` 来导入。\n\n##### 拆分声明文件[§](/post/typescript/声明文件#拆分声明文件)\n\n当我们的全局变量的声明文件太大时，可以通过拆分为多个文件，然后在一个入口文件中将它们一一引入，来提高代码的可维护性。比如 `jQuery` 的声明文件就是这样的：\n\n```ts\n// node_modules/@types/jquery/index.d.ts\n\n/// <reference types=\"sizzle\" />\n/// <reference path=\"JQueryStatic.d.ts\" />\n/// <reference path=\"JQuery.d.ts\" />\n/// <reference path=\"misc.d.ts\" />\n/// <reference path=\"legacy.d.ts\" />\n\nexport = jQuery;\n```\n\n其中用到了 `types` 和 `path` 两种不同的指令。它们的区别是：`types` 用于声明对另一个库的依赖，而 `path` 用于声明对另一个文件的依赖。\n\n上例中，`sizzle` 是与 `jquery` 平行的另一个库，所以需要使用 `types=\"sizzle\"` 来声明对它的依赖。而其他的三斜线指令就是将 `jquery` 的声明拆分到不同的文件中了，然后在这个入口文件中使用 `path=\"foo\"` 将它们一一引入。\n\n##### 其他三斜线指令[§](/post/typescript/声明文件#其他三斜线指令)\n\n除了这两种三斜线指令之外，还有其他的三斜线指令，比如 `/// <reference no-default-lib=\"true\"/>`, `/// <amd-module />` 等，但它们都是废弃的语法，故这里就不介绍了，详情可见[官网](http://www.typescriptlang.org/docs/handbook/triple-slash-directives.html)。\n\n### 自动生成声明文件[§](/post/typescript/声明文件#自动生成声明文件)\n\n如果库的源码本身就是由 ts 写的，那么在使用 `tsc` 脚本将 ts 编译为 js 的时候，添加 `declaration` 选项，就可以同时也生成 `.d.ts` 声明文件了。\n\n我们可以在命令行中添加 `--declaration`（简写 `-d`），或者在 `tsconfig.json` 中添加 `declaration` 选项。这里以 `tsconfig.json` 为例：\n\n```json\n{\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"outDir\": \"lib\",\n        \"declaration\": true,\n    }\n}\n```\n\n上例中我们添加了 `outDir` 选项，将 ts 文件的编译结果输出到 `lib` 目录下，然后添加了 `declaration` 选项，设置为 `true`，表示将会由 ts 文件自动生成 `.d.ts` 声明文件，也会输出到 `lib` 目录下。\n\n运行 `tsc` 之后，目录结构如下[30](https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/30-auto-d-ts)：\n\n```autoit\n/path/to/project\n├── lib\n|  ├── bar\n|  |  ├── index.d.ts\n|  |  └── index.js\n|  ├── index.d.ts\n|  └── index.js\n├── src\n|  ├── bar\n|  |  └── index.ts\n|  └── index.ts\n├── package.json\n└── tsconfig.json\n```\n\n在这个例子中，`src` 目录下有两个 ts 文件，分别是 `src/index.ts` 和 `src/bar/index.ts`，它们被编译到 `lib` 目录下的同时，也会生成对应的两个声明文件 `lib/index.d.ts` 和 `lib/bar/index.d.ts`。它们的内容分别是：\n\n```ts\n// src/index.ts\n\nexport * from './bar';\n\nexport default function foo() {\n    return 'foo';\n}\n// src/bar/index.ts\n\nexport function bar() {\n    return 'bar';\n}\n// lib/index.d.ts\n\nexport * from './bar';\nexport default function foo(): string;\n// lib/bar/index.d.ts\n\nexport declare function bar(): string;\n```\n\n可见，自动生成的声明文件基本保持了源码的结构，而将具体实现去掉了，生成了对应的类型声明。\n\n使用 `tsc` 自动生成声明文件时，每个 ts 文件都会对应一个 `.d.ts` 声明文件。这样的好处是，使用方不仅可以在使用 `import foo from 'foo'` 导入默认的模块时获得类型提示，还可以在使用 `import bar from 'foo/lib/bar'` 导入一个子模块时，也获得对应的类型提示。\n\n除了 `declaration` 选项之外，还有几个选项也与自动生成声明文件有关，这里只简单列举出来，不做详细演示了：\n\n- `declarationDir` 设置生成 `.d.ts` 文件的目录\n- `declarationMap` 对每个 `.d.ts` 文件，都生成对应的 `.d.ts.map`（sourcemap）文件\n- `emitDeclarationOnly` 仅生成 `.d.ts` 文件，不生成 `.js` 文件\n\n## 发布声明文件[§](/post/typescript/声明文件#发布声明文件)\n\n当我们为一个库写好了声明文件之后，下一步就是将它发布出去了。\n\n此时有两种方案：\n\n1. 将声明文件和源码放在一起\n2. 将声明文件发布到 `@types` 下\n\n这两种方案中优先选择第一种方案。保持声明文件与源码在一起，使用时就不需要额外增加单独的声明文件库的依赖了，而且也能保证声明文件的版本与源码的版本保持一致。\n\n仅当我们在给别人的仓库添加类型声明文件，但原作者不愿意合并 pull request 时，才需要使用第二种方案，将声明文件发布到 `@types` 下。\n\n### 将声明文件和源码放在一起[§](/post/typescript/声明文件#将声明文件和源码放在一起)\n\n如果声明文件是通过 `tsc` 自动生成的，那么无需做任何其他配置，只需要把编译好的文件也发布到 npm 上，使用方就可以获取到类型提示了。\n\n如果是手动写的声明文件，那么需要满足以下条件之一，才能被正确的识别：\n\n- 给 `package.json` 中的 `types` 或 `typings` 字段指定一个类型声明文件地址\n- 在项目根目录下，编写一个 `index.d.ts` 文件\n- 针对入口文件（`package.json` 中的 `main` 字段指定的入口文件），编写一个同名不同后缀的 `.d.ts` 文件\n\n第一种方式是给 `package.json` 中的 `types` 或 `typings` 字段指定一个类型声明文件地址。比如：\n\n```json\n{\n    \"name\": \"foo\",\n    \"version\": \"1.0.0\",\n    \"main\": \"lib/index.js\",\n    \"types\": \"foo.d.ts\",\n}\n```\n\n指定了 `types` 为 `foo.d.ts` 之后，导入此库的时候，就会去找 `foo.d.ts` 作为此库的类型声明文件了。\n\n`typings` 与 `types` 一样，只是另一种写法。\n\n如果没有指定 `types` 或 `typings`，那么就会在根目录下寻找 `index.d.ts` 文件，将它视为此库的类型声明文件。\n\n如果没有找到 `index.d.ts` 文件，那么就会寻找入口文件（`package.json` 中的 `main` 字段指定的入口文件）是否存在对应同名不同后缀的 `.d.ts` 文件。\n\n比如 `package.json` 是这样时：\n\n```json\n{\n    \"name\": \"foo\",\n    \"version\": \"1.0.0\",\n    \"main\": \"lib/index.js\"\n}\n```\n\n就会先识别 `package.json` 中是否存在 `types` 或 `typings` 字段。发现不存在，那么就会寻找是否存在 `index.d.ts` 文件。如果还是不存在，那么就会寻找是否存在 `lib/index.d.ts` 文件。假如说连 `lib/index.d.ts` 都不存在的话，就会被认为是一个没有提供类型声明文件的库了。\n\n有的库为了支持导入子模块，比如 `import bar from 'foo/lib/bar'`，就需要额外再编写一个类型声明文件 `lib/bar.d.ts` 或者 `lib/bar/index.d.ts`，这与自动生成声明文件类似，一个库中同时包含了多个类型声明文件。\n\n### 将声明文件发布到 `@types` 下[§](/post/typescript/声明文件#将声明文件发布到-types-下)\n\n如果我们是在给别人的仓库添加类型声明文件，但原作者不愿意合并 pull request，那么就需要将声明文件发布到 `@types` 下。\n\n与普通的 npm 模块不同，`@types` 是统一由 [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/) 管理的。要将声明文件发布到 `@types` 下，就需要给 [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/) 创建一个 pull-request，其中包含了类型声明文件，测试代码，以及 `tsconfig.json` 等。\n\npull-request 需要符合它们的规范，并且通过测试，才能被合并，稍后就会被自动发布到 `@types` 下。\n\n在 [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/) 中创建一个新的类型声明，需要用到一些工具，[DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/) 的文档中已经有了[详细的介绍](https://github.com/DefinitelyTyped/DefinitelyTyped#create-a-new-package)，这里就不赘述了，以官方文档为准。\n\n如果大家有此类需求，可以参考下笔者[提交的 pull-request](https://github.com/DefinitelyTyped/DefinitelyTyped/pull/30336/files) 。\n\n## 参考[§](/post/typescript/声明文件#参考)\n\n- [Writing Declaration Files](http://www.typescriptlang.org/docs/handbook/writing-declaration-files.html)（[中文版](https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/declaration files/Introduction.html)）\n- [Triple-Slash Directives](http://www.typescriptlang.org/docs/handbook/triple-slash-directives.html)（[中文版](https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Triple-Slash Directives.html)）\n- [typeRoots or paths](https://github.com/Microsoft/TypeScript/issues/22217#issuecomment-369783776)\n- [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/)","slug":"typescript/基础/声明文件","published":1,"date":"2023-01-10T08:29:21.761Z","updated":"2023-01-10T08:39:08.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcq06l05000sysvn5flfe7tj","content":"<h1 id=\"声明文件\"><a href=\"#声明文件\" class=\"headerlink\" title=\"声明文件\"></a>声明文件</h1><p>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</p>\n<h2 id=\"新语法索引§\"><a href=\"#新语法索引§\" class=\"headerlink\" title=\"新语法索引§\"></a>新语法索引<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E6%96%B0%E8%AF%AD%E6%B3%95%E7%B4%A2%E5%BC%95\">§</a></h2><p>由于本章涉及大量新语法，故在本章开头列出新语法的索引，方便大家在使用这些新语法时能快速查找到对应的讲解：</p>\n<ul>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-var\"><code>declare var</code></a> 声明全局变量</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-function\"><code>declare function</code></a> 声明全局方法</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-class\"><code>declare class</code></a> 声明全局类</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-enum\"><code>declare enum</code></a> 声明全局枚举类型</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-namespace\"><code>declare namespace</code></a> 声明（含有子属性的）全局对象</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#interface-%E5%92%8C-type\"><code>interface</code> 和 <code>type</code></a> 声明全局类型</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export\"><code>export</code></a> 导出变量</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-namespace\"><code>export namespace</code></a> 导出（含有子属性的）对象</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-default\"><code>export default</code></a> ES6 默认导出</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-1\"><code>export =</code></a> commonjs 导出模块</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-as-namespace\"><code>export as namespace</code></a> UMD 库声明全局变量</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-global\"><code>declare global</code></a> 扩展全局变量</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-module\"><code>declare module</code></a> 扩展模块</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#san-xie-xian-zhi-ling\"><code>/// </code></a> 三斜线指令</li>\n</ul>\n<h2 id=\"什么是声明语句§\"><a href=\"#什么是声明语句§\" class=\"headerlink\" title=\"什么是声明语句§\"></a>什么是声明语句<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A3%B0%E6%98%8E%E8%AF%AD%E5%8F%A5\">§</a></h2><p>假如我们想使用第三方库 jQuery，一种常见的方式是在 html 中通过 <code>&lt;script&gt;</code> 标签引入 jQuery，然后就可以使用全局变量 <code>$</code> 或 <code>jQuery</code> 了。</p>\n<p>我们通常这样获取一个 <code>id</code> 是 <code>foo</code> 的元素：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">$(&#39;#foo&#39;);\n&#x2F;&#x2F; or\njQuery(&#39;#foo&#39;);</code></pre>\n\n<p>但是在 ts 中，编译器并不知道 <code>$</code> 或 <code>jQuery</code> 是什么东西<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/01-jquery\">1</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">jQuery(&#39;#foo&#39;);\n&#x2F;&#x2F; ERROR: Cannot find name &#39;jQuery&#39;.</code></pre>\n\n<p>这时，我们需要使用 <code>declare var</code> 来定义它的类型<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/02-declare-var\">2</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">declare var jQuery: (selector: string) &#x3D;&gt; any;\n\njQuery(&#39;#foo&#39;);</code></pre>\n\n<p>上例中，<code>declare var</code> 并没有真的定义一个变量，只是定义了全局变量 <code>jQuery</code> 的类型，仅仅会用于编译时的检查，在编译结果中会被删除。它编译结果是：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">jQuery(&#39;#foo&#39;);</code></pre>\n\n<p>除了 <code>declare var</code> 之外，还有其他很多种声明语句，将会在后面详细介绍。</p>\n<h2 id=\"什么是声明文件§\"><a href=\"#什么是声明文件§\" class=\"headerlink\" title=\"什么是声明文件§\"></a>什么是声明文件<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">§</a></h2><p>通常我们会把声明语句放到一个单独的文件（<code>jQuery.d.ts</code>）中，这就是声明文件<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/03-jquery-d-ts\">3</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare var jQuery: (selector: string) &#x3D;&gt; any;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery(&#39;#foo&#39;);</code></pre>\n\n<p>声明文件必需以 <code>.d.ts</code> 为后缀。</p>\n<p>一般来说，ts 会解析项目中所有的 <code>*.ts</code> 文件，当然也包含以 <code>.d.ts</code> 结尾的文件。所以当我们将 <code>jQuery.d.ts</code> 放到项目中时，其他所有 <code>*.ts</code> 文件就都可以获得 <code>jQuery</code> 的类型定义了。</p>\n<pre class=\"line-numbers language-autoit\" data-language=\"autoit\"><code class=\"language-autoit\">&#x2F;path&#x2F;to&#x2F;project\n├── src\n|  ├── index.ts\n|  └── jQuery.d.ts\n└── tsconfig.json</code></pre>\n\n<p>假如仍然无法解析，那么可以检查下 <code>tsconfig.json</code> 中的 <code>files</code>、<code>include</code> 和 <code>exclude</code> 配置，确保其包含了 <code>jQuery.d.ts</code> 文件。</p>\n<p>这里只演示了全局变量这种模式的声明文件，假如是通过模块导入的方式使用第三方库的话，那么引入声明文件又是另一种方式了，将会在后面详细介绍。</p>\n<h3 id=\"第三方声明文件§\"><a href=\"#第三方声明文件§\" class=\"headerlink\" title=\"第三方声明文件§\"></a>第三方声明文件<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">§</a></h3><p>当然，jQuery 的声明文件不需要我们定义了，社区已经帮我们定义好了：<a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/jquery/index.d.ts\">jQuery in DefinitelyTyped</a>。</p>\n<p>我们可以直接下载下来使用，但是更推荐的是使用 <code>@types</code> 统一管理第三方库的声明文件。</p>\n<p><code>@types</code> 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install @types&#x2F;jquery --save-dev</code></pre>\n\n<p>可以在<a href=\"https://microsoft.github.io/TypeSearch/\">这个页面</a>搜索你需要的声明文件。</p>\n<h2 id=\"书写声明文件§\"><a href=\"#书写声明文件§\" class=\"headerlink\" title=\"书写声明文件§\"></a>书写声明文件<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E4%B9%A6%E5%86%99%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">§</a></h2><p>当一个第三方库没有提供声明文件时，我们就需要自己书写声明文件了。前面只介绍了最简单的声明文件内容，而真正书写一个声明文件并不是一件简单的事，以下会详细介绍如何书写声明文件。</p>\n<p>在不同的场景下，声明文件的内容和使用方式会有所区别。</p>\n<p>库的使用场景主要有以下几种：</p>\n<ul>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#quan-ju-bian-liang\">全局变量</a>：通过 <code>&lt;script&gt;</code> 标签引入第三方库，注入全局变量</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#npm-bao\">npm 包</a>：通过 <code>import foo from &#39;foo&#39;</code> 导入，符合 ES6 模块规范</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#umd-ku\">UMD 库</a>：既可以通过 <code>&lt;script&gt;</code> 标签引入，又可以通过 <code>import</code> 导入</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#zhi-jie-kuo-zhan-quan-ju-bian-liang\">直接扩展全局变量</a>：通过 <code>&lt;script&gt;</code> 标签引入后，改变一个全局变量的结构</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#zai-npm-bao-huo-umd-ku-zhong-kuo-zhan-quan-ju-bian-liang\">在 npm 包或 UMD 库中扩展全局变量</a>：引用 npm 包或 UMD 库后，改变一个全局变量的结构</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#mo-kuai-cha-jian\">模块插件</a>：通过 <code>&lt;script&gt;</code> 或 <code>import</code> 导入后，改变另一个模块的结构</li>\n</ul>\n<h3 id=\"全局变量§\"><a href=\"#全局变量§\" class=\"headerlink\" title=\"全局变量§\"></a>全局变量<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F\">§</a></h3><p>全局变量是最简单的一种场景，之前举的例子就是通过 <code>&lt;script&gt;</code> 标签引入 jQuery，注入全局变量 <code>$</code> 和 <code>jQuery</code>。</p>\n<p>使用全局变量的声明文件时，如果是以 <code>npm install @types/xxx --save-dev</code> 安装的，则不需要任何配置。如果是将声明文件直接存放于当前项目中，则建议和其他源码一起放到 <code>src</code> 目录下（或者对应的源码目录下）：</p>\n<pre class=\"line-numbers language-autoit\" data-language=\"autoit\"><code class=\"language-autoit\">&#x2F;path&#x2F;to&#x2F;project\n├── src\n|  ├── index.ts\n|  └── jQuery.d.ts\n└── tsconfig.json</code></pre>\n\n<p>如果没有生效，可以检查下 <code>tsconfig.json</code> 中的 <code>files</code>、<code>include</code> 和 <code>exclude</code> 配置，确保其包含了 <code>jQuery.d.ts</code> 文件。</p>\n<p>全局变量的声明文件主要有以下几种语法：</p>\n<ul>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-var\"><code>declare var</code></a> 声明全局变量</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-function\"><code>declare function</code></a> 声明全局方法</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-class\"><code>declare class</code></a> 声明全局类</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-enum\"><code>declare enum</code></a> 声明全局枚举类型</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-namespace\"><code>declare namespace</code></a> 声明（含有子属性的）全局对象</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#interface-he-type\"><code>interface</code> 和 <code>type</code></a> 声明全局类型</li>\n</ul>\n<h4 id=\"declare-var§\"><a href=\"#declare-var§\" class=\"headerlink\" title=\"declare var§\"></a><code>declare var</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-var\">§</a></h4><p>在所有的声明语句中，<code>declare var</code> 是最简单的，如之前所学，它能够用来定义一个全局变量的类型。与其类似的，还有 <code>declare let</code> 和 <code>declare const</code>，使用 <code>let</code> 与使用 <code>var</code> 没有什么区别：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare let jQuery: (selector: string) &#x3D;&gt; any;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery(&#39;#foo&#39;);\n&#x2F;&#x2F; 使用 declare let 定义的 jQuery 类型，允许修改这个全局变量\njQuery &#x3D; function(selector) &#123;\n    return document.querySelector(selector);\n&#125;;</code></pre>\n\n<p>而当我们使用 <code>const</code> 定义时，表示此时的全局变量是一个常量，不允许再去修改它的值了<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/04-declare-const-jquery\">4</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare const jQuery: (selector: string) &#x3D;&gt; any;\n\njQuery(&#39;#foo&#39;);\n&#x2F;&#x2F; 使用 declare const 定义的 jQuery 类型，禁止修改这个全局变量\njQuery &#x3D; function(selector) &#123;\n    return document.querySelector(selector);\n&#125;;\n&#x2F;&#x2F; ERROR: Cannot assign to &#39;jQuery&#39; because it is a constant or a read-only property.</code></pre>\n\n<p>一般来说，全局变量都是禁止修改的常量，所以大部分情况都应该使用 <code>const</code> 而不是 <code>var</code> 或 <code>let</code>。</p>\n<p>需要注意的是，声明语句中只能定义类型，切勿在声明语句中定义具体的实现<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/05-declare-jquery-value\">5</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">declare const jQuery &#x3D; function(selector) &#123;\n    return document.querySelector(selector);\n&#125;;\n&#x2F;&#x2F; ERROR: An implementation cannot be declared in ambient contexts.</code></pre>\n\n<h4 id=\"declare-function§\"><a href=\"#declare-function§\" class=\"headerlink\" title=\"declare function§\"></a><code>declare function</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-function\">§</a></h4><p><code>declare function</code> 用来定义全局函数的类型。jQuery 其实就是一个函数，所以也可以用 <code>function</code> 来定义：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare function jQuery(selector: string): any;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery(&#39;#foo&#39;);</code></pre>\n\n<p>在函数类型的声明语句中，函数重载也是支持的<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/06-declare-function\">6</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare function jQuery(selector: string): any;\ndeclare function jQuery(domReadyCallback: () &#x3D;&gt; any): any;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery(&#39;#foo&#39;);\njQuery(function() &#123;\n    alert(&#39;Dom Ready!&#39;);\n&#125;);</code></pre>\n\n<h4 id=\"declare-class§\"><a href=\"#declare-class§\" class=\"headerlink\" title=\"declare class§\"></a><code>declare class</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-class\">§</a></h4><p>当全局变量是一个类的时候，我们用 <code>declare class</code> 来定义它的类型<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/07-declare-class\">7</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;Animal.d.ts\n\ndeclare class Animal &#123;\n    name: string;\n    constructor(name: string);\n    sayHi(): string;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nlet cat &#x3D; new Animal(&#39;Tom&#39;);</code></pre>\n\n<p>同样的，<code>declare class</code> 语句也只能用来定义类型，不能用来定义具体的实现，比如定义 <code>sayHi</code> 方法的具体实现则会报错：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;Animal.d.ts\n\ndeclare class Animal &#123;\n    name: string;\n    constructor(name: string);\n    sayHi() &#123;\n        return &#96;My name is $&#123;this.name&#125;&#96;;\n    &#125;;\n    &#x2F;&#x2F; ERROR: An implementation cannot be declared in ambient contexts.\n&#125;</code></pre>\n\n<h4 id=\"declare-enum§\"><a href=\"#declare-enum§\" class=\"headerlink\" title=\"declare enum§\"></a><code>declare enum</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-enum\">§</a></h4><p>使用 <code>declare enum</code> 定义的枚举类型也称作外部枚举（Ambient Enums），举例如下<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/08-declare-enum\">8</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;Directions.d.ts\n\ndeclare enum Directions &#123;\n    Up,\n    Down,\n    Left,\n    Right\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nlet directions &#x3D; [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</code></pre>\n\n<p>与其他全局变量的类型声明一致，<code>declare enum</code> 仅用来定义类型，而不是具体的值。</p>\n<p><code>Directions.d.ts</code> 仅仅会用于编译时的检查，声明文件里的内容在编译结果中会被删除。它编译结果是：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var directions &#x3D; [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</code></pre>\n\n<p>其中 <code>Directions</code> 是由第三方库定义好的全局变量。</p>\n<h4 id=\"declare-namespace§\"><a href=\"#declare-namespace§\" class=\"headerlink\" title=\"declare namespace§\"></a><code>declare namespace</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-namespace\">§</a></h4><p><code>namespace</code> 是 ts 早期时为了解决模块化而创造的关键字，中文称为命名空间。</p>\n<p>由于历史遗留原因，在早期还没有 ES6 的时候，ts 提供了一种模块化方案，使用 <code>module</code> 关键字表示内部模块。但由于后来 ES6 也使用了 <code>module</code> 关键字，ts 为了兼容 ES6，使用 <code>namespace</code> 替代了自己的 <code>module</code>，更名为命名空间。</p>\n<p>随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的 <code>namespace</code>，而推荐使用 ES6 的模块化方案了，故我们不再需要学习 <code>namespace</code> 的使用了。</p>\n<p><code>namespace</code> 被淘汰了，但是在声明文件中，<code>declare namespace</code> 还是比较常用的，它用来表示全局变量是一个对象，包含很多子属性。</p>\n<p>比如 <code>jQuery</code> 是一个全局变量，它是一个对象，提供了一个 <code>jQuery.ajax</code> 方法可以调用，那么我们就应该使用 <code>declare namespace jQuery</code> 来声明这个拥有多个子属性的全局变量。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare namespace jQuery &#123;\n    function ajax(url: string, settings?: any): void;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery.ajax(&#39;&#x2F;api&#x2F;get_something&#39;);</code></pre>\n\n<p>注意，在 <code>declare namespace</code> 内部，我们直接使用 <code>function ajax</code> 来声明函数，而不是使用 <code>declare function ajax</code>。类似的，也可以使用 <code>const</code>, <code>class</code>, <code>enum</code> 等语句<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/09-declare-namespace\">9</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare namespace jQuery &#123;\n    function ajax(url: string, settings?: any): void;\n    const version: number;\n    class Event &#123;\n        blur(eventType: EventType): void\n    &#125;\n    enum EventType &#123;\n        CustomClick\n    &#125;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery.ajax(&#39;&#x2F;api&#x2F;get_something&#39;);\nconsole.log(jQuery.version);\nconst e &#x3D; new jQuery.Event();\ne.blur(jQuery.EventType.CustomClick);</code></pre>\n\n<h5 id=\"嵌套的命名空间§\"><a href=\"#嵌套的命名空间§\" class=\"headerlink\" title=\"嵌套的命名空间§\"></a>嵌套的命名空间<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E5%B5%8C%E5%A5%97%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4\">§</a></h5><p>如果对象拥有深层的层级，则需要用嵌套的 <code>namespace</code> 来声明深层的属性的类型<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/10-declare-namespace-nesting\">10</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare namespace jQuery &#123;\n    function ajax(url: string, settings?: any): void;\n    namespace fn &#123;\n        function extend(object: any): void;\n    &#125;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery.ajax(&#39;&#x2F;api&#x2F;get_something&#39;);\njQuery.fn.extend(&#123;\n    check: function() &#123;\n        return this.each(function() &#123;\n            this.checked &#x3D; true;\n        &#125;);\n    &#125;\n&#125;);</code></pre>\n\n<p>假如 <code>jQuery</code> 下仅有 <code>fn</code> 这一个属性（没有 <code>ajax</code> 等其他属性或方法），则可以不需要嵌套 <code>namespace</code><a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/11-declare-namespace-dot\">11</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare namespace jQuery.fn &#123;\n    function extend(object: any): void;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery.fn.extend(&#123;\n    check: function() &#123;\n        return this.each(function() &#123;\n            this.checked &#x3D; true;\n        &#125;);\n    &#125;\n&#125;);</code></pre>\n\n<h4 id=\"interface-和-type§\"><a href=\"#interface-和-type§\" class=\"headerlink\" title=\"interface 和 type§\"></a><code>interface</code> 和 <code>type</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#interface-%E5%92%8C-type\">§</a></h4><p>除了全局变量之外，可能有一些类型我们也希望能暴露出来。在类型声明文件中，我们可以直接使用 <code>interface</code> 或 <code>type</code> 来声明一个全局的接口或类型<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/12-interface\">12</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ninterface AjaxSettings &#123;\n    method?: &#39;GET&#39; | &#39;POST&#39;\n    data?: any;\n&#125;\ndeclare namespace jQuery &#123;\n    function ajax(url: string, settings?: AjaxSettings): void;\n&#125;</code></pre>\n\n<p>这样的话，在其他文件中也可以使用这个接口或类型了：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;index.ts\n\nlet settings: AjaxSettings &#x3D; &#123;\n    method: &#39;POST&#39;,\n    data: &#123;\n        name: &#39;foo&#39;\n    &#125;\n&#125;;\njQuery.ajax(&#39;&#x2F;api&#x2F;post_something&#39;, settings);</code></pre>\n\n<p><code>type</code> 与 <code>interface</code> 类似，不再赘述。</p>\n<h5 id=\"防止命名冲突§\"><a href=\"#防止命名冲突§\" class=\"headerlink\" title=\"防止命名冲突§\"></a>防止命名冲突<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E9%98%B2%E6%AD%A2%E5%91%BD%E5%90%8D%E5%86%B2%E7%AA%81\">§</a></h5><p>暴露在最外层的 <code>interface</code> 或 <code>type</code> 会作为全局类型作用于整个项目中，我们应该尽可能的减少全局变量或全局类型的数量。故最好将他们放到 <code>namespace</code> 下<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/13-avoid-name-conflict\">13</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare namespace jQuery &#123;\n    interface AjaxSettings &#123;\n        method?: &#39;GET&#39; | &#39;POST&#39;\n        data?: any;\n    &#125;\n    function ajax(url: string, settings?: AjaxSettings): void;\n&#125;</code></pre>\n\n<p>注意，在使用这个 <code>interface</code> 的时候，也应该加上 <code>jQuery</code> 前缀：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;index.ts\n\nlet settings: jQuery.AjaxSettings &#x3D; &#123;\n    method: &#39;POST&#39;,\n    data: &#123;\n        name: &#39;foo&#39;\n    &#125;\n&#125;;\njQuery.ajax(&#39;&#x2F;api&#x2F;post_something&#39;, settings);</code></pre>\n\n<h4 id=\"声明合并§\"><a href=\"#声明合并§\" class=\"headerlink\" title=\"声明合并§\"></a>声明合并<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E5%A3%B0%E6%98%8E%E5%90%88%E5%B9%B6\">§</a></h4><p>假如 jQuery 既是一个函数，可以直接被调用 <code>jQuery(&#39;#foo&#39;)</code>，又是一个对象，拥有子属性 <code>jQuery.ajax()</code>（事实确实如此），那么我们可以组合多个声明语句，它们会不冲突的合并起来<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/14-declaration-merging\">14</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare function jQuery(selector: string): any;\ndeclare namespace jQuery &#123;\n    function ajax(url: string, settings?: any): void;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery(&#39;#foo&#39;);\njQuery.ajax(&#39;&#x2F;api&#x2F;get_something&#39;);</code></pre>\n\n<p>关于声明合并的更多用法，可以查看<a href=\"https://ts.xcatliu.com/advanced/declaration-merging.html\">声明合并</a>章节。</p>\n<h3 id=\"npm-包§\"><a href=\"#npm-包§\" class=\"headerlink\" title=\"npm 包§\"></a>npm 包<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#npm-%E5%8C%85\">§</a></h3><p>一般我们通过 <code>import foo from &#39;foo&#39;</code> 导入一个 npm 包，这是符合 ES6 模块规范的。</p>\n<p>在我们尝试给一个 npm 包创建声明文件之前，需要先看看它的声明文件是否已经存在。一般来说，npm 包的声明文件可能存在于两个地方：</p>\n<ol>\n<li>与该 npm 包绑定在一起。判断依据是 <code>package.json</code> 中有 <code>types</code> 字段，或者有一个 <code>index.d.ts</code> 声明文件。这种模式不需要额外安装其他包，是最为推荐的，所以以后我们自己创建 npm 包的时候，最好也将声明文件与 npm 包绑定在一起。</li>\n<li>发布到 <code>@types</code> 里。我们只需要尝试安装一下对应的 <code>@types</code> 包就知道是否存在该声明文件，安装命令是 <code>npm install @types/foo --save-dev</code>。这种模式一般是由于 npm 包的维护者没有提供声明文件，所以只能由其他人将声明文件发布到 <code>@types</code> 里了。</li>\n</ol>\n<p>假如以上两种方式都没有找到对应的声明文件，那么我们就需要自己为它写声明文件了。由于是通过 <code>import</code> 语句导入的模块，所以声明文件存放的位置也有所约束，一般有两种方案：</p>\n<ol>\n<li>创建一个 <code>node_modules/@types/foo/index.d.ts</code> 文件，存放 <code>foo</code> 模块的声明文件。这种方式不需要额外的配置，但是 <code>node_modules</code> 目录不稳定，代码也没有被保存到仓库中，无法回溯版本，有不小心被删除的风险，故不太建议用这种方案，一般只用作临时测试。</li>\n<li>创建一个 <code>types</code> 目录，专门用来管理自己写的声明文件，将 <code>foo</code> 的声明文件放到 <code>types/foo/index.d.ts</code> 中。这种方式需要配置下 <code>tsconfig.json</code> 中的 <code>paths</code> 和 <code>baseUrl</code> 字段。</li>\n</ol>\n<p>目录结构：</p>\n<pre class=\"line-numbers language-autoit\" data-language=\"autoit\"><code class=\"language-autoit\">&#x2F;path&#x2F;to&#x2F;project\n├── src\n|  └── index.ts\n├── types\n|  └── foo\n|     └── index.d.ts\n└── tsconfig.json</code></pre>\n\n<p><code>tsconfig.json</code> 内容：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n    &quot;compilerOptions&quot;: &#123;\n        &quot;module&quot;: &quot;commonjs&quot;,\n        &quot;baseUrl&quot;: &quot;.&#x2F;&quot;,\n        &quot;paths&quot;: &#123;\n            &quot;*&quot;: [&quot;types&#x2F;*&quot;]\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>如此配置之后，通过 <code>import</code> 导入 <code>foo</code> 的时候，也会去 <code>types</code> 目录下寻找对应的模块的声明文件了。</p>\n<p>注意 <code>module</code> 配置可以有很多种选项，不同的选项会影响模块的导入导出模式。这里我们使用了 <code>commonjs</code> 这个最常用的选项，后面的教程也都默认使用的这个选项。</p>\n<p>不管采用了以上两种方式中的哪一种，我都<strong>强烈建议</strong>大家将书写好的声明文件（通过给第三方库发 pull request，或者直接提交到 <code>@types</code> 里）发布到开源社区中，享受了这么多社区的优秀的资源，就应该在力所能及的时候给出一些回馈。只有所有人都参与进来，才能让 ts 社区更加繁荣。</p>\n<p>npm 包的声明文件主要有以下几种语法：</p>\n<ul>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export\"><code>export</code></a> 导出变量</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-namespace\"><code>export namespace</code></a> 导出（含有子属性的）对象</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-default\"><code>export default</code></a> ES6 默认导出</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-1\"><code>export =</code></a> commonjs 导出模块</li>\n</ul>\n<h4 id=\"export§\"><a href=\"#export§\" class=\"headerlink\" title=\"export§\"></a><code>export</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export\">§</a></h4><p>npm 包的声明文件与全局变量的声明文件有很大区别。在 npm 包的声明文件中，使用 <code>declare</code> 不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。只有在声明文件中使用 <code>export</code> 导出，然后在使用方 <code>import</code> 导入后，才会应用到这些类型声明。</p>\n<p><code>export</code> 的语法与普通的 ts 中的语法类似，区别仅在于声明文件中禁止定义具体的实现<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/15-export\">15</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport const name: string;\nexport function getName(): string;\nexport class Animal &#123;\n    constructor(name: string);\n    sayHi(): string;\n&#125;\nexport enum Directions &#123;\n    Up,\n    Down,\n    Left,\n    Right\n&#125;\nexport interface Options &#123;\n    data: any;\n&#125;</code></pre>\n\n<p>对应的导入和使用模块应该是这样：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;index.ts\n\nimport &#123; name, getName, Animal, Directions, Options &#125; from &#39;foo&#39;;\n\nconsole.log(name);\nlet myName &#x3D; getName();\nlet cat &#x3D; new Animal(&#39;Tom&#39;);\nlet directions &#x3D; [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\nlet options: Options &#x3D; &#123;\n    data: &#123;\n        name: &#39;foo&#39;\n    &#125;\n&#125;;</code></pre>\n\n<h5 id=\"混用-declare-和-export§\"><a href=\"#混用-declare-和-export§\" class=\"headerlink\" title=\"混用 declare 和 export§\"></a>混用 <code>declare</code> 和 <code>export</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E6%B7%B7%E7%94%A8-declare-%E5%92%8C-export\">§</a></h5><p>我们也可以使用 <code>declare</code> 先声明多个变量，最后再用 <code>export</code> 一次性导出。上例的声明文件可以等价的改写为<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/16-declare-and-export\">16</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\ndeclare const name: string;\ndeclare function getName(): string;\ndeclare class Animal &#123;\n    constructor(name: string);\n    sayHi(): string;\n&#125;\ndeclare enum Directions &#123;\n    Up,\n    Down,\n    Left,\n    Right\n&#125;\ninterface Options &#123;\n    data: any;\n&#125;\n\nexport &#123; name, getName, Animal, Directions, Options &#125;;</code></pre>\n\n<p>注意，与全局变量的声明文件类似，<code>interface</code> 前是不需要 <code>declare</code> 的。</p>\n<h4 id=\"export-namespace§\"><a href=\"#export-namespace§\" class=\"headerlink\" title=\"export namespace§\"></a><code>export namespace</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-namespace\">§</a></h4><p>与 <code>declare namespace</code> 类似，<code>export namespace</code> 用来导出一个拥有子属性的对象<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/17-export-namespace\">17</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport namespace foo &#123;\n    const name: string;\n    namespace bar &#123;\n        function baz(): string;\n    &#125;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nimport &#123; foo &#125; from &#39;foo&#39;;\n\nconsole.log(foo.name);\nfoo.bar.baz();</code></pre>\n\n<h4 id=\"export-default§\"><a href=\"#export-default§\" class=\"headerlink\" title=\"export default§\"></a><code>export default</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-default\">§</a></h4><p>在 ES6 模块系统中，使用 <code>export default</code> 可以导出一个默认值，使用方可以用 <code>import foo from &#39;foo&#39;</code> 而不是 <code>import &#123; foo &#125; from &#39;foo&#39;</code> 来导入这个默认值。</p>\n<p>在类型声明文件中，<code>export default</code> 用来导出默认值的类型<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/18-export-default\">18</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport default function foo(): string;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nimport foo from &#39;foo&#39;;\n\nfoo();</code></pre>\n\n<p>注意，只有 <code>function</code>、<code>class</code> 和 <code>interface</code> 可以直接默认导出，其他的变量需要先定义出来，再默认导出<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/19-export-default-enum-error\">19</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport default enum Directions &#123;\n&#x2F;&#x2F; ERROR: Expression expected.\n    Up,\n    Down,\n    Left,\n    Right\n&#125;</code></pre>\n\n<p>上例中 <code>export default enum</code> 是错误的语法，需要使用 <code>declare enum</code> 定义出来，然后使用 <code>export default</code> 导出：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\ndeclare enum Directions &#123;\n    Up,\n    Down,\n    Left,\n    Right\n&#125;\n\nexport default Directions;</code></pre>\n\n<p>针对这种默认导出，我们一般会将导出语句放在整个声明文件的最前面<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/20-export-default-enum\">20</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport default Directions;\n\ndeclare enum Directions &#123;\n    Up,\n    Down,\n    Left,\n    Right\n&#125;</code></pre>\n\n<h4 id=\"export-§\"><a href=\"#export-§\" class=\"headerlink\" title=\"export =§\"></a><code>export =</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-\">§</a></h4><p>在 commonjs 规范中，我们用以下方式来导出一个模块：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 整体导出\nmodule.exports &#x3D; foo;\n&#x2F;&#x2F; 单个导出\nexports.bar &#x3D; bar;</code></pre>\n\n<p>在 ts 中，针对这种模块导出，有多种方式可以导入，第一种方式是 <code>const ... = require</code>：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 整体导入\nconst foo &#x3D; require(&#39;foo&#39;);\n&#x2F;&#x2F; 单个导入\nconst bar &#x3D; require(&#39;foo&#39;).bar;</code></pre>\n\n<p>第二种方式是 <code>import ... from</code>，注意针对整体导出，需要使用 <code>import * as</code> 来导入：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 整体导入\nimport * as foo from &#39;foo&#39;;\n&#x2F;&#x2F; 单个导入\nimport &#123; bar &#125; from &#39;foo&#39;;</code></pre>\n\n<p>第三种方式是 <code>import ... require</code>，这也是 ts 官方推荐的方式：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 整体导入\nimport foo &#x3D; require(&#39;foo&#39;);\n&#x2F;&#x2F; 单个导入\nimport bar &#x3D; foo.bar;</code></pre>\n\n<p>对于这种使用 commonjs 规范的库，假如要为它写类型声明文件的话，就需要使用到 <code>export =</code> 这种语法了<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/21-export-equal\">21</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport &#x3D; foo;\n\ndeclare function foo(): string;\ndeclare namespace foo &#123;\n    const bar: number;\n&#125;</code></pre>\n\n<p>需要注意的是，上例中使用了 <code>export =</code> 之后，就不能再单个导出 <code>export &#123; bar &#125;</code> 了。所以我们通过声明合并，使用 <code>declare namespace foo</code> 来将 <code>bar</code> 合并到 <code>foo</code> 里。</p>\n<p>准确地讲，<code>export =</code> 不仅可以用在声明文件中，也可以用在普通的 ts 文件中。实际上，<code>import ... require</code> 和 <code>export =</code> 都是 ts 为了兼容 AMD 规范和 commonjs 规范而创立的新语法，由于并不常用也不推荐使用，所以这里就不详细介绍了，感兴趣的可以看<a href=\"https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require\">官方文档</a>。</p>\n<p>由于很多第三方库是 commonjs 规范的，所以声明文件也就不得不用到 <code>export =</code> 这种语法了。但是还是需要再强调下，相比与 <code>export =</code>，我们更推荐使用 ES6 标准的 <code>export default</code> 和 <code>export</code>。</p>\n<h3 id=\"UMD-库§\"><a href=\"#UMD-库§\" class=\"headerlink\" title=\"UMD 库§\"></a>UMD 库<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#umd-%E5%BA%93\">§</a></h3><p>既可以通过 <code>&lt;script&gt;</code> 标签引入，又可以通过 <code>import</code> 导入的库，称为 UMD 库。相比于 npm 包的类型声明文件，我们需要额外声明一个全局变量，为了实现这种方式，ts 提供了一个新语法 <code>export as namespace</code>。</p>\n<h4 id=\"export-as-namespace§\"><a href=\"#export-as-namespace§\" class=\"headerlink\" title=\"export as namespace§\"></a><code>export as namespace</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-as-namespace\">§</a></h4><p>一般使用 <code>export as namespace</code> 时，都是先有了 npm 包的声明文件，再基于它添加一条 <code>export as namespace</code> 语句，即可将声明好的一个变量声明为全局变量，举例如下<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/22-export-as-namespace\">22</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport as namespace foo;\nexport &#x3D; foo;\n\ndeclare function foo(): string;\ndeclare namespace foo &#123;\n    const bar: number;\n&#125;</code></pre>\n\n<p>当然它也可以与 <code>export default</code> 一起使用：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport as namespace foo;\nexport default foo;\n\ndeclare function foo(): string;\ndeclare namespace foo &#123;\n    const bar: number;\n&#125;</code></pre>\n\n<h3 id=\"直接扩展全局变量§\"><a href=\"#直接扩展全局变量§\" class=\"headerlink\" title=\"直接扩展全局变量§\"></a>直接扩展全局变量<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E7%9B%B4%E6%8E%A5%E6%89%A9%E5%B1%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F\">§</a></h3><p>有的第三方库扩展了一个全局变量，可是此全局变量的类型却没有相应的更新过来，就会导致 ts 编译错误，此时就需要扩展全局变量的类型。比如扩展 <code>String</code> 类型<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/23-merge-global-interface\">23</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface String &#123;\n    prependHello(): string;\n&#125;\n\n&#39;foo&#39;.prependHello();</code></pre>\n\n<p>通过声明合并，使用 <code>interface String</code> 即可给 <code>String</code> 添加属性或方法。</p>\n<p>也可以使用 <code>declare namespace</code> 给已有的命名空间添加类型声明<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/24-merge-global-namespace\">24</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;jquery-plugin&#x2F;index.d.ts\n\ndeclare namespace JQuery &#123;\n    interface CustomOptions &#123;\n        bar: string;\n    &#125;\n&#125;\n\ninterface JQueryStatic &#123;\n    foo(options: JQuery.CustomOptions): string;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery.foo(&#123;\n    bar: &#39;&#39;\n&#125;);</code></pre>\n\n<h3 id=\"在-npm-包或-UMD-库中扩展全局变量§\"><a href=\"#在-npm-包或-UMD-库中扩展全局变量§\" class=\"headerlink\" title=\"在 npm 包或 UMD 库中扩展全局变量§\"></a>在 npm 包或 UMD 库中扩展全局变量<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E5%9C%A8-npm-%E5%8C%85%E6%88%96-umd-%E5%BA%93%E4%B8%AD%E6%89%A9%E5%B1%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F\">§</a></h3><p>如之前所说，对于一个 npm 包或者 UMD 库的声明文件，只有 <code>export</code> 导出的类型声明才能被导入。所以对于 npm 包或 UMD 库，如果导入此库之后会扩展全局变量，则需要使用另一种语法在声明文件中扩展全局变量的类型，那就是 <code>declare global</code>。</p>\n<h4 id=\"declare-global§\"><a href=\"#declare-global§\" class=\"headerlink\" title=\"declare global§\"></a><code>declare global</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-global\">§</a></h4><p>使用 <code>declare global</code> 可以在 npm 包或者 UMD 库的声明文件中扩展全局变量的类型<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/25-declare-global\">25</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\ndeclare global &#123;\n    interface String &#123;\n        prependHello(): string;\n    &#125;\n&#125;\n\nexport &#123;&#125;;\n&#x2F;&#x2F; src&#x2F;index.ts\n\n&#39;bar&#39;.prependHello();</code></pre>\n\n<p>注意即使此声明文件不需要导出任何东西，仍然需要导出一个空对象，用来告诉编译器这是一个模块的声明文件，而不是一个全局变量的声明文件。</p>\n<h3 id=\"模块插件§\"><a href=\"#模块插件§\" class=\"headerlink\" title=\"模块插件§\"></a>模块插件<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E6%A8%A1%E5%9D%97%E6%8F%92%E4%BB%B6\">§</a></h3><p>有时通过 <code>import</code> 导入一个模块插件，可以改变另一个原有模块的结构。此时如果原有模块已经有了类型声明文件，而插件模块没有类型声明文件，就会导致类型不完整，缺少插件部分的类型。ts 提供了一个语法 <code>declare module</code>，它可以用来扩展原有模块的类型。</p>\n<h4 id=\"declare-module§\"><a href=\"#declare-module§\" class=\"headerlink\" title=\"declare module§\"></a><code>declare module</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-module\">§</a></h4><p>如果是需要扩展原有模块的话，需要在类型声明文件中先引用原有模块，再使用 <code>declare module</code> 扩展原有模块<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/26-declare-module\">26</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;moment-plugin&#x2F;index.d.ts\n\nimport * as moment from &#39;moment&#39;;\n\ndeclare module &#39;moment&#39; &#123;\n    export function foo(): moment.CalendarKey;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nimport * as moment from &#39;moment&#39;;\nimport &#39;moment-plugin&#39;;\n\nmoment.foo();</code></pre>\n\n<p><code>declare module</code> 也可用于在一个文件中一次性声明多个模块的类型<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/27-multiple-declare-module\">27</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo-bar.d.ts\n\ndeclare module &#39;foo&#39; &#123;\n    export interface Foo &#123;\n        foo: string;\n    &#125;\n&#125;\n\ndeclare module &#39;bar&#39; &#123;\n    export function bar(): string;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nimport &#123; Foo &#125; from &#39;foo&#39;;\nimport * as bar from &#39;bar&#39;;\n\nlet f: Foo;\nbar.bar();</code></pre>\n\n<h3 id=\"声明文件中的依赖§\"><a href=\"#声明文件中的依赖§\" class=\"headerlink\" title=\"声明文件中的依赖§\"></a>声明文件中的依赖<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96\">§</a></h3><p>一个声明文件有时会依赖另一个声明文件中的类型，比如在前面的 <code>declare module</code> 的例子中，我们就在声明文件中导入了 <code>moment</code>，并且使用了 <code>moment.CalendarKey</code> 这个类型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;moment-plugin&#x2F;index.d.ts\n\nimport * as moment from &#39;moment&#39;;\n\ndeclare module &#39;moment&#39; &#123;\n    export function foo(): moment.CalendarKey;\n&#125;</code></pre>\n\n<p>除了可以在声明文件中通过 <code>import</code> 导入另一个声明文件中的类型之外，还有一个语法也可以用来导入另一个声明文件，那就是三斜线指令。</p>\n<h4 id=\"三斜线指令§\"><a href=\"#三斜线指令§\" class=\"headerlink\" title=\"三斜线指令§\"></a>三斜线指令<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E4%B8%89%E6%96%9C%E7%BA%BF%E6%8C%87%E4%BB%A4\">§</a></h4><p>与 <code>namespace</code> 类似，三斜线指令也是 ts 在早期版本中为了描述模块之间的依赖关系而创造的语法。随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的三斜线指令来声明模块之间的依赖关系了。</p>\n<p>但是在声明文件中，它还是有一定的用武之地。</p>\n<p>类似于声明文件中的 <code>import</code>，它可以用来导入另一个声明文件。与 <code>import</code> 的区别是，当且仅当在以下几个场景下，我们才需要使用三斜线指令替代 <code>import</code>：</p>\n<ul>\n<li>当我们在<strong>书写</strong>一个全局变量的声明文件时</li>\n<li>当我们需要<strong>依赖</strong>一个全局变量的声明文件时</li>\n</ul>\n<h5 id=\"书写一个全局变量的声明文件§\"><a href=\"#书写一个全局变量的声明文件§\" class=\"headerlink\" title=\"书写一个全局变量的声明文件§\"></a><strong>书写</strong>一个全局变量的声明文件<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E4%B9%A6%E5%86%99%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">§</a></h5><p>这些场景听上去很拗口，但实际上很好理解——在全局变量的声明文件中，是不允许出现 <code>import</code>, <code>export</code> 关键字的。一旦出现了，那么他就会被视为一个 npm 包或 UMD 库，就不再是全局变量的声明文件了。故当我们在书写一个全局变量的声明文件时，如果需要引用另一个库的类型，那么就必须用三斜线指令了<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/28-triple-slash-directives\">28</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;jquery-plugin&#x2F;index.d.ts\n\n&#x2F;&#x2F;&#x2F; &lt;reference types&#x3D;&quot;jquery&quot; &#x2F;&gt;\n\ndeclare function foo(options: JQuery.AjaxSettings): string;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nfoo(&#123;&#125;);</code></pre>\n\n<p>三斜线指令的语法如上，<code>///</code> 后面使用 xml 的格式添加了对 <code>jquery</code> 类型的依赖，这样就可以在声明文件中使用 <code>JQuery.AjaxSettings</code> 类型了。</p>\n<p>注意，三斜线指令必须放在文件的最顶端，三斜线指令的前面只允许出现单行或多行注释。</p>\n<h5 id=\"依赖一个全局变量的声明文件§\"><a href=\"#依赖一个全局变量的声明文件§\" class=\"headerlink\" title=\"依赖一个全局变量的声明文件§\"></a><strong>依赖</strong>一个全局变量的声明文件<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E4%BE%9D%E8%B5%96%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">§</a></h5><p>在另一个场景下，当我们需要依赖一个全局变量的声明文件时，由于全局变量不支持通过 <code>import</code> 导入，当然也就必须使用三斜线指令来引入了<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/29-triple-slash-directives-global\">29</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;node-plugin&#x2F;index.d.ts\n\n&#x2F;&#x2F;&#x2F; &lt;reference types&#x3D;&quot;node&quot; &#x2F;&gt;\n\nexport function foo(p: NodeJS.Process): string;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nimport &#123; foo &#125; from &#39;node-plugin&#39;;\n\nfoo(global.process);</code></pre>\n\n<p>在上面的例子中，我们通过三斜线指引入了 <code>node</code> 的类型，然后在声明文件中使用了 <code>NodeJS.Process</code> 这个类型。最后在使用到 <code>foo</code> 的时候，传入了 <code>node</code> 中的全局变量 <code>process</code>。</p>\n<p>由于引入的 <code>node</code> 中的类型都是全局变量的类型，它们是没有办法通过 <code>import</code> 来导入的，所以这种场景下也只能通过三斜线指令来引入了。</p>\n<p>以上两种使用场景下，都是由于需要书写或需要依赖全局变量的声明文件，所以必须使用三斜线指令。在其他的一些不是必要使用三斜线指令的情况下，就都需要使用 <code>import</code> 来导入。</p>\n<h5 id=\"拆分声明文件§\"><a href=\"#拆分声明文件§\" class=\"headerlink\" title=\"拆分声明文件§\"></a>拆分声明文件<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E6%8B%86%E5%88%86%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">§</a></h5><p>当我们的全局变量的声明文件太大时，可以通过拆分为多个文件，然后在一个入口文件中将它们一一引入，来提高代码的可维护性。比如 <code>jQuery</code> 的声明文件就是这样的：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; node_modules&#x2F;@types&#x2F;jquery&#x2F;index.d.ts\n\n&#x2F;&#x2F;&#x2F; &lt;reference types&#x3D;&quot;sizzle&quot; &#x2F;&gt;\n&#x2F;&#x2F;&#x2F; &lt;reference path&#x3D;&quot;JQueryStatic.d.ts&quot; &#x2F;&gt;\n&#x2F;&#x2F;&#x2F; &lt;reference path&#x3D;&quot;JQuery.d.ts&quot; &#x2F;&gt;\n&#x2F;&#x2F;&#x2F; &lt;reference path&#x3D;&quot;misc.d.ts&quot; &#x2F;&gt;\n&#x2F;&#x2F;&#x2F; &lt;reference path&#x3D;&quot;legacy.d.ts&quot; &#x2F;&gt;\n\nexport &#x3D; jQuery;</code></pre>\n\n<p>其中用到了 <code>types</code> 和 <code>path</code> 两种不同的指令。它们的区别是：<code>types</code> 用于声明对另一个库的依赖，而 <code>path</code> 用于声明对另一个文件的依赖。</p>\n<p>上例中，<code>sizzle</code> 是与 <code>jquery</code> 平行的另一个库，所以需要使用 <code>types=&quot;sizzle&quot;</code> 来声明对它的依赖。而其他的三斜线指令就是将 <code>jquery</code> 的声明拆分到不同的文件中了，然后在这个入口文件中使用 <code>path=&quot;foo&quot;</code> 将它们一一引入。</p>\n<h5 id=\"其他三斜线指令§\"><a href=\"#其他三斜线指令§\" class=\"headerlink\" title=\"其他三斜线指令§\"></a>其他三斜线指令<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E5%85%B6%E4%BB%96%E4%B8%89%E6%96%9C%E7%BA%BF%E6%8C%87%E4%BB%A4\">§</a></h5><p>除了这两种三斜线指令之外，还有其他的三斜线指令，比如 <code>/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</code>, <code>/// &lt;amd-module /&gt;</code> 等，但它们都是废弃的语法，故这里就不介绍了，详情可见<a href=\"http://www.typescriptlang.org/docs/handbook/triple-slash-directives.html\">官网</a>。</p>\n<h3 id=\"自动生成声明文件§\"><a href=\"#自动生成声明文件§\" class=\"headerlink\" title=\"自动生成声明文件§\"></a>自动生成声明文件<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">§</a></h3><p>如果库的源码本身就是由 ts 写的，那么在使用 <code>tsc</code> 脚本将 ts 编译为 js 的时候，添加 <code>declaration</code> 选项，就可以同时也生成 <code>.d.ts</code> 声明文件了。</p>\n<p>我们可以在命令行中添加 <code>--declaration</code>（简写 <code>-d</code>），或者在 <code>tsconfig.json</code> 中添加 <code>declaration</code> 选项。这里以 <code>tsconfig.json</code> 为例：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n    &quot;compilerOptions&quot;: &#123;\n        &quot;module&quot;: &quot;commonjs&quot;,\n        &quot;outDir&quot;: &quot;lib&quot;,\n        &quot;declaration&quot;: true,\n    &#125;\n&#125;</code></pre>\n\n<p>上例中我们添加了 <code>outDir</code> 选项，将 ts 文件的编译结果输出到 <code>lib</code> 目录下，然后添加了 <code>declaration</code> 选项，设置为 <code>true</code>，表示将会由 ts 文件自动生成 <code>.d.ts</code> 声明文件，也会输出到 <code>lib</code> 目录下。</p>\n<p>运行 <code>tsc</code> 之后，目录结构如下<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/30-auto-d-ts\">30</a>：</p>\n<pre class=\"line-numbers language-autoit\" data-language=\"autoit\"><code class=\"language-autoit\">&#x2F;path&#x2F;to&#x2F;project\n├── lib\n|  ├── bar\n|  |  ├── index.d.ts\n|  |  └── index.js\n|  ├── index.d.ts\n|  └── index.js\n├── src\n|  ├── bar\n|  |  └── index.ts\n|  └── index.ts\n├── package.json\n└── tsconfig.json</code></pre>\n\n<p>在这个例子中，<code>src</code> 目录下有两个 ts 文件，分别是 <code>src/index.ts</code> 和 <code>src/bar/index.ts</code>，它们被编译到 <code>lib</code> 目录下的同时，也会生成对应的两个声明文件 <code>lib/index.d.ts</code> 和 <code>lib/bar/index.d.ts</code>。它们的内容分别是：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;index.ts\n\nexport * from &#39;.&#x2F;bar&#39;;\n\nexport default function foo() &#123;\n    return &#39;foo&#39;;\n&#125;\n&#x2F;&#x2F; src&#x2F;bar&#x2F;index.ts\n\nexport function bar() &#123;\n    return &#39;bar&#39;;\n&#125;\n&#x2F;&#x2F; lib&#x2F;index.d.ts\n\nexport * from &#39;.&#x2F;bar&#39;;\nexport default function foo(): string;\n&#x2F;&#x2F; lib&#x2F;bar&#x2F;index.d.ts\n\nexport declare function bar(): string;</code></pre>\n\n<p>可见，自动生成的声明文件基本保持了源码的结构，而将具体实现去掉了，生成了对应的类型声明。</p>\n<p>使用 <code>tsc</code> 自动生成声明文件时，每个 ts 文件都会对应一个 <code>.d.ts</code> 声明文件。这样的好处是，使用方不仅可以在使用 <code>import foo from &#39;foo&#39;</code> 导入默认的模块时获得类型提示，还可以在使用 <code>import bar from &#39;foo/lib/bar&#39;</code> 导入一个子模块时，也获得对应的类型提示。</p>\n<p>除了 <code>declaration</code> 选项之外，还有几个选项也与自动生成声明文件有关，这里只简单列举出来，不做详细演示了：</p>\n<ul>\n<li><code>declarationDir</code> 设置生成 <code>.d.ts</code> 文件的目录</li>\n<li><code>declarationMap</code> 对每个 <code>.d.ts</code> 文件，都生成对应的 <code>.d.ts.map</code>（sourcemap）文件</li>\n<li><code>emitDeclarationOnly</code> 仅生成 <code>.d.ts</code> 文件，不生成 <code>.js</code> 文件</li>\n</ul>\n<h2 id=\"发布声明文件§\"><a href=\"#发布声明文件§\" class=\"headerlink\" title=\"发布声明文件§\"></a>发布声明文件<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E5%8F%91%E5%B8%83%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">§</a></h2><p>当我们为一个库写好了声明文件之后，下一步就是将它发布出去了。</p>\n<p>此时有两种方案：</p>\n<ol>\n<li>将声明文件和源码放在一起</li>\n<li>将声明文件发布到 <code>@types</code> 下</li>\n</ol>\n<p>这两种方案中优先选择第一种方案。保持声明文件与源码在一起，使用时就不需要额外增加单独的声明文件库的依赖了，而且也能保证声明文件的版本与源码的版本保持一致。</p>\n<p>仅当我们在给别人的仓库添加类型声明文件，但原作者不愿意合并 pull request 时，才需要使用第二种方案，将声明文件发布到 <code>@types</code> 下。</p>\n<h3 id=\"将声明文件和源码放在一起§\"><a href=\"#将声明文件和源码放在一起§\" class=\"headerlink\" title=\"将声明文件和源码放在一起§\"></a>将声明文件和源码放在一起<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E5%B0%86%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E5%92%8C%E6%BA%90%E7%A0%81%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7\">§</a></h3><p>如果声明文件是通过 <code>tsc</code> 自动生成的，那么无需做任何其他配置，只需要把编译好的文件也发布到 npm 上，使用方就可以获取到类型提示了。</p>\n<p>如果是手动写的声明文件，那么需要满足以下条件之一，才能被正确的识别：</p>\n<ul>\n<li>给 <code>package.json</code> 中的 <code>types</code> 或 <code>typings</code> 字段指定一个类型声明文件地址</li>\n<li>在项目根目录下，编写一个 <code>index.d.ts</code> 文件</li>\n<li>针对入口文件（<code>package.json</code> 中的 <code>main</code> 字段指定的入口文件），编写一个同名不同后缀的 <code>.d.ts</code> 文件</li>\n</ul>\n<p>第一种方式是给 <code>package.json</code> 中的 <code>types</code> 或 <code>typings</code> 字段指定一个类型声明文件地址。比如：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n    &quot;name&quot;: &quot;foo&quot;,\n    &quot;version&quot;: &quot;1.0.0&quot;,\n    &quot;main&quot;: &quot;lib&#x2F;index.js&quot;,\n    &quot;types&quot;: &quot;foo.d.ts&quot;,\n&#125;</code></pre>\n\n<p>指定了 <code>types</code> 为 <code>foo.d.ts</code> 之后，导入此库的时候，就会去找 <code>foo.d.ts</code> 作为此库的类型声明文件了。</p>\n<p><code>typings</code> 与 <code>types</code> 一样，只是另一种写法。</p>\n<p>如果没有指定 <code>types</code> 或 <code>typings</code>，那么就会在根目录下寻找 <code>index.d.ts</code> 文件，将它视为此库的类型声明文件。</p>\n<p>如果没有找到 <code>index.d.ts</code> 文件，那么就会寻找入口文件（<code>package.json</code> 中的 <code>main</code> 字段指定的入口文件）是否存在对应同名不同后缀的 <code>.d.ts</code> 文件。</p>\n<p>比如 <code>package.json</code> 是这样时：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n    &quot;name&quot;: &quot;foo&quot;,\n    &quot;version&quot;: &quot;1.0.0&quot;,\n    &quot;main&quot;: &quot;lib&#x2F;index.js&quot;\n&#125;</code></pre>\n\n<p>就会先识别 <code>package.json</code> 中是否存在 <code>types</code> 或 <code>typings</code> 字段。发现不存在，那么就会寻找是否存在 <code>index.d.ts</code> 文件。如果还是不存在，那么就会寻找是否存在 <code>lib/index.d.ts</code> 文件。假如说连 <code>lib/index.d.ts</code> 都不存在的话，就会被认为是一个没有提供类型声明文件的库了。</p>\n<p>有的库为了支持导入子模块，比如 <code>import bar from &#39;foo/lib/bar&#39;</code>，就需要额外再编写一个类型声明文件 <code>lib/bar.d.ts</code> 或者 <code>lib/bar/index.d.ts</code>，这与自动生成声明文件类似，一个库中同时包含了多个类型声明文件。</p>\n<h3 id=\"将声明文件发布到-types-下§\"><a href=\"#将声明文件发布到-types-下§\" class=\"headerlink\" title=\"将声明文件发布到 @types 下§\"></a>将声明文件发布到 <code>@types</code> 下<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E5%B0%86%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E5%8F%91%E5%B8%83%E5%88%B0-types-%E4%B8%8B\">§</a></h3><p>如果我们是在给别人的仓库添加类型声明文件，但原作者不愿意合并 pull request，那么就需要将声明文件发布到 <code>@types</code> 下。</p>\n<p>与普通的 npm 模块不同，<code>@types</code> 是统一由 <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/\">DefinitelyTyped</a> 管理的。要将声明文件发布到 <code>@types</code> 下，就需要给 <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/\">DefinitelyTyped</a> 创建一个 pull-request，其中包含了类型声明文件，测试代码，以及 <code>tsconfig.json</code> 等。</p>\n<p>pull-request 需要符合它们的规范，并且通过测试，才能被合并，稍后就会被自动发布到 <code>@types</code> 下。</p>\n<p>在 <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/\">DefinitelyTyped</a> 中创建一个新的类型声明，需要用到一些工具，<a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/\">DefinitelyTyped</a> 的文档中已经有了<a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped#create-a-new-package\">详细的介绍</a>，这里就不赘述了，以官方文档为准。</p>\n<p>如果大家有此类需求，可以参考下笔者<a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/pull/30336/files\">提交的 pull-request</a> 。</p>\n<h2 id=\"参考§\"><a href=\"#参考§\" class=\"headerlink\" title=\"参考§\"></a>参考<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E5%8F%82%E8%80%83\">§</a></h2><ul>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/writing-declaration-files.html\">Writing Declaration Files</a>（[中文版](<a href=\"https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/declaration\">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/declaration</a> files/Introduction.html)）</li>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/triple-slash-directives.html\">Triple-Slash Directives</a>（[中文版](<a href=\"https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Triple-Slash\">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Triple-Slash</a> Directives.html)）</li>\n<li><a href=\"https://github.com/Microsoft/TypeScript/issues/22217#issuecomment-369783776\">typeRoots or paths</a></li>\n<li><a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/\">DefinitelyTyped</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"声明文件\"><a href=\"#声明文件\" class=\"headerlink\" title=\"声明文件\"></a>声明文件</h1><p>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</p>\n<h2 id=\"新语法索引§\"><a href=\"#新语法索引§\" class=\"headerlink\" title=\"新语法索引§\"></a>新语法索引<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E6%96%B0%E8%AF%AD%E6%B3%95%E7%B4%A2%E5%BC%95\">§</a></h2><p>由于本章涉及大量新语法，故在本章开头列出新语法的索引，方便大家在使用这些新语法时能快速查找到对应的讲解：</p>\n<ul>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-var\"><code>declare var</code></a> 声明全局变量</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-function\"><code>declare function</code></a> 声明全局方法</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-class\"><code>declare class</code></a> 声明全局类</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-enum\"><code>declare enum</code></a> 声明全局枚举类型</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-namespace\"><code>declare namespace</code></a> 声明（含有子属性的）全局对象</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#interface-%E5%92%8C-type\"><code>interface</code> 和 <code>type</code></a> 声明全局类型</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export\"><code>export</code></a> 导出变量</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-namespace\"><code>export namespace</code></a> 导出（含有子属性的）对象</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-default\"><code>export default</code></a> ES6 默认导出</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-1\"><code>export =</code></a> commonjs 导出模块</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-as-namespace\"><code>export as namespace</code></a> UMD 库声明全局变量</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-global\"><code>declare global</code></a> 扩展全局变量</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-module\"><code>declare module</code></a> 扩展模块</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#san-xie-xian-zhi-ling\"><code>/// </code></a> 三斜线指令</li>\n</ul>\n<h2 id=\"什么是声明语句§\"><a href=\"#什么是声明语句§\" class=\"headerlink\" title=\"什么是声明语句§\"></a>什么是声明语句<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A3%B0%E6%98%8E%E8%AF%AD%E5%8F%A5\">§</a></h2><p>假如我们想使用第三方库 jQuery，一种常见的方式是在 html 中通过 <code>&lt;script&gt;</code> 标签引入 jQuery，然后就可以使用全局变量 <code>$</code> 或 <code>jQuery</code> 了。</p>\n<p>我们通常这样获取一个 <code>id</code> 是 <code>foo</code> 的元素：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">$(&#39;#foo&#39;);\n&#x2F;&#x2F; or\njQuery(&#39;#foo&#39;);</code></pre>\n\n<p>但是在 ts 中，编译器并不知道 <code>$</code> 或 <code>jQuery</code> 是什么东西<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/01-jquery\">1</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">jQuery(&#39;#foo&#39;);\n&#x2F;&#x2F; ERROR: Cannot find name &#39;jQuery&#39;.</code></pre>\n\n<p>这时，我们需要使用 <code>declare var</code> 来定义它的类型<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/02-declare-var\">2</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">declare var jQuery: (selector: string) &#x3D;&gt; any;\n\njQuery(&#39;#foo&#39;);</code></pre>\n\n<p>上例中，<code>declare var</code> 并没有真的定义一个变量，只是定义了全局变量 <code>jQuery</code> 的类型，仅仅会用于编译时的检查，在编译结果中会被删除。它编译结果是：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">jQuery(&#39;#foo&#39;);</code></pre>\n\n<p>除了 <code>declare var</code> 之外，还有其他很多种声明语句，将会在后面详细介绍。</p>\n<h2 id=\"什么是声明文件§\"><a href=\"#什么是声明文件§\" class=\"headerlink\" title=\"什么是声明文件§\"></a>什么是声明文件<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">§</a></h2><p>通常我们会把声明语句放到一个单独的文件（<code>jQuery.d.ts</code>）中，这就是声明文件<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/03-jquery-d-ts\">3</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare var jQuery: (selector: string) &#x3D;&gt; any;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery(&#39;#foo&#39;);</code></pre>\n\n<p>声明文件必需以 <code>.d.ts</code> 为后缀。</p>\n<p>一般来说，ts 会解析项目中所有的 <code>*.ts</code> 文件，当然也包含以 <code>.d.ts</code> 结尾的文件。所以当我们将 <code>jQuery.d.ts</code> 放到项目中时，其他所有 <code>*.ts</code> 文件就都可以获得 <code>jQuery</code> 的类型定义了。</p>\n<pre class=\"line-numbers language-autoit\" data-language=\"autoit\"><code class=\"language-autoit\">&#x2F;path&#x2F;to&#x2F;project\n├── src\n|  ├── index.ts\n|  └── jQuery.d.ts\n└── tsconfig.json</code></pre>\n\n<p>假如仍然无法解析，那么可以检查下 <code>tsconfig.json</code> 中的 <code>files</code>、<code>include</code> 和 <code>exclude</code> 配置，确保其包含了 <code>jQuery.d.ts</code> 文件。</p>\n<p>这里只演示了全局变量这种模式的声明文件，假如是通过模块导入的方式使用第三方库的话，那么引入声明文件又是另一种方式了，将会在后面详细介绍。</p>\n<h3 id=\"第三方声明文件§\"><a href=\"#第三方声明文件§\" class=\"headerlink\" title=\"第三方声明文件§\"></a>第三方声明文件<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">§</a></h3><p>当然，jQuery 的声明文件不需要我们定义了，社区已经帮我们定义好了：<a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/jquery/index.d.ts\">jQuery in DefinitelyTyped</a>。</p>\n<p>我们可以直接下载下来使用，但是更推荐的是使用 <code>@types</code> 统一管理第三方库的声明文件。</p>\n<p><code>@types</code> 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install @types&#x2F;jquery --save-dev</code></pre>\n\n<p>可以在<a href=\"https://microsoft.github.io/TypeSearch/\">这个页面</a>搜索你需要的声明文件。</p>\n<h2 id=\"书写声明文件§\"><a href=\"#书写声明文件§\" class=\"headerlink\" title=\"书写声明文件§\"></a>书写声明文件<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E4%B9%A6%E5%86%99%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">§</a></h2><p>当一个第三方库没有提供声明文件时，我们就需要自己书写声明文件了。前面只介绍了最简单的声明文件内容，而真正书写一个声明文件并不是一件简单的事，以下会详细介绍如何书写声明文件。</p>\n<p>在不同的场景下，声明文件的内容和使用方式会有所区别。</p>\n<p>库的使用场景主要有以下几种：</p>\n<ul>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#quan-ju-bian-liang\">全局变量</a>：通过 <code>&lt;script&gt;</code> 标签引入第三方库，注入全局变量</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#npm-bao\">npm 包</a>：通过 <code>import foo from &#39;foo&#39;</code> 导入，符合 ES6 模块规范</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#umd-ku\">UMD 库</a>：既可以通过 <code>&lt;script&gt;</code> 标签引入，又可以通过 <code>import</code> 导入</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#zhi-jie-kuo-zhan-quan-ju-bian-liang\">直接扩展全局变量</a>：通过 <code>&lt;script&gt;</code> 标签引入后，改变一个全局变量的结构</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#zai-npm-bao-huo-umd-ku-zhong-kuo-zhan-quan-ju-bian-liang\">在 npm 包或 UMD 库中扩展全局变量</a>：引用 npm 包或 UMD 库后，改变一个全局变量的结构</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#mo-kuai-cha-jian\">模块插件</a>：通过 <code>&lt;script&gt;</code> 或 <code>import</code> 导入后，改变另一个模块的结构</li>\n</ul>\n<h3 id=\"全局变量§\"><a href=\"#全局变量§\" class=\"headerlink\" title=\"全局变量§\"></a>全局变量<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F\">§</a></h3><p>全局变量是最简单的一种场景，之前举的例子就是通过 <code>&lt;script&gt;</code> 标签引入 jQuery，注入全局变量 <code>$</code> 和 <code>jQuery</code>。</p>\n<p>使用全局变量的声明文件时，如果是以 <code>npm install @types/xxx --save-dev</code> 安装的，则不需要任何配置。如果是将声明文件直接存放于当前项目中，则建议和其他源码一起放到 <code>src</code> 目录下（或者对应的源码目录下）：</p>\n<pre class=\"line-numbers language-autoit\" data-language=\"autoit\"><code class=\"language-autoit\">&#x2F;path&#x2F;to&#x2F;project\n├── src\n|  ├── index.ts\n|  └── jQuery.d.ts\n└── tsconfig.json</code></pre>\n\n<p>如果没有生效，可以检查下 <code>tsconfig.json</code> 中的 <code>files</code>、<code>include</code> 和 <code>exclude</code> 配置，确保其包含了 <code>jQuery.d.ts</code> 文件。</p>\n<p>全局变量的声明文件主要有以下几种语法：</p>\n<ul>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-var\"><code>declare var</code></a> 声明全局变量</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-function\"><code>declare function</code></a> 声明全局方法</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-class\"><code>declare class</code></a> 声明全局类</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-enum\"><code>declare enum</code></a> 声明全局枚举类型</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-namespace\"><code>declare namespace</code></a> 声明（含有子属性的）全局对象</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#interface-he-type\"><code>interface</code> 和 <code>type</code></a> 声明全局类型</li>\n</ul>\n<h4 id=\"declare-var§\"><a href=\"#declare-var§\" class=\"headerlink\" title=\"declare var§\"></a><code>declare var</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-var\">§</a></h4><p>在所有的声明语句中，<code>declare var</code> 是最简单的，如之前所学，它能够用来定义一个全局变量的类型。与其类似的，还有 <code>declare let</code> 和 <code>declare const</code>，使用 <code>let</code> 与使用 <code>var</code> 没有什么区别：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare let jQuery: (selector: string) &#x3D;&gt; any;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery(&#39;#foo&#39;);\n&#x2F;&#x2F; 使用 declare let 定义的 jQuery 类型，允许修改这个全局变量\njQuery &#x3D; function(selector) &#123;\n    return document.querySelector(selector);\n&#125;;</code></pre>\n\n<p>而当我们使用 <code>const</code> 定义时，表示此时的全局变量是一个常量，不允许再去修改它的值了<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/04-declare-const-jquery\">4</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare const jQuery: (selector: string) &#x3D;&gt; any;\n\njQuery(&#39;#foo&#39;);\n&#x2F;&#x2F; 使用 declare const 定义的 jQuery 类型，禁止修改这个全局变量\njQuery &#x3D; function(selector) &#123;\n    return document.querySelector(selector);\n&#125;;\n&#x2F;&#x2F; ERROR: Cannot assign to &#39;jQuery&#39; because it is a constant or a read-only property.</code></pre>\n\n<p>一般来说，全局变量都是禁止修改的常量，所以大部分情况都应该使用 <code>const</code> 而不是 <code>var</code> 或 <code>let</code>。</p>\n<p>需要注意的是，声明语句中只能定义类型，切勿在声明语句中定义具体的实现<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/05-declare-jquery-value\">5</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">declare const jQuery &#x3D; function(selector) &#123;\n    return document.querySelector(selector);\n&#125;;\n&#x2F;&#x2F; ERROR: An implementation cannot be declared in ambient contexts.</code></pre>\n\n<h4 id=\"declare-function§\"><a href=\"#declare-function§\" class=\"headerlink\" title=\"declare function§\"></a><code>declare function</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-function\">§</a></h4><p><code>declare function</code> 用来定义全局函数的类型。jQuery 其实就是一个函数，所以也可以用 <code>function</code> 来定义：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare function jQuery(selector: string): any;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery(&#39;#foo&#39;);</code></pre>\n\n<p>在函数类型的声明语句中，函数重载也是支持的<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/06-declare-function\">6</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare function jQuery(selector: string): any;\ndeclare function jQuery(domReadyCallback: () &#x3D;&gt; any): any;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery(&#39;#foo&#39;);\njQuery(function() &#123;\n    alert(&#39;Dom Ready!&#39;);\n&#125;);</code></pre>\n\n<h4 id=\"declare-class§\"><a href=\"#declare-class§\" class=\"headerlink\" title=\"declare class§\"></a><code>declare class</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-class\">§</a></h4><p>当全局变量是一个类的时候，我们用 <code>declare class</code> 来定义它的类型<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/07-declare-class\">7</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;Animal.d.ts\n\ndeclare class Animal &#123;\n    name: string;\n    constructor(name: string);\n    sayHi(): string;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nlet cat &#x3D; new Animal(&#39;Tom&#39;);</code></pre>\n\n<p>同样的，<code>declare class</code> 语句也只能用来定义类型，不能用来定义具体的实现，比如定义 <code>sayHi</code> 方法的具体实现则会报错：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;Animal.d.ts\n\ndeclare class Animal &#123;\n    name: string;\n    constructor(name: string);\n    sayHi() &#123;\n        return &#96;My name is $&#123;this.name&#125;&#96;;\n    &#125;;\n    &#x2F;&#x2F; ERROR: An implementation cannot be declared in ambient contexts.\n&#125;</code></pre>\n\n<h4 id=\"declare-enum§\"><a href=\"#declare-enum§\" class=\"headerlink\" title=\"declare enum§\"></a><code>declare enum</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-enum\">§</a></h4><p>使用 <code>declare enum</code> 定义的枚举类型也称作外部枚举（Ambient Enums），举例如下<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/08-declare-enum\">8</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;Directions.d.ts\n\ndeclare enum Directions &#123;\n    Up,\n    Down,\n    Left,\n    Right\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nlet directions &#x3D; [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</code></pre>\n\n<p>与其他全局变量的类型声明一致，<code>declare enum</code> 仅用来定义类型，而不是具体的值。</p>\n<p><code>Directions.d.ts</code> 仅仅会用于编译时的检查，声明文件里的内容在编译结果中会被删除。它编译结果是：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var directions &#x3D; [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</code></pre>\n\n<p>其中 <code>Directions</code> 是由第三方库定义好的全局变量。</p>\n<h4 id=\"declare-namespace§\"><a href=\"#declare-namespace§\" class=\"headerlink\" title=\"declare namespace§\"></a><code>declare namespace</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-namespace\">§</a></h4><p><code>namespace</code> 是 ts 早期时为了解决模块化而创造的关键字，中文称为命名空间。</p>\n<p>由于历史遗留原因，在早期还没有 ES6 的时候，ts 提供了一种模块化方案，使用 <code>module</code> 关键字表示内部模块。但由于后来 ES6 也使用了 <code>module</code> 关键字，ts 为了兼容 ES6，使用 <code>namespace</code> 替代了自己的 <code>module</code>，更名为命名空间。</p>\n<p>随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的 <code>namespace</code>，而推荐使用 ES6 的模块化方案了，故我们不再需要学习 <code>namespace</code> 的使用了。</p>\n<p><code>namespace</code> 被淘汰了，但是在声明文件中，<code>declare namespace</code> 还是比较常用的，它用来表示全局变量是一个对象，包含很多子属性。</p>\n<p>比如 <code>jQuery</code> 是一个全局变量，它是一个对象，提供了一个 <code>jQuery.ajax</code> 方法可以调用，那么我们就应该使用 <code>declare namespace jQuery</code> 来声明这个拥有多个子属性的全局变量。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare namespace jQuery &#123;\n    function ajax(url: string, settings?: any): void;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery.ajax(&#39;&#x2F;api&#x2F;get_something&#39;);</code></pre>\n\n<p>注意，在 <code>declare namespace</code> 内部，我们直接使用 <code>function ajax</code> 来声明函数，而不是使用 <code>declare function ajax</code>。类似的，也可以使用 <code>const</code>, <code>class</code>, <code>enum</code> 等语句<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/09-declare-namespace\">9</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare namespace jQuery &#123;\n    function ajax(url: string, settings?: any): void;\n    const version: number;\n    class Event &#123;\n        blur(eventType: EventType): void\n    &#125;\n    enum EventType &#123;\n        CustomClick\n    &#125;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery.ajax(&#39;&#x2F;api&#x2F;get_something&#39;);\nconsole.log(jQuery.version);\nconst e &#x3D; new jQuery.Event();\ne.blur(jQuery.EventType.CustomClick);</code></pre>\n\n<h5 id=\"嵌套的命名空间§\"><a href=\"#嵌套的命名空间§\" class=\"headerlink\" title=\"嵌套的命名空间§\"></a>嵌套的命名空间<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E5%B5%8C%E5%A5%97%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4\">§</a></h5><p>如果对象拥有深层的层级，则需要用嵌套的 <code>namespace</code> 来声明深层的属性的类型<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/10-declare-namespace-nesting\">10</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare namespace jQuery &#123;\n    function ajax(url: string, settings?: any): void;\n    namespace fn &#123;\n        function extend(object: any): void;\n    &#125;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery.ajax(&#39;&#x2F;api&#x2F;get_something&#39;);\njQuery.fn.extend(&#123;\n    check: function() &#123;\n        return this.each(function() &#123;\n            this.checked &#x3D; true;\n        &#125;);\n    &#125;\n&#125;);</code></pre>\n\n<p>假如 <code>jQuery</code> 下仅有 <code>fn</code> 这一个属性（没有 <code>ajax</code> 等其他属性或方法），则可以不需要嵌套 <code>namespace</code><a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/11-declare-namespace-dot\">11</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare namespace jQuery.fn &#123;\n    function extend(object: any): void;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery.fn.extend(&#123;\n    check: function() &#123;\n        return this.each(function() &#123;\n            this.checked &#x3D; true;\n        &#125;);\n    &#125;\n&#125;);</code></pre>\n\n<h4 id=\"interface-和-type§\"><a href=\"#interface-和-type§\" class=\"headerlink\" title=\"interface 和 type§\"></a><code>interface</code> 和 <code>type</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#interface-%E5%92%8C-type\">§</a></h4><p>除了全局变量之外，可能有一些类型我们也希望能暴露出来。在类型声明文件中，我们可以直接使用 <code>interface</code> 或 <code>type</code> 来声明一个全局的接口或类型<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/12-interface\">12</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ninterface AjaxSettings &#123;\n    method?: &#39;GET&#39; | &#39;POST&#39;\n    data?: any;\n&#125;\ndeclare namespace jQuery &#123;\n    function ajax(url: string, settings?: AjaxSettings): void;\n&#125;</code></pre>\n\n<p>这样的话，在其他文件中也可以使用这个接口或类型了：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;index.ts\n\nlet settings: AjaxSettings &#x3D; &#123;\n    method: &#39;POST&#39;,\n    data: &#123;\n        name: &#39;foo&#39;\n    &#125;\n&#125;;\njQuery.ajax(&#39;&#x2F;api&#x2F;post_something&#39;, settings);</code></pre>\n\n<p><code>type</code> 与 <code>interface</code> 类似，不再赘述。</p>\n<h5 id=\"防止命名冲突§\"><a href=\"#防止命名冲突§\" class=\"headerlink\" title=\"防止命名冲突§\"></a>防止命名冲突<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E9%98%B2%E6%AD%A2%E5%91%BD%E5%90%8D%E5%86%B2%E7%AA%81\">§</a></h5><p>暴露在最外层的 <code>interface</code> 或 <code>type</code> 会作为全局类型作用于整个项目中，我们应该尽可能的减少全局变量或全局类型的数量。故最好将他们放到 <code>namespace</code> 下<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/13-avoid-name-conflict\">13</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare namespace jQuery &#123;\n    interface AjaxSettings &#123;\n        method?: &#39;GET&#39; | &#39;POST&#39;\n        data?: any;\n    &#125;\n    function ajax(url: string, settings?: AjaxSettings): void;\n&#125;</code></pre>\n\n<p>注意，在使用这个 <code>interface</code> 的时候，也应该加上 <code>jQuery</code> 前缀：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;index.ts\n\nlet settings: jQuery.AjaxSettings &#x3D; &#123;\n    method: &#39;POST&#39;,\n    data: &#123;\n        name: &#39;foo&#39;\n    &#125;\n&#125;;\njQuery.ajax(&#39;&#x2F;api&#x2F;post_something&#39;, settings);</code></pre>\n\n<h4 id=\"声明合并§\"><a href=\"#声明合并§\" class=\"headerlink\" title=\"声明合并§\"></a>声明合并<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E5%A3%B0%E6%98%8E%E5%90%88%E5%B9%B6\">§</a></h4><p>假如 jQuery 既是一个函数，可以直接被调用 <code>jQuery(&#39;#foo&#39;)</code>，又是一个对象，拥有子属性 <code>jQuery.ajax()</code>（事实确实如此），那么我们可以组合多个声明语句，它们会不冲突的合并起来<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/14-declaration-merging\">14</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare function jQuery(selector: string): any;\ndeclare namespace jQuery &#123;\n    function ajax(url: string, settings?: any): void;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery(&#39;#foo&#39;);\njQuery.ajax(&#39;&#x2F;api&#x2F;get_something&#39;);</code></pre>\n\n<p>关于声明合并的更多用法，可以查看<a href=\"https://ts.xcatliu.com/advanced/declaration-merging.html\">声明合并</a>章节。</p>\n<h3 id=\"npm-包§\"><a href=\"#npm-包§\" class=\"headerlink\" title=\"npm 包§\"></a>npm 包<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#npm-%E5%8C%85\">§</a></h3><p>一般我们通过 <code>import foo from &#39;foo&#39;</code> 导入一个 npm 包，这是符合 ES6 模块规范的。</p>\n<p>在我们尝试给一个 npm 包创建声明文件之前，需要先看看它的声明文件是否已经存在。一般来说，npm 包的声明文件可能存在于两个地方：</p>\n<ol>\n<li>与该 npm 包绑定在一起。判断依据是 <code>package.json</code> 中有 <code>types</code> 字段，或者有一个 <code>index.d.ts</code> 声明文件。这种模式不需要额外安装其他包，是最为推荐的，所以以后我们自己创建 npm 包的时候，最好也将声明文件与 npm 包绑定在一起。</li>\n<li>发布到 <code>@types</code> 里。我们只需要尝试安装一下对应的 <code>@types</code> 包就知道是否存在该声明文件，安装命令是 <code>npm install @types/foo --save-dev</code>。这种模式一般是由于 npm 包的维护者没有提供声明文件，所以只能由其他人将声明文件发布到 <code>@types</code> 里了。</li>\n</ol>\n<p>假如以上两种方式都没有找到对应的声明文件，那么我们就需要自己为它写声明文件了。由于是通过 <code>import</code> 语句导入的模块，所以声明文件存放的位置也有所约束，一般有两种方案：</p>\n<ol>\n<li>创建一个 <code>node_modules/@types/foo/index.d.ts</code> 文件，存放 <code>foo</code> 模块的声明文件。这种方式不需要额外的配置，但是 <code>node_modules</code> 目录不稳定，代码也没有被保存到仓库中，无法回溯版本，有不小心被删除的风险，故不太建议用这种方案，一般只用作临时测试。</li>\n<li>创建一个 <code>types</code> 目录，专门用来管理自己写的声明文件，将 <code>foo</code> 的声明文件放到 <code>types/foo/index.d.ts</code> 中。这种方式需要配置下 <code>tsconfig.json</code> 中的 <code>paths</code> 和 <code>baseUrl</code> 字段。</li>\n</ol>\n<p>目录结构：</p>\n<pre class=\"line-numbers language-autoit\" data-language=\"autoit\"><code class=\"language-autoit\">&#x2F;path&#x2F;to&#x2F;project\n├── src\n|  └── index.ts\n├── types\n|  └── foo\n|     └── index.d.ts\n└── tsconfig.json</code></pre>\n\n<p><code>tsconfig.json</code> 内容：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n    &quot;compilerOptions&quot;: &#123;\n        &quot;module&quot;: &quot;commonjs&quot;,\n        &quot;baseUrl&quot;: &quot;.&#x2F;&quot;,\n        &quot;paths&quot;: &#123;\n            &quot;*&quot;: [&quot;types&#x2F;*&quot;]\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>如此配置之后，通过 <code>import</code> 导入 <code>foo</code> 的时候，也会去 <code>types</code> 目录下寻找对应的模块的声明文件了。</p>\n<p>注意 <code>module</code> 配置可以有很多种选项，不同的选项会影响模块的导入导出模式。这里我们使用了 <code>commonjs</code> 这个最常用的选项，后面的教程也都默认使用的这个选项。</p>\n<p>不管采用了以上两种方式中的哪一种，我都<strong>强烈建议</strong>大家将书写好的声明文件（通过给第三方库发 pull request，或者直接提交到 <code>@types</code> 里）发布到开源社区中，享受了这么多社区的优秀的资源，就应该在力所能及的时候给出一些回馈。只有所有人都参与进来，才能让 ts 社区更加繁荣。</p>\n<p>npm 包的声明文件主要有以下几种语法：</p>\n<ul>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export\"><code>export</code></a> 导出变量</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-namespace\"><code>export namespace</code></a> 导出（含有子属性的）对象</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-default\"><code>export default</code></a> ES6 默认导出</li>\n<li><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-1\"><code>export =</code></a> commonjs 导出模块</li>\n</ul>\n<h4 id=\"export§\"><a href=\"#export§\" class=\"headerlink\" title=\"export§\"></a><code>export</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export\">§</a></h4><p>npm 包的声明文件与全局变量的声明文件有很大区别。在 npm 包的声明文件中，使用 <code>declare</code> 不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。只有在声明文件中使用 <code>export</code> 导出，然后在使用方 <code>import</code> 导入后，才会应用到这些类型声明。</p>\n<p><code>export</code> 的语法与普通的 ts 中的语法类似，区别仅在于声明文件中禁止定义具体的实现<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/15-export\">15</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport const name: string;\nexport function getName(): string;\nexport class Animal &#123;\n    constructor(name: string);\n    sayHi(): string;\n&#125;\nexport enum Directions &#123;\n    Up,\n    Down,\n    Left,\n    Right\n&#125;\nexport interface Options &#123;\n    data: any;\n&#125;</code></pre>\n\n<p>对应的导入和使用模块应该是这样：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;index.ts\n\nimport &#123; name, getName, Animal, Directions, Options &#125; from &#39;foo&#39;;\n\nconsole.log(name);\nlet myName &#x3D; getName();\nlet cat &#x3D; new Animal(&#39;Tom&#39;);\nlet directions &#x3D; [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\nlet options: Options &#x3D; &#123;\n    data: &#123;\n        name: &#39;foo&#39;\n    &#125;\n&#125;;</code></pre>\n\n<h5 id=\"混用-declare-和-export§\"><a href=\"#混用-declare-和-export§\" class=\"headerlink\" title=\"混用 declare 和 export§\"></a>混用 <code>declare</code> 和 <code>export</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E6%B7%B7%E7%94%A8-declare-%E5%92%8C-export\">§</a></h5><p>我们也可以使用 <code>declare</code> 先声明多个变量，最后再用 <code>export</code> 一次性导出。上例的声明文件可以等价的改写为<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/16-declare-and-export\">16</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\ndeclare const name: string;\ndeclare function getName(): string;\ndeclare class Animal &#123;\n    constructor(name: string);\n    sayHi(): string;\n&#125;\ndeclare enum Directions &#123;\n    Up,\n    Down,\n    Left,\n    Right\n&#125;\ninterface Options &#123;\n    data: any;\n&#125;\n\nexport &#123; name, getName, Animal, Directions, Options &#125;;</code></pre>\n\n<p>注意，与全局变量的声明文件类似，<code>interface</code> 前是不需要 <code>declare</code> 的。</p>\n<h4 id=\"export-namespace§\"><a href=\"#export-namespace§\" class=\"headerlink\" title=\"export namespace§\"></a><code>export namespace</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-namespace\">§</a></h4><p>与 <code>declare namespace</code> 类似，<code>export namespace</code> 用来导出一个拥有子属性的对象<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/17-export-namespace\">17</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport namespace foo &#123;\n    const name: string;\n    namespace bar &#123;\n        function baz(): string;\n    &#125;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nimport &#123; foo &#125; from &#39;foo&#39;;\n\nconsole.log(foo.name);\nfoo.bar.baz();</code></pre>\n\n<h4 id=\"export-default§\"><a href=\"#export-default§\" class=\"headerlink\" title=\"export default§\"></a><code>export default</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-default\">§</a></h4><p>在 ES6 模块系统中，使用 <code>export default</code> 可以导出一个默认值，使用方可以用 <code>import foo from &#39;foo&#39;</code> 而不是 <code>import &#123; foo &#125; from &#39;foo&#39;</code> 来导入这个默认值。</p>\n<p>在类型声明文件中，<code>export default</code> 用来导出默认值的类型<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/18-export-default\">18</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport default function foo(): string;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nimport foo from &#39;foo&#39;;\n\nfoo();</code></pre>\n\n<p>注意，只有 <code>function</code>、<code>class</code> 和 <code>interface</code> 可以直接默认导出，其他的变量需要先定义出来，再默认导出<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/19-export-default-enum-error\">19</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport default enum Directions &#123;\n&#x2F;&#x2F; ERROR: Expression expected.\n    Up,\n    Down,\n    Left,\n    Right\n&#125;</code></pre>\n\n<p>上例中 <code>export default enum</code> 是错误的语法，需要使用 <code>declare enum</code> 定义出来，然后使用 <code>export default</code> 导出：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\ndeclare enum Directions &#123;\n    Up,\n    Down,\n    Left,\n    Right\n&#125;\n\nexport default Directions;</code></pre>\n\n<p>针对这种默认导出，我们一般会将导出语句放在整个声明文件的最前面<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/20-export-default-enum\">20</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport default Directions;\n\ndeclare enum Directions &#123;\n    Up,\n    Down,\n    Left,\n    Right\n&#125;</code></pre>\n\n<h4 id=\"export-§\"><a href=\"#export-§\" class=\"headerlink\" title=\"export =§\"></a><code>export =</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-\">§</a></h4><p>在 commonjs 规范中，我们用以下方式来导出一个模块：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 整体导出\nmodule.exports &#x3D; foo;\n&#x2F;&#x2F; 单个导出\nexports.bar &#x3D; bar;</code></pre>\n\n<p>在 ts 中，针对这种模块导出，有多种方式可以导入，第一种方式是 <code>const ... = require</code>：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 整体导入\nconst foo &#x3D; require(&#39;foo&#39;);\n&#x2F;&#x2F; 单个导入\nconst bar &#x3D; require(&#39;foo&#39;).bar;</code></pre>\n\n<p>第二种方式是 <code>import ... from</code>，注意针对整体导出，需要使用 <code>import * as</code> 来导入：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 整体导入\nimport * as foo from &#39;foo&#39;;\n&#x2F;&#x2F; 单个导入\nimport &#123; bar &#125; from &#39;foo&#39;;</code></pre>\n\n<p>第三种方式是 <code>import ... require</code>，这也是 ts 官方推荐的方式：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 整体导入\nimport foo &#x3D; require(&#39;foo&#39;);\n&#x2F;&#x2F; 单个导入\nimport bar &#x3D; foo.bar;</code></pre>\n\n<p>对于这种使用 commonjs 规范的库，假如要为它写类型声明文件的话，就需要使用到 <code>export =</code> 这种语法了<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/21-export-equal\">21</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport &#x3D; foo;\n\ndeclare function foo(): string;\ndeclare namespace foo &#123;\n    const bar: number;\n&#125;</code></pre>\n\n<p>需要注意的是，上例中使用了 <code>export =</code> 之后，就不能再单个导出 <code>export &#123; bar &#125;</code> 了。所以我们通过声明合并，使用 <code>declare namespace foo</code> 来将 <code>bar</code> 合并到 <code>foo</code> 里。</p>\n<p>准确地讲，<code>export =</code> 不仅可以用在声明文件中，也可以用在普通的 ts 文件中。实际上，<code>import ... require</code> 和 <code>export =</code> 都是 ts 为了兼容 AMD 规范和 commonjs 规范而创立的新语法，由于并不常用也不推荐使用，所以这里就不详细介绍了，感兴趣的可以看<a href=\"https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require\">官方文档</a>。</p>\n<p>由于很多第三方库是 commonjs 规范的，所以声明文件也就不得不用到 <code>export =</code> 这种语法了。但是还是需要再强调下，相比与 <code>export =</code>，我们更推荐使用 ES6 标准的 <code>export default</code> 和 <code>export</code>。</p>\n<h3 id=\"UMD-库§\"><a href=\"#UMD-库§\" class=\"headerlink\" title=\"UMD 库§\"></a>UMD 库<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#umd-%E5%BA%93\">§</a></h3><p>既可以通过 <code>&lt;script&gt;</code> 标签引入，又可以通过 <code>import</code> 导入的库，称为 UMD 库。相比于 npm 包的类型声明文件，我们需要额外声明一个全局变量，为了实现这种方式，ts 提供了一个新语法 <code>export as namespace</code>。</p>\n<h4 id=\"export-as-namespace§\"><a href=\"#export-as-namespace§\" class=\"headerlink\" title=\"export as namespace§\"></a><code>export as namespace</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#export-as-namespace\">§</a></h4><p>一般使用 <code>export as namespace</code> 时，都是先有了 npm 包的声明文件，再基于它添加一条 <code>export as namespace</code> 语句，即可将声明好的一个变量声明为全局变量，举例如下<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/22-export-as-namespace\">22</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport as namespace foo;\nexport &#x3D; foo;\n\ndeclare function foo(): string;\ndeclare namespace foo &#123;\n    const bar: number;\n&#125;</code></pre>\n\n<p>当然它也可以与 <code>export default</code> 一起使用：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport as namespace foo;\nexport default foo;\n\ndeclare function foo(): string;\ndeclare namespace foo &#123;\n    const bar: number;\n&#125;</code></pre>\n\n<h3 id=\"直接扩展全局变量§\"><a href=\"#直接扩展全局变量§\" class=\"headerlink\" title=\"直接扩展全局变量§\"></a>直接扩展全局变量<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E7%9B%B4%E6%8E%A5%E6%89%A9%E5%B1%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F\">§</a></h3><p>有的第三方库扩展了一个全局变量，可是此全局变量的类型却没有相应的更新过来，就会导致 ts 编译错误，此时就需要扩展全局变量的类型。比如扩展 <code>String</code> 类型<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/23-merge-global-interface\">23</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface String &#123;\n    prependHello(): string;\n&#125;\n\n&#39;foo&#39;.prependHello();</code></pre>\n\n<p>通过声明合并，使用 <code>interface String</code> 即可给 <code>String</code> 添加属性或方法。</p>\n<p>也可以使用 <code>declare namespace</code> 给已有的命名空间添加类型声明<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/24-merge-global-namespace\">24</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;jquery-plugin&#x2F;index.d.ts\n\ndeclare namespace JQuery &#123;\n    interface CustomOptions &#123;\n        bar: string;\n    &#125;\n&#125;\n\ninterface JQueryStatic &#123;\n    foo(options: JQuery.CustomOptions): string;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery.foo(&#123;\n    bar: &#39;&#39;\n&#125;);</code></pre>\n\n<h3 id=\"在-npm-包或-UMD-库中扩展全局变量§\"><a href=\"#在-npm-包或-UMD-库中扩展全局变量§\" class=\"headerlink\" title=\"在 npm 包或 UMD 库中扩展全局变量§\"></a>在 npm 包或 UMD 库中扩展全局变量<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E5%9C%A8-npm-%E5%8C%85%E6%88%96-umd-%E5%BA%93%E4%B8%AD%E6%89%A9%E5%B1%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F\">§</a></h3><p>如之前所说，对于一个 npm 包或者 UMD 库的声明文件，只有 <code>export</code> 导出的类型声明才能被导入。所以对于 npm 包或 UMD 库，如果导入此库之后会扩展全局变量，则需要使用另一种语法在声明文件中扩展全局变量的类型，那就是 <code>declare global</code>。</p>\n<h4 id=\"declare-global§\"><a href=\"#declare-global§\" class=\"headerlink\" title=\"declare global§\"></a><code>declare global</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-global\">§</a></h4><p>使用 <code>declare global</code> 可以在 npm 包或者 UMD 库的声明文件中扩展全局变量的类型<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/25-declare-global\">25</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\ndeclare global &#123;\n    interface String &#123;\n        prependHello(): string;\n    &#125;\n&#125;\n\nexport &#123;&#125;;\n&#x2F;&#x2F; src&#x2F;index.ts\n\n&#39;bar&#39;.prependHello();</code></pre>\n\n<p>注意即使此声明文件不需要导出任何东西，仍然需要导出一个空对象，用来告诉编译器这是一个模块的声明文件，而不是一个全局变量的声明文件。</p>\n<h3 id=\"模块插件§\"><a href=\"#模块插件§\" class=\"headerlink\" title=\"模块插件§\"></a>模块插件<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E6%A8%A1%E5%9D%97%E6%8F%92%E4%BB%B6\">§</a></h3><p>有时通过 <code>import</code> 导入一个模块插件，可以改变另一个原有模块的结构。此时如果原有模块已经有了类型声明文件，而插件模块没有类型声明文件，就会导致类型不完整，缺少插件部分的类型。ts 提供了一个语法 <code>declare module</code>，它可以用来扩展原有模块的类型。</p>\n<h4 id=\"declare-module§\"><a href=\"#declare-module§\" class=\"headerlink\" title=\"declare module§\"></a><code>declare module</code><a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#declare-module\">§</a></h4><p>如果是需要扩展原有模块的话，需要在类型声明文件中先引用原有模块，再使用 <code>declare module</code> 扩展原有模块<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/26-declare-module\">26</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;moment-plugin&#x2F;index.d.ts\n\nimport * as moment from &#39;moment&#39;;\n\ndeclare module &#39;moment&#39; &#123;\n    export function foo(): moment.CalendarKey;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nimport * as moment from &#39;moment&#39;;\nimport &#39;moment-plugin&#39;;\n\nmoment.foo();</code></pre>\n\n<p><code>declare module</code> 也可用于在一个文件中一次性声明多个模块的类型<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/27-multiple-declare-module\">27</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;foo-bar.d.ts\n\ndeclare module &#39;foo&#39; &#123;\n    export interface Foo &#123;\n        foo: string;\n    &#125;\n&#125;\n\ndeclare module &#39;bar&#39; &#123;\n    export function bar(): string;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nimport &#123; Foo &#125; from &#39;foo&#39;;\nimport * as bar from &#39;bar&#39;;\n\nlet f: Foo;\nbar.bar();</code></pre>\n\n<h3 id=\"声明文件中的依赖§\"><a href=\"#声明文件中的依赖§\" class=\"headerlink\" title=\"声明文件中的依赖§\"></a>声明文件中的依赖<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96\">§</a></h3><p>一个声明文件有时会依赖另一个声明文件中的类型，比如在前面的 <code>declare module</code> 的例子中，我们就在声明文件中导入了 <code>moment</code>，并且使用了 <code>moment.CalendarKey</code> 这个类型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;moment-plugin&#x2F;index.d.ts\n\nimport * as moment from &#39;moment&#39;;\n\ndeclare module &#39;moment&#39; &#123;\n    export function foo(): moment.CalendarKey;\n&#125;</code></pre>\n\n<p>除了可以在声明文件中通过 <code>import</code> 导入另一个声明文件中的类型之外，还有一个语法也可以用来导入另一个声明文件，那就是三斜线指令。</p>\n<h4 id=\"三斜线指令§\"><a href=\"#三斜线指令§\" class=\"headerlink\" title=\"三斜线指令§\"></a>三斜线指令<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E4%B8%89%E6%96%9C%E7%BA%BF%E6%8C%87%E4%BB%A4\">§</a></h4><p>与 <code>namespace</code> 类似，三斜线指令也是 ts 在早期版本中为了描述模块之间的依赖关系而创造的语法。随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的三斜线指令来声明模块之间的依赖关系了。</p>\n<p>但是在声明文件中，它还是有一定的用武之地。</p>\n<p>类似于声明文件中的 <code>import</code>，它可以用来导入另一个声明文件。与 <code>import</code> 的区别是，当且仅当在以下几个场景下，我们才需要使用三斜线指令替代 <code>import</code>：</p>\n<ul>\n<li>当我们在<strong>书写</strong>一个全局变量的声明文件时</li>\n<li>当我们需要<strong>依赖</strong>一个全局变量的声明文件时</li>\n</ul>\n<h5 id=\"书写一个全局变量的声明文件§\"><a href=\"#书写一个全局变量的声明文件§\" class=\"headerlink\" title=\"书写一个全局变量的声明文件§\"></a><strong>书写</strong>一个全局变量的声明文件<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E4%B9%A6%E5%86%99%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">§</a></h5><p>这些场景听上去很拗口，但实际上很好理解——在全局变量的声明文件中，是不允许出现 <code>import</code>, <code>export</code> 关键字的。一旦出现了，那么他就会被视为一个 npm 包或 UMD 库，就不再是全局变量的声明文件了。故当我们在书写一个全局变量的声明文件时，如果需要引用另一个库的类型，那么就必须用三斜线指令了<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/28-triple-slash-directives\">28</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;jquery-plugin&#x2F;index.d.ts\n\n&#x2F;&#x2F;&#x2F; &lt;reference types&#x3D;&quot;jquery&quot; &#x2F;&gt;\n\ndeclare function foo(options: JQuery.AjaxSettings): string;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nfoo(&#123;&#125;);</code></pre>\n\n<p>三斜线指令的语法如上，<code>///</code> 后面使用 xml 的格式添加了对 <code>jquery</code> 类型的依赖，这样就可以在声明文件中使用 <code>JQuery.AjaxSettings</code> 类型了。</p>\n<p>注意，三斜线指令必须放在文件的最顶端，三斜线指令的前面只允许出现单行或多行注释。</p>\n<h5 id=\"依赖一个全局变量的声明文件§\"><a href=\"#依赖一个全局变量的声明文件§\" class=\"headerlink\" title=\"依赖一个全局变量的声明文件§\"></a><strong>依赖</strong>一个全局变量的声明文件<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E4%BE%9D%E8%B5%96%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">§</a></h5><p>在另一个场景下，当我们需要依赖一个全局变量的声明文件时，由于全局变量不支持通过 <code>import</code> 导入，当然也就必须使用三斜线指令来引入了<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/29-triple-slash-directives-global\">29</a>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; types&#x2F;node-plugin&#x2F;index.d.ts\n\n&#x2F;&#x2F;&#x2F; &lt;reference types&#x3D;&quot;node&quot; &#x2F;&gt;\n\nexport function foo(p: NodeJS.Process): string;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nimport &#123; foo &#125; from &#39;node-plugin&#39;;\n\nfoo(global.process);</code></pre>\n\n<p>在上面的例子中，我们通过三斜线指引入了 <code>node</code> 的类型，然后在声明文件中使用了 <code>NodeJS.Process</code> 这个类型。最后在使用到 <code>foo</code> 的时候，传入了 <code>node</code> 中的全局变量 <code>process</code>。</p>\n<p>由于引入的 <code>node</code> 中的类型都是全局变量的类型，它们是没有办法通过 <code>import</code> 来导入的，所以这种场景下也只能通过三斜线指令来引入了。</p>\n<p>以上两种使用场景下，都是由于需要书写或需要依赖全局变量的声明文件，所以必须使用三斜线指令。在其他的一些不是必要使用三斜线指令的情况下，就都需要使用 <code>import</code> 来导入。</p>\n<h5 id=\"拆分声明文件§\"><a href=\"#拆分声明文件§\" class=\"headerlink\" title=\"拆分声明文件§\"></a>拆分声明文件<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E6%8B%86%E5%88%86%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">§</a></h5><p>当我们的全局变量的声明文件太大时，可以通过拆分为多个文件，然后在一个入口文件中将它们一一引入，来提高代码的可维护性。比如 <code>jQuery</code> 的声明文件就是这样的：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; node_modules&#x2F;@types&#x2F;jquery&#x2F;index.d.ts\n\n&#x2F;&#x2F;&#x2F; &lt;reference types&#x3D;&quot;sizzle&quot; &#x2F;&gt;\n&#x2F;&#x2F;&#x2F; &lt;reference path&#x3D;&quot;JQueryStatic.d.ts&quot; &#x2F;&gt;\n&#x2F;&#x2F;&#x2F; &lt;reference path&#x3D;&quot;JQuery.d.ts&quot; &#x2F;&gt;\n&#x2F;&#x2F;&#x2F; &lt;reference path&#x3D;&quot;misc.d.ts&quot; &#x2F;&gt;\n&#x2F;&#x2F;&#x2F; &lt;reference path&#x3D;&quot;legacy.d.ts&quot; &#x2F;&gt;\n\nexport &#x3D; jQuery;</code></pre>\n\n<p>其中用到了 <code>types</code> 和 <code>path</code> 两种不同的指令。它们的区别是：<code>types</code> 用于声明对另一个库的依赖，而 <code>path</code> 用于声明对另一个文件的依赖。</p>\n<p>上例中，<code>sizzle</code> 是与 <code>jquery</code> 平行的另一个库，所以需要使用 <code>types=&quot;sizzle&quot;</code> 来声明对它的依赖。而其他的三斜线指令就是将 <code>jquery</code> 的声明拆分到不同的文件中了，然后在这个入口文件中使用 <code>path=&quot;foo&quot;</code> 将它们一一引入。</p>\n<h5 id=\"其他三斜线指令§\"><a href=\"#其他三斜线指令§\" class=\"headerlink\" title=\"其他三斜线指令§\"></a>其他三斜线指令<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E5%85%B6%E4%BB%96%E4%B8%89%E6%96%9C%E7%BA%BF%E6%8C%87%E4%BB%A4\">§</a></h5><p>除了这两种三斜线指令之外，还有其他的三斜线指令，比如 <code>/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</code>, <code>/// &lt;amd-module /&gt;</code> 等，但它们都是废弃的语法，故这里就不介绍了，详情可见<a href=\"http://www.typescriptlang.org/docs/handbook/triple-slash-directives.html\">官网</a>。</p>\n<h3 id=\"自动生成声明文件§\"><a href=\"#自动生成声明文件§\" class=\"headerlink\" title=\"自动生成声明文件§\"></a>自动生成声明文件<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">§</a></h3><p>如果库的源码本身就是由 ts 写的，那么在使用 <code>tsc</code> 脚本将 ts 编译为 js 的时候，添加 <code>declaration</code> 选项，就可以同时也生成 <code>.d.ts</code> 声明文件了。</p>\n<p>我们可以在命令行中添加 <code>--declaration</code>（简写 <code>-d</code>），或者在 <code>tsconfig.json</code> 中添加 <code>declaration</code> 选项。这里以 <code>tsconfig.json</code> 为例：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n    &quot;compilerOptions&quot;: &#123;\n        &quot;module&quot;: &quot;commonjs&quot;,\n        &quot;outDir&quot;: &quot;lib&quot;,\n        &quot;declaration&quot;: true,\n    &#125;\n&#125;</code></pre>\n\n<p>上例中我们添加了 <code>outDir</code> 选项，将 ts 文件的编译结果输出到 <code>lib</code> 目录下，然后添加了 <code>declaration</code> 选项，设置为 <code>true</code>，表示将会由 ts 文件自动生成 <code>.d.ts</code> 声明文件，也会输出到 <code>lib</code> 目录下。</p>\n<p>运行 <code>tsc</code> 之后，目录结构如下<a href=\"https://github.com/xcatliu/typescript-tutorial/tree/master/examples/declaration-files/30-auto-d-ts\">30</a>：</p>\n<pre class=\"line-numbers language-autoit\" data-language=\"autoit\"><code class=\"language-autoit\">&#x2F;path&#x2F;to&#x2F;project\n├── lib\n|  ├── bar\n|  |  ├── index.d.ts\n|  |  └── index.js\n|  ├── index.d.ts\n|  └── index.js\n├── src\n|  ├── bar\n|  |  └── index.ts\n|  └── index.ts\n├── package.json\n└── tsconfig.json</code></pre>\n\n<p>在这个例子中，<code>src</code> 目录下有两个 ts 文件，分别是 <code>src/index.ts</code> 和 <code>src/bar/index.ts</code>，它们被编译到 <code>lib</code> 目录下的同时，也会生成对应的两个声明文件 <code>lib/index.d.ts</code> 和 <code>lib/bar/index.d.ts</code>。它们的内容分别是：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; src&#x2F;index.ts\n\nexport * from &#39;.&#x2F;bar&#39;;\n\nexport default function foo() &#123;\n    return &#39;foo&#39;;\n&#125;\n&#x2F;&#x2F; src&#x2F;bar&#x2F;index.ts\n\nexport function bar() &#123;\n    return &#39;bar&#39;;\n&#125;\n&#x2F;&#x2F; lib&#x2F;index.d.ts\n\nexport * from &#39;.&#x2F;bar&#39;;\nexport default function foo(): string;\n&#x2F;&#x2F; lib&#x2F;bar&#x2F;index.d.ts\n\nexport declare function bar(): string;</code></pre>\n\n<p>可见，自动生成的声明文件基本保持了源码的结构，而将具体实现去掉了，生成了对应的类型声明。</p>\n<p>使用 <code>tsc</code> 自动生成声明文件时，每个 ts 文件都会对应一个 <code>.d.ts</code> 声明文件。这样的好处是，使用方不仅可以在使用 <code>import foo from &#39;foo&#39;</code> 导入默认的模块时获得类型提示，还可以在使用 <code>import bar from &#39;foo/lib/bar&#39;</code> 导入一个子模块时，也获得对应的类型提示。</p>\n<p>除了 <code>declaration</code> 选项之外，还有几个选项也与自动生成声明文件有关，这里只简单列举出来，不做详细演示了：</p>\n<ul>\n<li><code>declarationDir</code> 设置生成 <code>.d.ts</code> 文件的目录</li>\n<li><code>declarationMap</code> 对每个 <code>.d.ts</code> 文件，都生成对应的 <code>.d.ts.map</code>（sourcemap）文件</li>\n<li><code>emitDeclarationOnly</code> 仅生成 <code>.d.ts</code> 文件，不生成 <code>.js</code> 文件</li>\n</ul>\n<h2 id=\"发布声明文件§\"><a href=\"#发布声明文件§\" class=\"headerlink\" title=\"发布声明文件§\"></a>发布声明文件<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E5%8F%91%E5%B8%83%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">§</a></h2><p>当我们为一个库写好了声明文件之后，下一步就是将它发布出去了。</p>\n<p>此时有两种方案：</p>\n<ol>\n<li>将声明文件和源码放在一起</li>\n<li>将声明文件发布到 <code>@types</code> 下</li>\n</ol>\n<p>这两种方案中优先选择第一种方案。保持声明文件与源码在一起，使用时就不需要额外增加单独的声明文件库的依赖了，而且也能保证声明文件的版本与源码的版本保持一致。</p>\n<p>仅当我们在给别人的仓库添加类型声明文件，但原作者不愿意合并 pull request 时，才需要使用第二种方案，将声明文件发布到 <code>@types</code> 下。</p>\n<h3 id=\"将声明文件和源码放在一起§\"><a href=\"#将声明文件和源码放在一起§\" class=\"headerlink\" title=\"将声明文件和源码放在一起§\"></a>将声明文件和源码放在一起<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E5%B0%86%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E5%92%8C%E6%BA%90%E7%A0%81%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7\">§</a></h3><p>如果声明文件是通过 <code>tsc</code> 自动生成的，那么无需做任何其他配置，只需要把编译好的文件也发布到 npm 上，使用方就可以获取到类型提示了。</p>\n<p>如果是手动写的声明文件，那么需要满足以下条件之一，才能被正确的识别：</p>\n<ul>\n<li>给 <code>package.json</code> 中的 <code>types</code> 或 <code>typings</code> 字段指定一个类型声明文件地址</li>\n<li>在项目根目录下，编写一个 <code>index.d.ts</code> 文件</li>\n<li>针对入口文件（<code>package.json</code> 中的 <code>main</code> 字段指定的入口文件），编写一个同名不同后缀的 <code>.d.ts</code> 文件</li>\n</ul>\n<p>第一种方式是给 <code>package.json</code> 中的 <code>types</code> 或 <code>typings</code> 字段指定一个类型声明文件地址。比如：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n    &quot;name&quot;: &quot;foo&quot;,\n    &quot;version&quot;: &quot;1.0.0&quot;,\n    &quot;main&quot;: &quot;lib&#x2F;index.js&quot;,\n    &quot;types&quot;: &quot;foo.d.ts&quot;,\n&#125;</code></pre>\n\n<p>指定了 <code>types</code> 为 <code>foo.d.ts</code> 之后，导入此库的时候，就会去找 <code>foo.d.ts</code> 作为此库的类型声明文件了。</p>\n<p><code>typings</code> 与 <code>types</code> 一样，只是另一种写法。</p>\n<p>如果没有指定 <code>types</code> 或 <code>typings</code>，那么就会在根目录下寻找 <code>index.d.ts</code> 文件，将它视为此库的类型声明文件。</p>\n<p>如果没有找到 <code>index.d.ts</code> 文件，那么就会寻找入口文件（<code>package.json</code> 中的 <code>main</code> 字段指定的入口文件）是否存在对应同名不同后缀的 <code>.d.ts</code> 文件。</p>\n<p>比如 <code>package.json</code> 是这样时：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n    &quot;name&quot;: &quot;foo&quot;,\n    &quot;version&quot;: &quot;1.0.0&quot;,\n    &quot;main&quot;: &quot;lib&#x2F;index.js&quot;\n&#125;</code></pre>\n\n<p>就会先识别 <code>package.json</code> 中是否存在 <code>types</code> 或 <code>typings</code> 字段。发现不存在，那么就会寻找是否存在 <code>index.d.ts</code> 文件。如果还是不存在，那么就会寻找是否存在 <code>lib/index.d.ts</code> 文件。假如说连 <code>lib/index.d.ts</code> 都不存在的话，就会被认为是一个没有提供类型声明文件的库了。</p>\n<p>有的库为了支持导入子模块，比如 <code>import bar from &#39;foo/lib/bar&#39;</code>，就需要额外再编写一个类型声明文件 <code>lib/bar.d.ts</code> 或者 <code>lib/bar/index.d.ts</code>，这与自动生成声明文件类似，一个库中同时包含了多个类型声明文件。</p>\n<h3 id=\"将声明文件发布到-types-下§\"><a href=\"#将声明文件发布到-types-下§\" class=\"headerlink\" title=\"将声明文件发布到 @types 下§\"></a>将声明文件发布到 <code>@types</code> 下<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E5%B0%86%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6%E5%8F%91%E5%B8%83%E5%88%B0-types-%E4%B8%8B\">§</a></h3><p>如果我们是在给别人的仓库添加类型声明文件，但原作者不愿意合并 pull request，那么就需要将声明文件发布到 <code>@types</code> 下。</p>\n<p>与普通的 npm 模块不同，<code>@types</code> 是统一由 <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/\">DefinitelyTyped</a> 管理的。要将声明文件发布到 <code>@types</code> 下，就需要给 <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/\">DefinitelyTyped</a> 创建一个 pull-request，其中包含了类型声明文件，测试代码，以及 <code>tsconfig.json</code> 等。</p>\n<p>pull-request 需要符合它们的规范，并且通过测试，才能被合并，稍后就会被自动发布到 <code>@types</code> 下。</p>\n<p>在 <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/\">DefinitelyTyped</a> 中创建一个新的类型声明，需要用到一些工具，<a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/\">DefinitelyTyped</a> 的文档中已经有了<a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped#create-a-new-package\">详细的介绍</a>，这里就不赘述了，以官方文档为准。</p>\n<p>如果大家有此类需求，可以参考下笔者<a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/pull/30336/files\">提交的 pull-request</a> 。</p>\n<h2 id=\"参考§\"><a href=\"#参考§\" class=\"headerlink\" title=\"参考§\"></a>参考<a href=\"/post/typescript/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6#%E5%8F%82%E8%80%83\">§</a></h2><ul>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/writing-declaration-files.html\">Writing Declaration Files</a>（[中文版](<a href=\"https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/declaration\">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/declaration</a> files/Introduction.html)）</li>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/triple-slash-directives.html\">Triple-Slash Directives</a>（[中文版](<a href=\"https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Triple-Slash\">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Triple-Slash</a> Directives.html)）</li>\n<li><a href=\"https://github.com/Microsoft/TypeScript/issues/22217#issuecomment-369783776\">typeRoots or paths</a></li>\n<li><a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/\">DefinitelyTyped</a></li>\n</ul>\n"},{"title":"基础 - 对象的类型——接口","cover":"https://whitelabelcoders.com/app/uploads/18.jpg","_content":"\n# 对象的类型——接口\n\n在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。\n\n## 什么是接口\n\n在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。\n\nTypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。\n\n## 简单的例子\n\n```TypeScript\ninterface Person {\n    name: string;\n    age: number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25\n};\n```\n\n上面的例子中，我们定义了一个接口 `Person`，接着定义了一个变量 `tom`，它的类型是 `Person`。这样，我们就约束了 `tom` 的形状必须和接口 `Person` 一致。\n\n接口一般首字母大写。[有的编程语言中会建议接口的名称加上 I 前缀](https://msdn.microsoft.com/en-us/library/8bc1fexb%28v=vs.71%29.aspx)。\n\n定义的变量比接口少了一些属性是不允许的：\n\n```TypeScript\ninterface Person {\n    name: string;\n    age: number;\n}\n\nlet tom: Person = {\n    name: 'Tom'\n};\n\n// index.ts(6,5): error TS2322: Type '{ name: string; }' is not assignable to type 'Person'.\n//   Property 'age' is missing in type '{ name: string; }'.\n```\n\n多一些属性也是不允许的：\n\n```TypeScript\ninterface Person {\n    name: string;\n    age: number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n\n// index.ts(9,5): error TS2322: Type '{ name: string; age: number; gender: string; }' is not assignable to type 'Person'.\n//   Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.\n```\n\n可见，**赋值的时候，变量的形状必须和接口的形状保持一致**。\n\n## 可选属性\n\n有时我们希望不要完全匹配一个形状，那么可以用可选属性：\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n}\n\nlet tom: Person = {\n    name: 'Tom'\n};\n```\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25\n};\n```\n\n可选属性的含义是该属性可以不存在。\n\n这时**仍然不允许添加未定义的属性：**\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n\n// examples/playground/index.ts(9,5): error TS2322: Type '{ name: string; age: number; gender: string; }' is not assignable to type 'Person'.\n//   Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.\n```\n\n## 任意属性\n\n有时候我们希望一个接口允许有任意的属性，可以使用如下方式：\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    gender: 'male'\n};\n```\n\n使用 `[propName: string]` 定义了任意属性取 `string` 类型的值。\n\n需要注意的是，**一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的同类型或者子集：**\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: string;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n\n// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.\n// index.ts(7,5): error TS2322: Type '{ [x: string]: string | number; name: string; age: number; gender: string; }' is not assignable to type 'Person'.\n//   Index signatures are incompatible.\n//     Type 'string | number' is not assignable to type 'string'.\n//       Type 'number' is not assignable to type 'string'.\n```\n\n上例中，任意属性的值允许是 `string`，但是可选属性 `age` 的值却是 `number`，`number` 不是 `string` 的子属性，所以报错了。\n\n另外，在报错信息中可以看出，此时 `{ name: 'Tom', age: 25, gender: 'male' }` 的类型被推断成了 `{ [x: string]: string | number; name: string; age: number; gender: string; }`，这是联合类型和接口的结合。\n\n一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: string | number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n```\n\n## 只读属性\n\n有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 `readonly` 定义只读属性：\n\n```TypeScript\ninterface Person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    id: 89757,\n    name: 'Tom',\n    gender: 'male'\n};\n\ntom.id = 9527;\n\n// index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.\n```\n\n上例中，使用 `readonly` 定义的属性 `id` 初始化后，又被赋值了，所以报错了。\n\n**注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：**\n\n```TypeScript\ninterface Person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    gender: 'male'\n};\n\ntom.id = 89757;\n\n// index.ts(8,5): error TS2322: Type '{ name: string; gender: string; }' is not assignable to type 'Person'.\n//   Property 'id' is missing in type '{ name: string; gender: string; }'.\n// index.ts(13,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.\n```\n\n上例中，报错信息有两处，第一处是在对 `tom` 进行赋值的时候，没有给 `id` 赋值。\n\n第二处是在给 `tom.id` 赋值的时候，由于它是只读属性，所以报错了。\n\n## 参考\n\n- [Interfaces](http://www.typescriptlang.org/docs/handbook/interfaces.html)","source":"_posts/typescript/基础/对象的类型——接口.md","raw":"---\ntitle: 基础 - 对象的类型——接口\ncover: https://whitelabelcoders.com/app/uploads/18.jpg\ncategories:\n  - TypeScript入门\ntags:\n  - TypeScript\n  - 类型\n---\n\n# 对象的类型——接口\n\n在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。\n\n## 什么是接口\n\n在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。\n\nTypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。\n\n## 简单的例子\n\n```TypeScript\ninterface Person {\n    name: string;\n    age: number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25\n};\n```\n\n上面的例子中，我们定义了一个接口 `Person`，接着定义了一个变量 `tom`，它的类型是 `Person`。这样，我们就约束了 `tom` 的形状必须和接口 `Person` 一致。\n\n接口一般首字母大写。[有的编程语言中会建议接口的名称加上 I 前缀](https://msdn.microsoft.com/en-us/library/8bc1fexb%28v=vs.71%29.aspx)。\n\n定义的变量比接口少了一些属性是不允许的：\n\n```TypeScript\ninterface Person {\n    name: string;\n    age: number;\n}\n\nlet tom: Person = {\n    name: 'Tom'\n};\n\n// index.ts(6,5): error TS2322: Type '{ name: string; }' is not assignable to type 'Person'.\n//   Property 'age' is missing in type '{ name: string; }'.\n```\n\n多一些属性也是不允许的：\n\n```TypeScript\ninterface Person {\n    name: string;\n    age: number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n\n// index.ts(9,5): error TS2322: Type '{ name: string; age: number; gender: string; }' is not assignable to type 'Person'.\n//   Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.\n```\n\n可见，**赋值的时候，变量的形状必须和接口的形状保持一致**。\n\n## 可选属性\n\n有时我们希望不要完全匹配一个形状，那么可以用可选属性：\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n}\n\nlet tom: Person = {\n    name: 'Tom'\n};\n```\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25\n};\n```\n\n可选属性的含义是该属性可以不存在。\n\n这时**仍然不允许添加未定义的属性：**\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n\n// examples/playground/index.ts(9,5): error TS2322: Type '{ name: string; age: number; gender: string; }' is not assignable to type 'Person'.\n//   Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.\n```\n\n## 任意属性\n\n有时候我们希望一个接口允许有任意的属性，可以使用如下方式：\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    gender: 'male'\n};\n```\n\n使用 `[propName: string]` 定义了任意属性取 `string` 类型的值。\n\n需要注意的是，**一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的同类型或者子集：**\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: string;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n\n// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.\n// index.ts(7,5): error TS2322: Type '{ [x: string]: string | number; name: string; age: number; gender: string; }' is not assignable to type 'Person'.\n//   Index signatures are incompatible.\n//     Type 'string | number' is not assignable to type 'string'.\n//       Type 'number' is not assignable to type 'string'.\n```\n\n上例中，任意属性的值允许是 `string`，但是可选属性 `age` 的值却是 `number`，`number` 不是 `string` 的子属性，所以报错了。\n\n另外，在报错信息中可以看出，此时 `{ name: 'Tom', age: 25, gender: 'male' }` 的类型被推断成了 `{ [x: string]: string | number; name: string; age: number; gender: string; }`，这是联合类型和接口的结合。\n\n一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: string | number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n```\n\n## 只读属性\n\n有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 `readonly` 定义只读属性：\n\n```TypeScript\ninterface Person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    id: 89757,\n    name: 'Tom',\n    gender: 'male'\n};\n\ntom.id = 9527;\n\n// index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.\n```\n\n上例中，使用 `readonly` 定义的属性 `id` 初始化后，又被赋值了，所以报错了。\n\n**注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：**\n\n```TypeScript\ninterface Person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    gender: 'male'\n};\n\ntom.id = 89757;\n\n// index.ts(8,5): error TS2322: Type '{ name: string; gender: string; }' is not assignable to type 'Person'.\n//   Property 'id' is missing in type '{ name: string; gender: string; }'.\n// index.ts(13,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.\n```\n\n上例中，报错信息有两处，第一处是在对 `tom` 进行赋值的时候，没有给 `id` 赋值。\n\n第二处是在给 `tom.id` 赋值的时候，由于它是只读属性，所以报错了。\n\n## 参考\n\n- [Interfaces](http://www.typescriptlang.org/docs/handbook/interfaces.html)","slug":"typescript/基础/对象的类型——接口","published":1,"date":"2023-01-05T08:16:54.245Z","updated":"2023-01-06T06:35:45.981Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcq06l07000vysvnhd9h6svl","content":"<h1 id=\"对象的类型——接口\"><a href=\"#对象的类型——接口\" class=\"headerlink\" title=\"对象的类型——接口\"></a>对象的类型——接口</h1><p>在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。</p>\n<h2 id=\"什么是接口\"><a href=\"#什么是接口\" class=\"headerlink\" title=\"什么是接口\"></a>什么是接口</h2><p>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。</p>\n<p>TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。</p>\n<h2 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h2><pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25\n&#125;;</code></pre>\n\n<p>上面的例子中，我们定义了一个接口 <code>Person</code>，接着定义了一个变量 <code>tom</code>，它的类型是 <code>Person</code>。这样，我们就约束了 <code>tom</code> 的形状必须和接口 <code>Person</code> 一致。</p>\n<p>接口一般首字母大写。<a href=\"https://msdn.microsoft.com/en-us/library/8bc1fexb%28v=vs.71%29.aspx\">有的编程语言中会建议接口的名称加上 I 前缀</a>。</p>\n<p>定义的变量比接口少了一些属性是不允许的：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;\n&#125;;\n\n&#x2F;&#x2F; index.ts(6,5): error TS2322: Type &#39;&#123; name: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Property &#39;age&#39; is missing in type &#39;&#123; name: string; &#125;&#39;.</code></pre>\n\n<p>多一些属性也是不允许的：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n&#x2F;&#x2F; index.ts(9,5): error TS2322: Type &#39;&#123; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Object literal may only specify known properties, and &#39;gender&#39; does not exist in type &#39;Person&#39;.</code></pre>\n\n<p>可见，<strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong>。</p>\n<h2 id=\"可选属性\"><a href=\"#可选属性\" class=\"headerlink\" title=\"可选属性\"></a>可选属性</h2><p>有时我们希望不要完全匹配一个形状，那么可以用可选属性：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;\n&#125;;</code></pre>\n\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25\n&#125;;</code></pre>\n\n<p>可选属性的含义是该属性可以不存在。</p>\n<p>这时<strong>仍然不允许添加未定义的属性：</strong></p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n&#x2F;&#x2F; examples&#x2F;playground&#x2F;index.ts(9,5): error TS2322: Type &#39;&#123; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Object literal may only specify known properties, and &#39;gender&#39; does not exist in type &#39;Person&#39;.</code></pre>\n\n<h2 id=\"任意属性\"><a href=\"#任意属性\" class=\"headerlink\" title=\"任意属性\"></a>任意属性</h2><p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;</code></pre>\n\n<p>使用 <code>[propName: string]</code> 定义了任意属性取 <code>string</code> 类型的值。</p>\n<p>需要注意的是，<strong>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的同类型或者子集：</strong></p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n    [propName: string]: string;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n&#x2F;&#x2F; index.ts(3,5): error TS2411: Property &#39;age&#39; of type &#39;number&#39; is not assignable to string index type &#39;string&#39;.\n&#x2F;&#x2F; index.ts(7,5): error TS2322: Type &#39;&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Index signatures are incompatible.\n&#x2F;&#x2F;     Type &#39;string | number&#39; is not assignable to type &#39;string&#39;.\n&#x2F;&#x2F;       Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre>\n\n<p>上例中，任意属性的值允许是 <code>string</code>，但是可选属性 <code>age</code> 的值却是 <code>number</code>，<code>number</code> 不是 <code>string</code> 的子属性，所以报错了。</p>\n<p>另外，在报错信息中可以看出，此时 <code>&#123; name: &#39;Tom&#39;, age: 25, gender: &#39;male&#39; &#125;</code> 的类型被推断成了 <code>&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;</code>，这是联合类型和接口的结合。</p>\n<p>一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n    [propName: string]: string | number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;</code></pre>\n\n<h2 id=\"只读属性\"><a href=\"#只读属性\" class=\"headerlink\" title=\"只读属性\"></a>只读属性</h2><p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 <code>readonly</code> 定义只读属性：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    id: 89757,\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;\n\ntom.id &#x3D; 9527;\n\n&#x2F;&#x2F; index.ts(14,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-only property.</code></pre>\n\n<p>上例中，使用 <code>readonly</code> 定义的属性 <code>id</code> 初始化后，又被赋值了，所以报错了。</p>\n<p><strong>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：</strong></p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;\n\ntom.id &#x3D; 89757;\n\n&#x2F;&#x2F; index.ts(8,5): error TS2322: Type &#39;&#123; name: string; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Property &#39;id&#39; is missing in type &#39;&#123; name: string; gender: string; &#125;&#39;.\n&#x2F;&#x2F; index.ts(13,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-only property.</code></pre>\n\n<p>上例中，报错信息有两处，第一处是在对 <code>tom</code> 进行赋值的时候，没有给 <code>id</code> 赋值。</p>\n<p>第二处是在给 <code>tom.id</code> 赋值的时候，由于它是只读属性，所以报错了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/interfaces.html\">Interfaces</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"对象的类型——接口\"><a href=\"#对象的类型——接口\" class=\"headerlink\" title=\"对象的类型——接口\"></a>对象的类型——接口</h1><p>在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。</p>\n<h2 id=\"什么是接口\"><a href=\"#什么是接口\" class=\"headerlink\" title=\"什么是接口\"></a>什么是接口</h2><p>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。</p>\n<p>TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。</p>\n<h2 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h2><pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25\n&#125;;</code></pre>\n\n<p>上面的例子中，我们定义了一个接口 <code>Person</code>，接着定义了一个变量 <code>tom</code>，它的类型是 <code>Person</code>。这样，我们就约束了 <code>tom</code> 的形状必须和接口 <code>Person</code> 一致。</p>\n<p>接口一般首字母大写。<a href=\"https://msdn.microsoft.com/en-us/library/8bc1fexb%28v=vs.71%29.aspx\">有的编程语言中会建议接口的名称加上 I 前缀</a>。</p>\n<p>定义的变量比接口少了一些属性是不允许的：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;\n&#125;;\n\n&#x2F;&#x2F; index.ts(6,5): error TS2322: Type &#39;&#123; name: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Property &#39;age&#39; is missing in type &#39;&#123; name: string; &#125;&#39;.</code></pre>\n\n<p>多一些属性也是不允许的：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n&#x2F;&#x2F; index.ts(9,5): error TS2322: Type &#39;&#123; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Object literal may only specify known properties, and &#39;gender&#39; does not exist in type &#39;Person&#39;.</code></pre>\n\n<p>可见，<strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong>。</p>\n<h2 id=\"可选属性\"><a href=\"#可选属性\" class=\"headerlink\" title=\"可选属性\"></a>可选属性</h2><p>有时我们希望不要完全匹配一个形状，那么可以用可选属性：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;\n&#125;;</code></pre>\n\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25\n&#125;;</code></pre>\n\n<p>可选属性的含义是该属性可以不存在。</p>\n<p>这时<strong>仍然不允许添加未定义的属性：</strong></p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n&#x2F;&#x2F; examples&#x2F;playground&#x2F;index.ts(9,5): error TS2322: Type &#39;&#123; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Object literal may only specify known properties, and &#39;gender&#39; does not exist in type &#39;Person&#39;.</code></pre>\n\n<h2 id=\"任意属性\"><a href=\"#任意属性\" class=\"headerlink\" title=\"任意属性\"></a>任意属性</h2><p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;</code></pre>\n\n<p>使用 <code>[propName: string]</code> 定义了任意属性取 <code>string</code> 类型的值。</p>\n<p>需要注意的是，<strong>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的同类型或者子集：</strong></p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n    [propName: string]: string;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n&#x2F;&#x2F; index.ts(3,5): error TS2411: Property &#39;age&#39; of type &#39;number&#39; is not assignable to string index type &#39;string&#39;.\n&#x2F;&#x2F; index.ts(7,5): error TS2322: Type &#39;&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Index signatures are incompatible.\n&#x2F;&#x2F;     Type &#39;string | number&#39; is not assignable to type &#39;string&#39;.\n&#x2F;&#x2F;       Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre>\n\n<p>上例中，任意属性的值允许是 <code>string</code>，但是可选属性 <code>age</code> 的值却是 <code>number</code>，<code>number</code> 不是 <code>string</code> 的子属性，所以报错了。</p>\n<p>另外，在报错信息中可以看出，此时 <code>&#123; name: &#39;Tom&#39;, age: 25, gender: &#39;male&#39; &#125;</code> 的类型被推断成了 <code>&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;</code>，这是联合类型和接口的结合。</p>\n<p>一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n    [propName: string]: string | number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;</code></pre>\n\n<h2 id=\"只读属性\"><a href=\"#只读属性\" class=\"headerlink\" title=\"只读属性\"></a>只读属性</h2><p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 <code>readonly</code> 定义只读属性：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    id: 89757,\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;\n\ntom.id &#x3D; 9527;\n\n&#x2F;&#x2F; index.ts(14,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-only property.</code></pre>\n\n<p>上例中，使用 <code>readonly</code> 定义的属性 <code>id</code> 初始化后，又被赋值了，所以报错了。</p>\n<p><strong>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：</strong></p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;\n\ntom.id &#x3D; 89757;\n\n&#x2F;&#x2F; index.ts(8,5): error TS2322: Type &#39;&#123; name: string; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Property &#39;id&#39; is missing in type &#39;&#123; name: string; gender: string; &#125;&#39;.\n&#x2F;&#x2F; index.ts(13,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-only property.</code></pre>\n\n<p>上例中，报错信息有两处，第一处是在对 <code>tom</code> 进行赋值的时候，没有给 <code>id</code> 赋值。</p>\n<p>第二处是在给 <code>tom.id</code> 赋值的时候，由于它是只读属性，所以报错了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/interfaces.html\">Interfaces</a></li>\n</ul>\n"},{"title":"基础 - 数组的类型","cover":"https://whitelabelcoders.com/app/uploads/18.jpg","_content":"\n# 数组的类型\n\n在 TypeScript 中，数组类型有多种定义方式，比较灵活。\n\n## 「类型 + 方括号」表示法\n\n最简单的方法是使用「类型 + 方括号」来表示数组：\n\n```TypeScript\nlet fibonacci: number[] = [1, 1, 2, 3, 5];\n```\n\n数组的项中**不允许**出现其他的类型：\n\n```TypeScript\nlet fibonacci: number[] = [1, '1', 2, 3, 5];\n\n// Type 'string' is not assignable to type 'number'.\n```\n\n数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：\n\n```TypeScript\nlet fibonacci: number[] = [1, 1, 2, 3, 5];\nfibonacci.push('8');\n\n// Argument of type '\"8\"' is not assignable to parameter of type 'number'.\n```\n\n上例中，`push` 方法只允许传入 `number` 类型的参数，但是却传了一个 `\"8\"` 类型的参数，所以报错了。这里 `\"8\"` 是一个字符串字面量类型，会在后续章节中详细介绍。\n\n## 数组泛型\n\n我们也可以使用数组泛型（Array Generic） Array<elemType> 来表示数组：\n\n```TypeScript\nlet fibonacci: Array<number> = [1, 1, 2, 3, 5];\n```\n\n关于泛型，可以参考[泛型]()一章。\n\n## 用接口表示数组\n\n接口也可以用来描述数组：\n\n```TypeScript\ninterface NumberArray {\n    [index: number]: number;\n}\nlet fibonacci: NumberArray = [1, 1, 2, 3, 5];\n```\n\n`NumberArray` 表示：只要索引的类型是数字时，那么值的类型必须是数字。\n\n虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。\n\n不过有一种情况例外，那就是它常用来表示类数组。\n\n## 类数组\n\n类数组（Array-like Object）不是数组类型，比如 arguments：\n\n```TypeScript\nfunction sum() {\n    let args: number[] = arguments;\n}\n\n// Type 'IArguments' is missing the following properties from type 'number[]': pop, push, concat, join, and 24 more.\n```\n\n上例中，arguments 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：\n\n```TypeScript\nfunction sum() {\n    let args: {\n        [index: number]: number;\n        length: number;\n        callee: Function;\n    } = arguments;\n}\n```\n\n在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 `length` 和 `callee` 两个属性。\n\n事实上常用的类数组都有自己的接口定义，如 `IArguments`, `NodeList`, `HTMLCollection` 等：\n\n```TypeScript\nfunction sum() {\n    let args: IArguments = arguments;\n}\n```\n\n其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是：\n\n```TypeScript\ninterface IArguments {\n    [index: number]: any;\n    length: number;\n    callee: Function;\n}\n```\n\n关于内置对象，可以参考[内置对象]()一章。\n\n## any 在数组中的应用\n\n一个比较常见的做法是，用 any 表示数组中允许出现任意类型：\n\n```TypeScript\ninterface IArguments {\n    [index: number]: any;\n    length: number;\n    callee: Function;\n}\n```\n\n## 参考\n- [Basic Types # Array](http://www.typescriptlang.org/docs/handbook/basic-types.html#array)\n- [Interfaces # Indexable Types](http://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types)","source":"_posts/typescript/基础/数组的类型.md","raw":"---\ntitle: 基础 - 数组的类型\ncover: https://whitelabelcoders.com/app/uploads/18.jpg\ncategories:\n  - TypeScript入门\ntags:\n  - TypeScript\n  - 类型\n  - 数组\n---\n\n# 数组的类型\n\n在 TypeScript 中，数组类型有多种定义方式，比较灵活。\n\n## 「类型 + 方括号」表示法\n\n最简单的方法是使用「类型 + 方括号」来表示数组：\n\n```TypeScript\nlet fibonacci: number[] = [1, 1, 2, 3, 5];\n```\n\n数组的项中**不允许**出现其他的类型：\n\n```TypeScript\nlet fibonacci: number[] = [1, '1', 2, 3, 5];\n\n// Type 'string' is not assignable to type 'number'.\n```\n\n数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：\n\n```TypeScript\nlet fibonacci: number[] = [1, 1, 2, 3, 5];\nfibonacci.push('8');\n\n// Argument of type '\"8\"' is not assignable to parameter of type 'number'.\n```\n\n上例中，`push` 方法只允许传入 `number` 类型的参数，但是却传了一个 `\"8\"` 类型的参数，所以报错了。这里 `\"8\"` 是一个字符串字面量类型，会在后续章节中详细介绍。\n\n## 数组泛型\n\n我们也可以使用数组泛型（Array Generic） Array<elemType> 来表示数组：\n\n```TypeScript\nlet fibonacci: Array<number> = [1, 1, 2, 3, 5];\n```\n\n关于泛型，可以参考[泛型]()一章。\n\n## 用接口表示数组\n\n接口也可以用来描述数组：\n\n```TypeScript\ninterface NumberArray {\n    [index: number]: number;\n}\nlet fibonacci: NumberArray = [1, 1, 2, 3, 5];\n```\n\n`NumberArray` 表示：只要索引的类型是数字时，那么值的类型必须是数字。\n\n虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。\n\n不过有一种情况例外，那就是它常用来表示类数组。\n\n## 类数组\n\n类数组（Array-like Object）不是数组类型，比如 arguments：\n\n```TypeScript\nfunction sum() {\n    let args: number[] = arguments;\n}\n\n// Type 'IArguments' is missing the following properties from type 'number[]': pop, push, concat, join, and 24 more.\n```\n\n上例中，arguments 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：\n\n```TypeScript\nfunction sum() {\n    let args: {\n        [index: number]: number;\n        length: number;\n        callee: Function;\n    } = arguments;\n}\n```\n\n在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 `length` 和 `callee` 两个属性。\n\n事实上常用的类数组都有自己的接口定义，如 `IArguments`, `NodeList`, `HTMLCollection` 等：\n\n```TypeScript\nfunction sum() {\n    let args: IArguments = arguments;\n}\n```\n\n其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是：\n\n```TypeScript\ninterface IArguments {\n    [index: number]: any;\n    length: number;\n    callee: Function;\n}\n```\n\n关于内置对象，可以参考[内置对象]()一章。\n\n## any 在数组中的应用\n\n一个比较常见的做法是，用 any 表示数组中允许出现任意类型：\n\n```TypeScript\ninterface IArguments {\n    [index: number]: any;\n    length: number;\n    callee: Function;\n}\n```\n\n## 参考\n- [Basic Types # Array](http://www.typescriptlang.org/docs/handbook/basic-types.html#array)\n- [Interfaces # Indexable Types](http://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types)","slug":"typescript/基础/数组的类型","published":1,"date":"2023-01-05T09:45:01.484Z","updated":"2023-01-05T10:01:04.290Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcq06l08000yysvn58b119zy","content":"<h1 id=\"数组的类型\"><a href=\"#数组的类型\" class=\"headerlink\" title=\"数组的类型\"></a>数组的类型</h1><p>在 TypeScript 中，数组类型有多种定义方式，比较灵活。</p>\n<h2 id=\"「类型-方括号」表示法\"><a href=\"#「类型-方括号」表示法\" class=\"headerlink\" title=\"「类型 + 方括号」表示法\"></a>「类型 + 方括号」表示法</h2><p>最简单的方法是使用「类型 + 方括号」来表示数组：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let fibonacci: number[] &#x3D; [1, 1, 2, 3, 5];</code></pre>\n\n<p>数组的项中<strong>不允许</strong>出现其他的类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let fibonacci: number[] &#x3D; [1, &#39;1&#39;, 2, 3, 5];\n\n&#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;number&#39;.</code></pre>\n\n<p>数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let fibonacci: number[] &#x3D; [1, 1, 2, 3, 5];\nfibonacci.push(&#39;8&#39;);\n\n&#x2F;&#x2F; Argument of type &#39;&quot;8&quot;&#39; is not assignable to parameter of type &#39;number&#39;.</code></pre>\n\n<p>上例中，<code>push</code> 方法只允许传入 <code>number</code> 类型的参数，但是却传了一个 <code>&quot;8&quot;</code> 类型的参数，所以报错了。这里 <code>&quot;8&quot;</code> 是一个字符串字面量类型，会在后续章节中详细介绍。</p>\n<h2 id=\"数组泛型\"><a href=\"#数组泛型\" class=\"headerlink\" title=\"数组泛型\"></a>数组泛型</h2><p>我们也可以使用数组泛型（Array Generic） Array<elemType> 来表示数组：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let fibonacci: Array&lt;number&gt; &#x3D; [1, 1, 2, 3, 5];</code></pre>\n\n<p>关于泛型，可以参考<a href=\"\">泛型</a>一章。</p>\n<h2 id=\"用接口表示数组\"><a href=\"#用接口表示数组\" class=\"headerlink\" title=\"用接口表示数组\"></a>用接口表示数组</h2><p>接口也可以用来描述数组：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface NumberArray &#123;\n    [index: number]: number;\n&#125;\nlet fibonacci: NumberArray &#x3D; [1, 1, 2, 3, 5];</code></pre>\n\n<p><code>NumberArray</code> 表示：只要索引的类型是数字时，那么值的类型必须是数字。</p>\n<p>虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。</p>\n<p>不过有一种情况例外，那就是它常用来表示类数组。</p>\n<h2 id=\"类数组\"><a href=\"#类数组\" class=\"headerlink\" title=\"类数组\"></a>类数组</h2><p>类数组（Array-like Object）不是数组类型，比如 arguments：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function sum() &#123;\n    let args: number[] &#x3D; arguments;\n&#125;\n\n&#x2F;&#x2F; Type &#39;IArguments&#39; is missing the following properties from type &#39;number[]&#39;: pop, push, concat, join, and 24 more.</code></pre>\n\n<p>上例中，arguments 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function sum() &#123;\n    let args: &#123;\n        [index: number]: number;\n        length: number;\n        callee: Function;\n    &#125; &#x3D; arguments;\n&#125;</code></pre>\n\n<p>在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 <code>length</code> 和 <code>callee</code> 两个属性。</p>\n<p>事实上常用的类数组都有自己的接口定义，如 <code>IArguments</code>, <code>NodeList</code>, <code>HTMLCollection</code> 等：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function sum() &#123;\n    let args: IArguments &#x3D; arguments;\n&#125;</code></pre>\n\n<p>其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface IArguments &#123;\n    [index: number]: any;\n    length: number;\n    callee: Function;\n&#125;</code></pre>\n\n<p>关于内置对象，可以参考<a href=\"\">内置对象</a>一章。</p>\n<h2 id=\"any-在数组中的应用\"><a href=\"#any-在数组中的应用\" class=\"headerlink\" title=\"any 在数组中的应用\"></a>any 在数组中的应用</h2><p>一个比较常见的做法是，用 any 表示数组中允许出现任意类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface IArguments &#123;\n    [index: number]: any;\n    length: number;\n    callee: Function;\n&#125;</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/basic-types.html#array\">Basic Types # Array</a></li>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types\">Interfaces # Indexable Types</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数组的类型\"><a href=\"#数组的类型\" class=\"headerlink\" title=\"数组的类型\"></a>数组的类型</h1><p>在 TypeScript 中，数组类型有多种定义方式，比较灵活。</p>\n<h2 id=\"「类型-方括号」表示法\"><a href=\"#「类型-方括号」表示法\" class=\"headerlink\" title=\"「类型 + 方括号」表示法\"></a>「类型 + 方括号」表示法</h2><p>最简单的方法是使用「类型 + 方括号」来表示数组：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let fibonacci: number[] &#x3D; [1, 1, 2, 3, 5];</code></pre>\n\n<p>数组的项中<strong>不允许</strong>出现其他的类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let fibonacci: number[] &#x3D; [1, &#39;1&#39;, 2, 3, 5];\n\n&#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;number&#39;.</code></pre>\n\n<p>数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let fibonacci: number[] &#x3D; [1, 1, 2, 3, 5];\nfibonacci.push(&#39;8&#39;);\n\n&#x2F;&#x2F; Argument of type &#39;&quot;8&quot;&#39; is not assignable to parameter of type &#39;number&#39;.</code></pre>\n\n<p>上例中，<code>push</code> 方法只允许传入 <code>number</code> 类型的参数，但是却传了一个 <code>&quot;8&quot;</code> 类型的参数，所以报错了。这里 <code>&quot;8&quot;</code> 是一个字符串字面量类型，会在后续章节中详细介绍。</p>\n<h2 id=\"数组泛型\"><a href=\"#数组泛型\" class=\"headerlink\" title=\"数组泛型\"></a>数组泛型</h2><p>我们也可以使用数组泛型（Array Generic） Array<elemType> 来表示数组：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let fibonacci: Array&lt;number&gt; &#x3D; [1, 1, 2, 3, 5];</code></pre>\n\n<p>关于泛型，可以参考<a href=\"\">泛型</a>一章。</p>\n<h2 id=\"用接口表示数组\"><a href=\"#用接口表示数组\" class=\"headerlink\" title=\"用接口表示数组\"></a>用接口表示数组</h2><p>接口也可以用来描述数组：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface NumberArray &#123;\n    [index: number]: number;\n&#125;\nlet fibonacci: NumberArray &#x3D; [1, 1, 2, 3, 5];</code></pre>\n\n<p><code>NumberArray</code> 表示：只要索引的类型是数字时，那么值的类型必须是数字。</p>\n<p>虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。</p>\n<p>不过有一种情况例外，那就是它常用来表示类数组。</p>\n<h2 id=\"类数组\"><a href=\"#类数组\" class=\"headerlink\" title=\"类数组\"></a>类数组</h2><p>类数组（Array-like Object）不是数组类型，比如 arguments：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function sum() &#123;\n    let args: number[] &#x3D; arguments;\n&#125;\n\n&#x2F;&#x2F; Type &#39;IArguments&#39; is missing the following properties from type &#39;number[]&#39;: pop, push, concat, join, and 24 more.</code></pre>\n\n<p>上例中，arguments 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function sum() &#123;\n    let args: &#123;\n        [index: number]: number;\n        length: number;\n        callee: Function;\n    &#125; &#x3D; arguments;\n&#125;</code></pre>\n\n<p>在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 <code>length</code> 和 <code>callee</code> 两个属性。</p>\n<p>事实上常用的类数组都有自己的接口定义，如 <code>IArguments</code>, <code>NodeList</code>, <code>HTMLCollection</code> 等：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function sum() &#123;\n    let args: IArguments &#x3D; arguments;\n&#125;</code></pre>\n\n<p>其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface IArguments &#123;\n    [index: number]: any;\n    length: number;\n    callee: Function;\n&#125;</code></pre>\n\n<p>关于内置对象，可以参考<a href=\"\">内置对象</a>一章。</p>\n<h2 id=\"any-在数组中的应用\"><a href=\"#any-在数组中的应用\" class=\"headerlink\" title=\"any 在数组中的应用\"></a>any 在数组中的应用</h2><p>一个比较常见的做法是，用 any 表示数组中允许出现任意类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface IArguments &#123;\n    [index: number]: any;\n    length: number;\n    callee: Function;\n&#125;</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/basic-types.html#array\">Basic Types # Array</a></li>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types\">Interfaces # Indexable Types</a></li>\n</ul>\n"},{"title":"基础 - 类型断言","cover":"https://whitelabelcoders.com/app/uploads/18.jpg","_content":"\n# 类型断言\n\n## 语法\n\n```ts\n值 as 类型 \n// 或者\n<类型>值\n```\n\n## 类型断言的用途\n\n类型断言的常见用途有以下几种\n\n### 将一个联合类型断言为其中一种\n\n[之前提到过](/post/typescript%2F基础%2F联合类型#访问联合类型的属性或方法)，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们**只能访问此联合类型的所有类型中共有的属性或方法**：\n\n```ts\ninterface Cat {\n    name: 'mimi;'\n    cry(): void;\n}\n\ninterface Dog {\n    name: '来福'\n    cay(): void;\n}\n\nfunction (fun: Cat | Dog) {\n    return Cat.name\n}\n```\n\n而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法，比如：\n\n```ts\ninterface Cat {\n    name: 'mimi;'\n    cry(): void;\n}\n\ninterface Dog {\n    name: '来福'\n    run(): void;\n}\n\nfunction (fun: Cat | Dog): boolean {\n    if (typeof fun.cry == 'function') return true\n    return false\n}\n// index.ts:11:23 - error TS2339: Property 'cry' does not exist on type 'Cat | Dog'.\n//   Property 'cry' does not exist on type 'Cat'.\n```\n\n上面的例子中，获取 `animal.swim` 的时候会报错。\n\n此时可以使用类型断言，将 `animal` 断言成 `Fish`：\n\n```ts\ninterface Cat {\n    name: 'mimi;'\n    cry(): void;\n}\n\ninterface Dog {\n    name: '来福'\n    run(): void;\n}\n\nfunction (fun: Cat | Dog): boolean {\n    if (typeof (fun.cry as Cat) == 'function') return true\n    return false\n}\n```\n\n这样就可以解决访问 `animal.swim` 时报错的问题了。\n\n:::tip\n\n需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误：\n\n:::\n\n```ts\ninterface Cat {\n    name: 'mimi;'\n    cry(): void;\n}\n\ninterface Dog {\n    name: '来福'\n    run(): void;\n}\n\nfunction dosth (fun: Cat | Dog): boolean {\n    if (typeof (fun.cry as Cat) == 'function') return true\n    return false\n}\n\nconst jeck: Dog = {\n    name: '哼哈',\n    run() { console.log('run') }\n}\n\ndosth(jeck)\n// Uncaught TypeError: fun.cry is not a function`\n```\n\n报错的原因是因为 `(fun.cry as Cat)` 隐藏了`fun`为`Dog`的可能性, 直接将`fun`断言为了`Cat`而`Cat`类型里就没有`run`方法, 就会导致运行时错误了。\n\n>总之，使用类型断言时一定要格外小心，尽量避免断言后调用方法或引用深层属性，以减少不必要的运行时错误。\n\n### 将一个父类断言为更具体的子类\n\n当类之间有继承关系的时候, 类型断言也是很常见的\n\n```ts\nclass ApiError extends Error {\n    code: number = 0\n}\n\nclass HttpError extends Error {\n    statuscode: number = 200\n}\n\nfunction isHttpError (error: Error) {\n    if (typeof (error as HttpError).statuscode = 'number') return true\n    return false\n}\n```\n\n上面的例子中，我们声明了函数 `isHttpError`，它用来判断传入的参数是不是 `HttpError` 类型，为了实现这样一个函数，它的参数的类型肯定得是比`ApiError`和`HttpError`更抽象的父类 `Error`，这样的话这个函数就能接受 `Error` 或它的子类作为参数了。\n\n但是由于父类 `Error` 中没有 `statuscode` 属性，故直接获取 `error.statuscode` 会报错，需要使用类型断言获取 `(error as HttpError).code`。\n\n大家可能会注意到，在这个例子中有一个更合适的方式来判断是不是 `HttpError`，那就是使用 `instanceof`：\n\n```ts\nclass ApiError extends Error {\n    code: number = 0\n}\n\nclass HttpError extends Error {\n    statuscode: number = 200\n}\n\nfunction isHttpError (error: Error) {\n    if (error instanceof HttpError) return true\n    return false\n}\n```\n\n:::tip\n\n上面的例子中，确实使用 `instanceof` 更加合适，因为 `HttpError` 是一个 JavaScript 的类，能够通过 `instanceof` 来判断 `error` 是否是它的实例。\n\n但是有的情况下 `ApiError` 和 `HttpError` 不是一个真正的类，而只是一个 TypeScript 的接口（`interface`），接口是一个类型，不是一个真正的值，它在编译结果中会被删除，当然就无法使用 `instanceof` 来做运行时判断了\n\n:::\n\n此时就只能用类型断言，通过判断是否存在 `code` 属性，来判断传入的参数是不是 `ApiError` 了：\n\n```ts\ninterface ApiError extends Error {\n    code: number;\n}\ninterface HttpError extends Error {\n    statusCode: number;\n}\n\nfunction isApiError(error: Error) {\n    if (typeof (error as ApiError).code === 'number') {\n        return true;\n    }\n    return false;\n}\n```\n\n### 将任何一个类型断言为 \n\n理想情况下，TypeScript 的类型系统运转良好，每个值的类型都具体而精确。\n\n当我们引用一个在此类型上不存在的属性或方法时，就会报错：\n\n```ts\nconst foo: number = 1;\nfoo.length = 1;\n\n// index.ts:2:5 - error TS2339: Property 'length' does not exist on type 'number'.\n```\n\n上面的例子中，数字类型的变量 `foo` 上是没有 `length` 属性的，故 TypeScript 给出了相应的错误提示。\n\n这种错误提示显然是非常有用的。\n\n但有的时候，我们非常确定这段代码不会出错，比如下面这个例子：\n\n```ts\nwindow.foo = 1;\n\n// index.ts:1:8 - error TS2339: Property 'foo' does not exist on type 'Window & typeof globalThis'.\n```\n\n上面的例子中，我们需要将 `window` 上添加一个属性 `foo`，但 TypeScript 编译时会报错，提示我们 `window` 上不存在 `foo` 属性。\n\n此时我们可以使用 `as any` 临时将 `window` 断言为 `any` 类型：\n\n```ts\n(window as any).foo = 1;\n```\n\n在 `any` 类型的变量上，访问任何属性都是允许的。\n\n需要注意的是，将一个变量断言为 `any` 可以说是解决 TypeScript 中类型问题的最后一个手段。\n\n**它极有可能掩盖了真正的类型错误，所以如果不是非常确定，就不要使用 `as any`。**\n\n上面的例子中，我们也可以通过[扩展 window 的类型（TODO）][]解决这个错误，不过如果只是临时的增加 `foo` 属性，`as any` 会更加方便。\n\n总之，**一方面不能滥用 `as any`，另一方面也不要完全否定它的作用，我们需要在类型的严格性和开发的便利性之间掌握平衡**（这也是 [TypeScript 的设计理念](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals)之一），才能发挥出 TypeScript 最大的价值。\n\n### 将 `any` 断言为一个具体的类型\n\n在日常的开发中，我们不可避免的需要处理 `any` 类型的变量，它们可能是由于第三方库未能定义好自己的类型，也有可能是历史遗留的或其他人编写的烂代码，还可能是受到 TypeScript 类型系统的限制而无法精确定义类型的场景。\n\n遇到 `any` 类型的变量时，我们可以选择无视它，任由它滋生更多的 `any`。\n\n我们也可以选择改进它，通过类型断言及时的把 `any` 断言为精确的类型，亡羊补牢，使我们的代码向着高可维护性的目标发展。\n\n举例来说，历史遗留的代码中有个 `getCacheData`，它的返回值是 `any`：\n\n```ts\nfunction getCacheData(key: string): any {\n    return (window as any).cache[key];\n}\n```\n\n那么我们在使用它时，最好能够将调用了它之后的返回值断言成一个精确的类型，这样就方便了后续的操作：\n\n```ts\nfunction getCacheData(key: string): any {\n    return (window as any).cache[key];\n}\n\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst tom = getCacheData('tom') as Cat;\ntom.run();\n```\n\n上面的例子中，我们调用完 `getCacheData` 之后，立即将它断言为 `Cat` 类型。这样的话明确了 `tom` 的类型，后续对 `tom` 的访问时就有了代码补全，提高了代码的可维护性。\n\n## 类型断言的限制\n\n从上面的例子中，我们可以总结出：\n\n- 联合类型可以被断言为其中一个类型\n- 父类可以被断言为子类\n- 任何类型都可以被断言为 any\n- any 可以被断言为任何类型\n\n那么类型断言有没有什么限制呢？是不是任何一个类型都可以被断言为任何另一个类型呢？\n\n答案是否定的——并不是任何一个类型都可以被断言为任何另一个类型。\n\n具体来说，若 `A` 兼容 `B`，那么 `A` 能够被断言为 `B`，`B` 也能被断言为 `A`。\n\n下面我们通过一个简化的例子，来理解类型断言的限制：\n\n```ts\ninterface Animal {\n    name: string;\n}\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nlet tom: Cat = {\n    name: 'Tom',\n    run: () => { console.log('run') }\n};\nlet animal: Animal = tom;\n```\n\n我们知道，TypeScript 是结构类型系统，类型之间的对比只会比较它们最终的结构，而会忽略它们定义时的关系。\n\n在上面的例子中，`Cat` 包含了 `Animal` 中的所有属性，除此之外，它还有一个额外的方法 `run`。TypeScript 并不关心 `Cat` 和 `Animal` 之间定义时是什么关系，而只会看它们最终的结构有什么关系——所以它与 `Cat extends Animal` 是等价的：\n\n```ts\ninterface Animal {\n    name: string;\n}\ninterface Cat extends Animal {\n    run(): void;\n}\n```\n\n那么也不难理解为什么 `Cat` 类型的 `tom` 可以赋值给 `Animal` 类型的 `animal` 了——就像面向对象编程中我们可以将子类的实例赋值给类型为父类的变量。\n\n我们把它换成 TypeScript 中更专业的说法，即：`Animal` 兼容 `Cat`。\n\n当 `Animal` 兼容 `Cat` 时，它们就可以互相进行类型断言了：\n\n```ts\ninterface Animal {\n    name: string;\n}\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nfunction testAnimal(animal: Animal) {\n    return (animal as Cat);\n}\nfunction testCat(cat: Cat) {\n    return (cat as Animal);\n}\n```\n\n这样的设计其实也很容易就能理解：\n\n- 允许 `animal as Cat` 是因为「父类可以被断言为子类」，这个前面已经学习过了\n- 允许 `cat as Animal` 是因为既然子类拥有父类的属性和方法，那么被断言为父类，获取父类的属性、调用父类的方法，就不会有任何问题，故「子类可以被断言为父类」\n\n需要注意的是，这里我们使用了简化的父类子类的关系来表达类型的兼容性，而实际上 TypeScript 在判断类型的兼容性时，比这种情况复杂很多，详细请参考[类型的兼容性（TODO)][]章节。\n\n总之，若 `A` 兼容 `B`，那么 `A` 能够被断言为 `B`，`B` 也能被断言为 `A`。\n\n同理，若 `B` 兼容 `A`，那么 `A` 能够被断言为 `B`，`B` 也能被断言为 `A`。\n\n所以这也可以换一种说法：\n\n要使得 `A` 能够被断言为 `B`，只需要 `A` 兼容 `B` 或 `B` 兼容 `A` 即可，这也是为了在类型断言时的安全考虑，毕竟毫无根据的断言是非常危险的。\n\n综上所述：\n\n- 联合类型可以被断言为其中一个类型\n- 父类可以被断言为子类\n- 任何类型都可以被断言为 any\n- any 可以被断言为任何类型\n- 要使得 `A` 能够被断言为 `B`，只需要 `A` 兼容 `B` 或 `B` 兼容 `A` 即可\n\n其实前四种情况都是最后一个的特例。\n\n## 双重断言\n\n既然：\n\n- 任何类型都可以被断言为 any\n- any 可以被断言为任何类型\n\n那么我们是不是可以使用双重断言 `as any as Foo` 来将任何一个类型断言为任何另一个类型呢？\n\n```ts\ninterface Cat {\n    run(): void;\n}\ninterface Fish {\n    swim(): void;\n}\n\nfunction testCat(cat: Cat) {\n    return (cat as any as Fish);\n}\n```\n\n在上面的例子中，若直接使用 `cat as Fish` 肯定会报错，因为 `Cat` 和 `Fish` 互相都不兼容。\n\n但是若使用双重断言，则可以打破「要使得 `A` 能够被断言为 `B`，只需要 `A` 兼容 `B` 或 `B` 兼容 `A` 即可」的限制，将任何一个类型断言为任何另一个类型。\n\n若你使用了这种双重断言，那么十有八九是非常错误的，它很可能会导致运行时错误。\n\n**除非迫不得已，千万别用双重断言。**\n\n## 类型断言VS类型转换\n\n类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除：\n\n```ts\nfunction toBoolean(something: any): boolean {\n    return something as boolean;\n}\n\ntoBoolean(1);\n// 返回值为 1\n```\n\n在上面的例子中，将 `something` 断言为 `boolean` 虽然可以通过编译，但是并没有什么用，代码在编译后会变成：\n\n```js\nfunction toBoolean(something) {\n    return something;\n}\n\ntoBoolean(1);\n// 返回值为 1\n```\n\n所以类型断言不是类型转换，它不会真的影响到变量的类型。\n\n若要进行类型转换，需要直接调用类型转换的方法：\n\n```ts\nfunction toBoolean(something: any): boolean {\n    return Boolean(something);\n}\n\ntoBoolean(1);\n// 返回值为 true\n```\n\n## 类型断言 vs 类型声明\n\n在这个例子中：\n\n```ts\nfunction getCacheData(key: string): any {\n    return (window as any).cache[key];\n}\n\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst tom = getCacheData('tom') as Cat;\ntom.run();\n```\n\n我们使用 `as Cat` 将 `any` 类型断言为了 `Cat` 类型。\n\n但实际上还有其他方式可以解决这个问题：\n\n```ts\nfunction getCacheData(key: string): any {\n    return (window as any).cache[key];\n}\n\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst tom: Cat = getCacheData('tom');\ntom.run();\n```\n\n上面的例子中，我们通过类型声明的方式，将 `tom` 声明为 `Cat`，然后再将 `any` 类型的 `getCacheData('tom')` 赋值给 `Cat` 类型的 `tom`。\n\n这和类型断言是非常相似的，而且产生的结果也几乎是一样的——`tom` 在接下来的代码中都变成了 `Cat` 类型。\n\n它们的区别，可以通过这个例子来理解：\n\n```ts\ninterface Animal {\n    name: string;\n}\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst animal: Animal = {\n    name: 'tom'\n};\nlet tom = animal as Cat;\n```\n\n在上面的例子中，由于 `Animal` 兼容 `Cat`，故可以将 `animal` 断言为 `Cat` 赋值给 `tom`。\n\n但是若直接声明 `tom` 为 `Cat` 类型：\n\n```ts\ninterface Animal {\n    name: string;\n}\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst animal: Animal = {\n    name: 'tom'\n};\nlet tom: Cat = animal;\n\n// index.ts:12:5 - error TS2741: Property 'run' is missing in type 'Animal' but required in type 'Cat'.\n```\n\n则会报错，不允许将 `animal` 赋值为 `Cat` 类型的 `tom`。\n\n这很容易理解，`Animal` 可以看作是 `Cat` 的父类，当然不能将父类的实例赋值给类型为子类的变量。\n\n深入的讲，它们的核心区别就在于：\n\n- `animal` 断言为 `Cat`，只需要满足 `Animal` 兼容 `Cat` 或 `Cat` 兼容 `Animal` 即可\n- `animal` 赋值给 `tom`，需要满足 `Cat` 兼容 `Animal` 才行\n\n但是 `Cat` 并不兼容 `Animal`。\n\n而在前一个例子中，由于 `getCacheData('tom')` 是 `any` 类型，`any` 兼容 `Cat`，`Cat` 也兼容 `any`，故\n\n```ts\nconst tom = getCacheData('tom') as Cat;\n```\n\n等价于\n\n```ts\nconst tom: Cat = getCacheData('tom');\n```\n\n知道了它们的核心区别，就知道了类型声明是比类型断言更加严格的。\n\n所以为了增加代码的质量，我们最好优先使用类型声明，这也比类型断言的 `as` 语法更加优雅。\n\n## 类型断言 vs 泛型\n\n> 本小节的前置知识点：[泛型](/post/typescript/进阶/泛型)\n\n还是这个例子：\n\n```ts\nfunction getCacheData(key: string): any {\n    return (window as any).cache[key];\n}\n\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst tom = getCacheData('tom') as Cat;\ntom.run();\n```\n\n我们还有第三种方式可以解决这个问题，那就是泛型：\n\n```ts\nfunction getCacheData<T>(key: string): T {\n    return (window as any).cache[key];\n}\n\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst tom = getCacheData<Cat>('tom');\ntom.run();\n```\n\n通过给 `getCacheData` 函数添加了一个泛型 `<T>`，我们可以更加规范的实现对 `getCacheData` 返回值的约束，这也同时去除掉了代码中的 `any`，是最优的一个解决方案。\n\n## 参考[§](https://ts.xcatliu.com/basics/type-assertion.html#参考)\n\n- [TypeScript Deep Dive / Type Assertion](https://basarat.gitbooks.io/typescript/content/docs/types/type-assertion.html)\n- [Advanced Types # Type Guards and Differentiating Types](http://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types)（[中文版](https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced Types.html#类型保护与区分类型（type-guards-and-differentiating-types）)）\n- [TypeScript 的设计理念](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals)","source":"_posts/typescript/基础/类型断言.md","raw":"---\ntitle: 基础 - 类型断言\ncover: https://whitelabelcoders.com/app/uploads/18.jpg\ncategories:\n  - TypeScript入门\ntags:\n  - TypeScript\n  - 基础\n---\n\n# 类型断言\n\n## 语法\n\n```ts\n值 as 类型 \n// 或者\n<类型>值\n```\n\n## 类型断言的用途\n\n类型断言的常见用途有以下几种\n\n### 将一个联合类型断言为其中一种\n\n[之前提到过](/post/typescript%2F基础%2F联合类型#访问联合类型的属性或方法)，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们**只能访问此联合类型的所有类型中共有的属性或方法**：\n\n```ts\ninterface Cat {\n    name: 'mimi;'\n    cry(): void;\n}\n\ninterface Dog {\n    name: '来福'\n    cay(): void;\n}\n\nfunction (fun: Cat | Dog) {\n    return Cat.name\n}\n```\n\n而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法，比如：\n\n```ts\ninterface Cat {\n    name: 'mimi;'\n    cry(): void;\n}\n\ninterface Dog {\n    name: '来福'\n    run(): void;\n}\n\nfunction (fun: Cat | Dog): boolean {\n    if (typeof fun.cry == 'function') return true\n    return false\n}\n// index.ts:11:23 - error TS2339: Property 'cry' does not exist on type 'Cat | Dog'.\n//   Property 'cry' does not exist on type 'Cat'.\n```\n\n上面的例子中，获取 `animal.swim` 的时候会报错。\n\n此时可以使用类型断言，将 `animal` 断言成 `Fish`：\n\n```ts\ninterface Cat {\n    name: 'mimi;'\n    cry(): void;\n}\n\ninterface Dog {\n    name: '来福'\n    run(): void;\n}\n\nfunction (fun: Cat | Dog): boolean {\n    if (typeof (fun.cry as Cat) == 'function') return true\n    return false\n}\n```\n\n这样就可以解决访问 `animal.swim` 时报错的问题了。\n\n:::tip\n\n需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误：\n\n:::\n\n```ts\ninterface Cat {\n    name: 'mimi;'\n    cry(): void;\n}\n\ninterface Dog {\n    name: '来福'\n    run(): void;\n}\n\nfunction dosth (fun: Cat | Dog): boolean {\n    if (typeof (fun.cry as Cat) == 'function') return true\n    return false\n}\n\nconst jeck: Dog = {\n    name: '哼哈',\n    run() { console.log('run') }\n}\n\ndosth(jeck)\n// Uncaught TypeError: fun.cry is not a function`\n```\n\n报错的原因是因为 `(fun.cry as Cat)` 隐藏了`fun`为`Dog`的可能性, 直接将`fun`断言为了`Cat`而`Cat`类型里就没有`run`方法, 就会导致运行时错误了。\n\n>总之，使用类型断言时一定要格外小心，尽量避免断言后调用方法或引用深层属性，以减少不必要的运行时错误。\n\n### 将一个父类断言为更具体的子类\n\n当类之间有继承关系的时候, 类型断言也是很常见的\n\n```ts\nclass ApiError extends Error {\n    code: number = 0\n}\n\nclass HttpError extends Error {\n    statuscode: number = 200\n}\n\nfunction isHttpError (error: Error) {\n    if (typeof (error as HttpError).statuscode = 'number') return true\n    return false\n}\n```\n\n上面的例子中，我们声明了函数 `isHttpError`，它用来判断传入的参数是不是 `HttpError` 类型，为了实现这样一个函数，它的参数的类型肯定得是比`ApiError`和`HttpError`更抽象的父类 `Error`，这样的话这个函数就能接受 `Error` 或它的子类作为参数了。\n\n但是由于父类 `Error` 中没有 `statuscode` 属性，故直接获取 `error.statuscode` 会报错，需要使用类型断言获取 `(error as HttpError).code`。\n\n大家可能会注意到，在这个例子中有一个更合适的方式来判断是不是 `HttpError`，那就是使用 `instanceof`：\n\n```ts\nclass ApiError extends Error {\n    code: number = 0\n}\n\nclass HttpError extends Error {\n    statuscode: number = 200\n}\n\nfunction isHttpError (error: Error) {\n    if (error instanceof HttpError) return true\n    return false\n}\n```\n\n:::tip\n\n上面的例子中，确实使用 `instanceof` 更加合适，因为 `HttpError` 是一个 JavaScript 的类，能够通过 `instanceof` 来判断 `error` 是否是它的实例。\n\n但是有的情况下 `ApiError` 和 `HttpError` 不是一个真正的类，而只是一个 TypeScript 的接口（`interface`），接口是一个类型，不是一个真正的值，它在编译结果中会被删除，当然就无法使用 `instanceof` 来做运行时判断了\n\n:::\n\n此时就只能用类型断言，通过判断是否存在 `code` 属性，来判断传入的参数是不是 `ApiError` 了：\n\n```ts\ninterface ApiError extends Error {\n    code: number;\n}\ninterface HttpError extends Error {\n    statusCode: number;\n}\n\nfunction isApiError(error: Error) {\n    if (typeof (error as ApiError).code === 'number') {\n        return true;\n    }\n    return false;\n}\n```\n\n### 将任何一个类型断言为 \n\n理想情况下，TypeScript 的类型系统运转良好，每个值的类型都具体而精确。\n\n当我们引用一个在此类型上不存在的属性或方法时，就会报错：\n\n```ts\nconst foo: number = 1;\nfoo.length = 1;\n\n// index.ts:2:5 - error TS2339: Property 'length' does not exist on type 'number'.\n```\n\n上面的例子中，数字类型的变量 `foo` 上是没有 `length` 属性的，故 TypeScript 给出了相应的错误提示。\n\n这种错误提示显然是非常有用的。\n\n但有的时候，我们非常确定这段代码不会出错，比如下面这个例子：\n\n```ts\nwindow.foo = 1;\n\n// index.ts:1:8 - error TS2339: Property 'foo' does not exist on type 'Window & typeof globalThis'.\n```\n\n上面的例子中，我们需要将 `window` 上添加一个属性 `foo`，但 TypeScript 编译时会报错，提示我们 `window` 上不存在 `foo` 属性。\n\n此时我们可以使用 `as any` 临时将 `window` 断言为 `any` 类型：\n\n```ts\n(window as any).foo = 1;\n```\n\n在 `any` 类型的变量上，访问任何属性都是允许的。\n\n需要注意的是，将一个变量断言为 `any` 可以说是解决 TypeScript 中类型问题的最后一个手段。\n\n**它极有可能掩盖了真正的类型错误，所以如果不是非常确定，就不要使用 `as any`。**\n\n上面的例子中，我们也可以通过[扩展 window 的类型（TODO）][]解决这个错误，不过如果只是临时的增加 `foo` 属性，`as any` 会更加方便。\n\n总之，**一方面不能滥用 `as any`，另一方面也不要完全否定它的作用，我们需要在类型的严格性和开发的便利性之间掌握平衡**（这也是 [TypeScript 的设计理念](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals)之一），才能发挥出 TypeScript 最大的价值。\n\n### 将 `any` 断言为一个具体的类型\n\n在日常的开发中，我们不可避免的需要处理 `any` 类型的变量，它们可能是由于第三方库未能定义好自己的类型，也有可能是历史遗留的或其他人编写的烂代码，还可能是受到 TypeScript 类型系统的限制而无法精确定义类型的场景。\n\n遇到 `any` 类型的变量时，我们可以选择无视它，任由它滋生更多的 `any`。\n\n我们也可以选择改进它，通过类型断言及时的把 `any` 断言为精确的类型，亡羊补牢，使我们的代码向着高可维护性的目标发展。\n\n举例来说，历史遗留的代码中有个 `getCacheData`，它的返回值是 `any`：\n\n```ts\nfunction getCacheData(key: string): any {\n    return (window as any).cache[key];\n}\n```\n\n那么我们在使用它时，最好能够将调用了它之后的返回值断言成一个精确的类型，这样就方便了后续的操作：\n\n```ts\nfunction getCacheData(key: string): any {\n    return (window as any).cache[key];\n}\n\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst tom = getCacheData('tom') as Cat;\ntom.run();\n```\n\n上面的例子中，我们调用完 `getCacheData` 之后，立即将它断言为 `Cat` 类型。这样的话明确了 `tom` 的类型，后续对 `tom` 的访问时就有了代码补全，提高了代码的可维护性。\n\n## 类型断言的限制\n\n从上面的例子中，我们可以总结出：\n\n- 联合类型可以被断言为其中一个类型\n- 父类可以被断言为子类\n- 任何类型都可以被断言为 any\n- any 可以被断言为任何类型\n\n那么类型断言有没有什么限制呢？是不是任何一个类型都可以被断言为任何另一个类型呢？\n\n答案是否定的——并不是任何一个类型都可以被断言为任何另一个类型。\n\n具体来说，若 `A` 兼容 `B`，那么 `A` 能够被断言为 `B`，`B` 也能被断言为 `A`。\n\n下面我们通过一个简化的例子，来理解类型断言的限制：\n\n```ts\ninterface Animal {\n    name: string;\n}\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nlet tom: Cat = {\n    name: 'Tom',\n    run: () => { console.log('run') }\n};\nlet animal: Animal = tom;\n```\n\n我们知道，TypeScript 是结构类型系统，类型之间的对比只会比较它们最终的结构，而会忽略它们定义时的关系。\n\n在上面的例子中，`Cat` 包含了 `Animal` 中的所有属性，除此之外，它还有一个额外的方法 `run`。TypeScript 并不关心 `Cat` 和 `Animal` 之间定义时是什么关系，而只会看它们最终的结构有什么关系——所以它与 `Cat extends Animal` 是等价的：\n\n```ts\ninterface Animal {\n    name: string;\n}\ninterface Cat extends Animal {\n    run(): void;\n}\n```\n\n那么也不难理解为什么 `Cat` 类型的 `tom` 可以赋值给 `Animal` 类型的 `animal` 了——就像面向对象编程中我们可以将子类的实例赋值给类型为父类的变量。\n\n我们把它换成 TypeScript 中更专业的说法，即：`Animal` 兼容 `Cat`。\n\n当 `Animal` 兼容 `Cat` 时，它们就可以互相进行类型断言了：\n\n```ts\ninterface Animal {\n    name: string;\n}\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nfunction testAnimal(animal: Animal) {\n    return (animal as Cat);\n}\nfunction testCat(cat: Cat) {\n    return (cat as Animal);\n}\n```\n\n这样的设计其实也很容易就能理解：\n\n- 允许 `animal as Cat` 是因为「父类可以被断言为子类」，这个前面已经学习过了\n- 允许 `cat as Animal` 是因为既然子类拥有父类的属性和方法，那么被断言为父类，获取父类的属性、调用父类的方法，就不会有任何问题，故「子类可以被断言为父类」\n\n需要注意的是，这里我们使用了简化的父类子类的关系来表达类型的兼容性，而实际上 TypeScript 在判断类型的兼容性时，比这种情况复杂很多，详细请参考[类型的兼容性（TODO)][]章节。\n\n总之，若 `A` 兼容 `B`，那么 `A` 能够被断言为 `B`，`B` 也能被断言为 `A`。\n\n同理，若 `B` 兼容 `A`，那么 `A` 能够被断言为 `B`，`B` 也能被断言为 `A`。\n\n所以这也可以换一种说法：\n\n要使得 `A` 能够被断言为 `B`，只需要 `A` 兼容 `B` 或 `B` 兼容 `A` 即可，这也是为了在类型断言时的安全考虑，毕竟毫无根据的断言是非常危险的。\n\n综上所述：\n\n- 联合类型可以被断言为其中一个类型\n- 父类可以被断言为子类\n- 任何类型都可以被断言为 any\n- any 可以被断言为任何类型\n- 要使得 `A` 能够被断言为 `B`，只需要 `A` 兼容 `B` 或 `B` 兼容 `A` 即可\n\n其实前四种情况都是最后一个的特例。\n\n## 双重断言\n\n既然：\n\n- 任何类型都可以被断言为 any\n- any 可以被断言为任何类型\n\n那么我们是不是可以使用双重断言 `as any as Foo` 来将任何一个类型断言为任何另一个类型呢？\n\n```ts\ninterface Cat {\n    run(): void;\n}\ninterface Fish {\n    swim(): void;\n}\n\nfunction testCat(cat: Cat) {\n    return (cat as any as Fish);\n}\n```\n\n在上面的例子中，若直接使用 `cat as Fish` 肯定会报错，因为 `Cat` 和 `Fish` 互相都不兼容。\n\n但是若使用双重断言，则可以打破「要使得 `A` 能够被断言为 `B`，只需要 `A` 兼容 `B` 或 `B` 兼容 `A` 即可」的限制，将任何一个类型断言为任何另一个类型。\n\n若你使用了这种双重断言，那么十有八九是非常错误的，它很可能会导致运行时错误。\n\n**除非迫不得已，千万别用双重断言。**\n\n## 类型断言VS类型转换\n\n类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除：\n\n```ts\nfunction toBoolean(something: any): boolean {\n    return something as boolean;\n}\n\ntoBoolean(1);\n// 返回值为 1\n```\n\n在上面的例子中，将 `something` 断言为 `boolean` 虽然可以通过编译，但是并没有什么用，代码在编译后会变成：\n\n```js\nfunction toBoolean(something) {\n    return something;\n}\n\ntoBoolean(1);\n// 返回值为 1\n```\n\n所以类型断言不是类型转换，它不会真的影响到变量的类型。\n\n若要进行类型转换，需要直接调用类型转换的方法：\n\n```ts\nfunction toBoolean(something: any): boolean {\n    return Boolean(something);\n}\n\ntoBoolean(1);\n// 返回值为 true\n```\n\n## 类型断言 vs 类型声明\n\n在这个例子中：\n\n```ts\nfunction getCacheData(key: string): any {\n    return (window as any).cache[key];\n}\n\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst tom = getCacheData('tom') as Cat;\ntom.run();\n```\n\n我们使用 `as Cat` 将 `any` 类型断言为了 `Cat` 类型。\n\n但实际上还有其他方式可以解决这个问题：\n\n```ts\nfunction getCacheData(key: string): any {\n    return (window as any).cache[key];\n}\n\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst tom: Cat = getCacheData('tom');\ntom.run();\n```\n\n上面的例子中，我们通过类型声明的方式，将 `tom` 声明为 `Cat`，然后再将 `any` 类型的 `getCacheData('tom')` 赋值给 `Cat` 类型的 `tom`。\n\n这和类型断言是非常相似的，而且产生的结果也几乎是一样的——`tom` 在接下来的代码中都变成了 `Cat` 类型。\n\n它们的区别，可以通过这个例子来理解：\n\n```ts\ninterface Animal {\n    name: string;\n}\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst animal: Animal = {\n    name: 'tom'\n};\nlet tom = animal as Cat;\n```\n\n在上面的例子中，由于 `Animal` 兼容 `Cat`，故可以将 `animal` 断言为 `Cat` 赋值给 `tom`。\n\n但是若直接声明 `tom` 为 `Cat` 类型：\n\n```ts\ninterface Animal {\n    name: string;\n}\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst animal: Animal = {\n    name: 'tom'\n};\nlet tom: Cat = animal;\n\n// index.ts:12:5 - error TS2741: Property 'run' is missing in type 'Animal' but required in type 'Cat'.\n```\n\n则会报错，不允许将 `animal` 赋值为 `Cat` 类型的 `tom`。\n\n这很容易理解，`Animal` 可以看作是 `Cat` 的父类，当然不能将父类的实例赋值给类型为子类的变量。\n\n深入的讲，它们的核心区别就在于：\n\n- `animal` 断言为 `Cat`，只需要满足 `Animal` 兼容 `Cat` 或 `Cat` 兼容 `Animal` 即可\n- `animal` 赋值给 `tom`，需要满足 `Cat` 兼容 `Animal` 才行\n\n但是 `Cat` 并不兼容 `Animal`。\n\n而在前一个例子中，由于 `getCacheData('tom')` 是 `any` 类型，`any` 兼容 `Cat`，`Cat` 也兼容 `any`，故\n\n```ts\nconst tom = getCacheData('tom') as Cat;\n```\n\n等价于\n\n```ts\nconst tom: Cat = getCacheData('tom');\n```\n\n知道了它们的核心区别，就知道了类型声明是比类型断言更加严格的。\n\n所以为了增加代码的质量，我们最好优先使用类型声明，这也比类型断言的 `as` 语法更加优雅。\n\n## 类型断言 vs 泛型\n\n> 本小节的前置知识点：[泛型](/post/typescript/进阶/泛型)\n\n还是这个例子：\n\n```ts\nfunction getCacheData(key: string): any {\n    return (window as any).cache[key];\n}\n\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst tom = getCacheData('tom') as Cat;\ntom.run();\n```\n\n我们还有第三种方式可以解决这个问题，那就是泛型：\n\n```ts\nfunction getCacheData<T>(key: string): T {\n    return (window as any).cache[key];\n}\n\ninterface Cat {\n    name: string;\n    run(): void;\n}\n\nconst tom = getCacheData<Cat>('tom');\ntom.run();\n```\n\n通过给 `getCacheData` 函数添加了一个泛型 `<T>`，我们可以更加规范的实现对 `getCacheData` 返回值的约束，这也同时去除掉了代码中的 `any`，是最优的一个解决方案。\n\n## 参考[§](https://ts.xcatliu.com/basics/type-assertion.html#参考)\n\n- [TypeScript Deep Dive / Type Assertion](https://basarat.gitbooks.io/typescript/content/docs/types/type-assertion.html)\n- [Advanced Types # Type Guards and Differentiating Types](http://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types)（[中文版](https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced Types.html#类型保护与区分类型（type-guards-and-differentiating-types）)）\n- [TypeScript 的设计理念](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals)","slug":"typescript/基础/类型断言","published":1,"date":"2023-01-06T07:14:23.135Z","updated":"2023-01-09T08:01:24.690Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcq06l0t0038ysvndyyh5z4f","content":"<h1 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h1><h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">值 as 类型 \n&#x2F;&#x2F; 或者\n&lt;类型&gt;值</code></pre>\n\n<h2 id=\"类型断言的用途\"><a href=\"#类型断言的用途\" class=\"headerlink\" title=\"类型断言的用途\"></a>类型断言的用途</h2><p>类型断言的常见用途有以下几种</p>\n<h3 id=\"将一个联合类型断言为其中一种\"><a href=\"#将一个联合类型断言为其中一种\" class=\"headerlink\" title=\"将一个联合类型断言为其中一种\"></a>将一个联合类型断言为其中一种</h3><p><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B#%E8%AE%BF%E9%97%AE%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E6%88%96%E6%96%B9%E6%B3%95\">之前提到过</a>，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型中共有的属性或方法</strong>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Cat &#123;\n    name: &#39;mimi;&#39;\n    cry(): void;\n&#125;\n\ninterface Dog &#123;\n    name: &#39;来福&#39;\n    cay(): void;\n&#125;\n\nfunction (fun: Cat | Dog) &#123;\n    return Cat.name\n&#125;</code></pre>\n\n<p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法，比如：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Cat &#123;\n    name: &#39;mimi;&#39;\n    cry(): void;\n&#125;\n\ninterface Dog &#123;\n    name: &#39;来福&#39;\n    run(): void;\n&#125;\n\nfunction (fun: Cat | Dog): boolean &#123;\n    if (typeof fun.cry &#x3D;&#x3D; &#39;function&#39;) return true\n    return false\n&#125;\n&#x2F;&#x2F; index.ts:11:23 - error TS2339: Property &#39;cry&#39; does not exist on type &#39;Cat | Dog&#39;.\n&#x2F;&#x2F;   Property &#39;cry&#39; does not exist on type &#39;Cat&#39;.</code></pre>\n\n<p>上面的例子中，获取 <code>animal.swim</code> 的时候会报错。</p>\n<p>此时可以使用类型断言，将 <code>animal</code> 断言成 <code>Fish</code>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Cat &#123;\n    name: &#39;mimi;&#39;\n    cry(): void;\n&#125;\n\ninterface Dog &#123;\n    name: &#39;来福&#39;\n    run(): void;\n&#125;\n\nfunction (fun: Cat | Dog): boolean &#123;\n    if (typeof (fun.cry as Cat) &#x3D;&#x3D; &#39;function&#39;) return true\n    return false\n&#125;</code></pre>\n\n<p>这样就可以解决访问 <code>animal.swim</code> 时报错的问题了。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误：</p>\n\n</div>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Cat &#123;\n    name: &#39;mimi;&#39;\n    cry(): void;\n&#125;\n\ninterface Dog &#123;\n    name: &#39;来福&#39;\n    run(): void;\n&#125;\n\nfunction dosth (fun: Cat | Dog): boolean &#123;\n    if (typeof (fun.cry as Cat) &#x3D;&#x3D; &#39;function&#39;) return true\n    return false\n&#125;\n\nconst jeck: Dog &#x3D; &#123;\n    name: &#39;哼哈&#39;,\n    run() &#123; console.log(&#39;run&#39;) &#125;\n&#125;\n\ndosth(jeck)\n&#x2F;&#x2F; Uncaught TypeError: fun.cry is not a function&#96;</code></pre>\n\n<p>报错的原因是因为 <code>(fun.cry as Cat)</code> 隐藏了<code>fun</code>为<code>Dog</code>的可能性, 直接将<code>fun</code>断言为了<code>Cat</code>而<code>Cat</code>类型里就没有<code>run</code>方法, 就会导致运行时错误了。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>总之，使用类型断言时一定要格外小心，尽量避免断言后调用方法或引用深层属性，以减少不必要的运行时错误。</p></blockquote>\n<h3 id=\"将一个父类断言为更具体的子类\"><a href=\"#将一个父类断言为更具体的子类\" class=\"headerlink\" title=\"将一个父类断言为更具体的子类\"></a>将一个父类断言为更具体的子类</h3><p>当类之间有继承关系的时候, 类型断言也是很常见的</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class ApiError extends Error &#123;\n    code: number &#x3D; 0\n&#125;\n\nclass HttpError extends Error &#123;\n    statuscode: number &#x3D; 200\n&#125;\n\nfunction isHttpError (error: Error) &#123;\n    if (typeof (error as HttpError).statuscode &#x3D; &#39;number&#39;) return true\n    return false\n&#125;</code></pre>\n\n<p>上面的例子中，我们声明了函数 <code>isHttpError</code>，它用来判断传入的参数是不是 <code>HttpError</code> 类型，为了实现这样一个函数，它的参数的类型肯定得是比<code>ApiError</code>和<code>HttpError</code>更抽象的父类 <code>Error</code>，这样的话这个函数就能接受 <code>Error</code> 或它的子类作为参数了。</p>\n<p>但是由于父类 <code>Error</code> 中没有 <code>statuscode</code> 属性，故直接获取 <code>error.statuscode</code> 会报错，需要使用类型断言获取 <code>(error as HttpError).code</code>。</p>\n<p>大家可能会注意到，在这个例子中有一个更合适的方式来判断是不是 <code>HttpError</code>，那就是使用 <code>instanceof</code>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class ApiError extends Error &#123;\n    code: number &#x3D; 0\n&#125;\n\nclass HttpError extends Error &#123;\n    statuscode: number &#x3D; 200\n&#125;\n\nfunction isHttpError (error: Error) &#123;\n    if (error instanceof HttpError) return true\n    return false\n&#125;</code></pre>\n\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>上面的例子中，确实使用 <code>instanceof</code> 更加合适，因为 <code>HttpError</code> 是一个 JavaScript 的类，能够通过 <code>instanceof</code> 来判断 <code>error</code> 是否是它的实例。</p>\n<p>但是有的情况下 <code>ApiError</code> 和 <code>HttpError</code> 不是一个真正的类，而只是一个 TypeScript 的接口（<code>interface</code>），接口是一个类型，不是一个真正的值，它在编译结果中会被删除，当然就无法使用 <code>instanceof</code> 来做运行时判断了</p>\n</p>\n</div>\n<p>此时就只能用类型断言，通过判断是否存在 <code>code</code> 属性，来判断传入的参数是不是 <code>ApiError</code> 了：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface ApiError extends Error &#123;\n    code: number;\n&#125;\ninterface HttpError extends Error &#123;\n    statusCode: number;\n&#125;\n\nfunction isApiError(error: Error) &#123;\n    if (typeof (error as ApiError).code &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;\n        return true;\n    &#125;\n    return false;\n&#125;</code></pre>\n\n<h3 id=\"将任何一个类型断言为\"><a href=\"#将任何一个类型断言为\" class=\"headerlink\" title=\"将任何一个类型断言为\"></a>将任何一个类型断言为</h3><p>理想情况下，TypeScript 的类型系统运转良好，每个值的类型都具体而精确。</p>\n<p>当我们引用一个在此类型上不存在的属性或方法时，就会报错：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const foo: number &#x3D; 1;\nfoo.length &#x3D; 1;\n\n&#x2F;&#x2F; index.ts:2:5 - error TS2339: Property &#39;length&#39; does not exist on type &#39;number&#39;.</code></pre>\n\n<p>上面的例子中，数字类型的变量 <code>foo</code> 上是没有 <code>length</code> 属性的，故 TypeScript 给出了相应的错误提示。</p>\n<p>这种错误提示显然是非常有用的。</p>\n<p>但有的时候，我们非常确定这段代码不会出错，比如下面这个例子：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">window.foo &#x3D; 1;\n\n&#x2F;&#x2F; index.ts:1:8 - error TS2339: Property &#39;foo&#39; does not exist on type &#39;Window &amp; typeof globalThis&#39;.</code></pre>\n\n<p>上面的例子中，我们需要将 <code>window</code> 上添加一个属性 <code>foo</code>，但 TypeScript 编译时会报错，提示我们 <code>window</code> 上不存在 <code>foo</code> 属性。</p>\n<p>此时我们可以使用 <code>as any</code> 临时将 <code>window</code> 断言为 <code>any</code> 类型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">(window as any).foo &#x3D; 1;</code></pre>\n\n<p>在 <code>any</code> 类型的变量上，访问任何属性都是允许的。</p>\n<p>需要注意的是，将一个变量断言为 <code>any</code> 可以说是解决 TypeScript 中类型问题的最后一个手段。</p>\n<p><strong>它极有可能掩盖了真正的类型错误，所以如果不是非常确定，就不要使用 <code>as any</code>。</strong></p>\n<p>上面的例子中，我们也可以通过[扩展 window 的类型（TODO）][]解决这个错误，不过如果只是临时的增加 <code>foo</code> 属性，<code>as any</code> 会更加方便。</p>\n<p>总之，<strong>一方面不能滥用 <code>as any</code>，另一方面也不要完全否定它的作用，我们需要在类型的严格性和开发的便利性之间掌握平衡</strong>（这也是 <a href=\"https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals\">TypeScript 的设计理念</a>之一），才能发挥出 TypeScript 最大的价值。</p>\n<h3 id=\"将-any-断言为一个具体的类型\"><a href=\"#将-any-断言为一个具体的类型\" class=\"headerlink\" title=\"将 any 断言为一个具体的类型\"></a>将 <code>any</code> 断言为一个具体的类型</h3><p>在日常的开发中，我们不可避免的需要处理 <code>any</code> 类型的变量，它们可能是由于第三方库未能定义好自己的类型，也有可能是历史遗留的或其他人编写的烂代码，还可能是受到 TypeScript 类型系统的限制而无法精确定义类型的场景。</p>\n<p>遇到 <code>any</code> 类型的变量时，我们可以选择无视它，任由它滋生更多的 <code>any</code>。</p>\n<p>我们也可以选择改进它，通过类型断言及时的把 <code>any</code> 断言为精确的类型，亡羊补牢，使我们的代码向着高可维护性的目标发展。</p>\n<p>举例来说，历史遗留的代码中有个 <code>getCacheData</code>，它的返回值是 <code>any</code>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getCacheData(key: string): any &#123;\n    return (window as any).cache[key];\n&#125;</code></pre>\n\n<p>那么我们在使用它时，最好能够将调用了它之后的返回值断言成一个精确的类型，这样就方便了后续的操作：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getCacheData(key: string): any &#123;\n    return (window as any).cache[key];\n&#125;\n\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst tom &#x3D; getCacheData(&#39;tom&#39;) as Cat;\ntom.run();</code></pre>\n\n<p>上面的例子中，我们调用完 <code>getCacheData</code> 之后，立即将它断言为 <code>Cat</code> 类型。这样的话明确了 <code>tom</code> 的类型，后续对 <code>tom</code> 的访问时就有了代码补全，提高了代码的可维护性。</p>\n<h2 id=\"类型断言的限制\"><a href=\"#类型断言的限制\" class=\"headerlink\" title=\"类型断言的限制\"></a>类型断言的限制</h2><p>从上面的例子中，我们可以总结出：</p>\n<ul>\n<li>联合类型可以被断言为其中一个类型</li>\n<li>父类可以被断言为子类</li>\n<li>任何类型都可以被断言为 any</li>\n<li>any 可以被断言为任何类型</li>\n</ul>\n<p>那么类型断言有没有什么限制呢？是不是任何一个类型都可以被断言为任何另一个类型呢？</p>\n<p>答案是否定的——并不是任何一个类型都可以被断言为任何另一个类型。</p>\n<p>具体来说，若 <code>A</code> 兼容 <code>B</code>，那么 <code>A</code> 能够被断言为 <code>B</code>，<code>B</code> 也能被断言为 <code>A</code>。</p>\n<p>下面我们通过一个简化的例子，来理解类型断言的限制：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n    name: string;\n&#125;\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nlet tom: Cat &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    run: () &#x3D;&gt; &#123; console.log(&#39;run&#39;) &#125;\n&#125;;\nlet animal: Animal &#x3D; tom;</code></pre>\n\n<p>我们知道，TypeScript 是结构类型系统，类型之间的对比只会比较它们最终的结构，而会忽略它们定义时的关系。</p>\n<p>在上面的例子中，<code>Cat</code> 包含了 <code>Animal</code> 中的所有属性，除此之外，它还有一个额外的方法 <code>run</code>。TypeScript 并不关心 <code>Cat</code> 和 <code>Animal</code> 之间定义时是什么关系，而只会看它们最终的结构有什么关系——所以它与 <code>Cat extends Animal</code> 是等价的：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n    name: string;\n&#125;\ninterface Cat extends Animal &#123;\n    run(): void;\n&#125;</code></pre>\n\n<p>那么也不难理解为什么 <code>Cat</code> 类型的 <code>tom</code> 可以赋值给 <code>Animal</code> 类型的 <code>animal</code> 了——就像面向对象编程中我们可以将子类的实例赋值给类型为父类的变量。</p>\n<p>我们把它换成 TypeScript 中更专业的说法，即：<code>Animal</code> 兼容 <code>Cat</code>。</p>\n<p>当 <code>Animal</code> 兼容 <code>Cat</code> 时，它们就可以互相进行类型断言了：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n    name: string;\n&#125;\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nfunction testAnimal(animal: Animal) &#123;\n    return (animal as Cat);\n&#125;\nfunction testCat(cat: Cat) &#123;\n    return (cat as Animal);\n&#125;</code></pre>\n\n<p>这样的设计其实也很容易就能理解：</p>\n<ul>\n<li>允许 <code>animal as Cat</code> 是因为「父类可以被断言为子类」，这个前面已经学习过了</li>\n<li>允许 <code>cat as Animal</code> 是因为既然子类拥有父类的属性和方法，那么被断言为父类，获取父类的属性、调用父类的方法，就不会有任何问题，故「子类可以被断言为父类」</li>\n</ul>\n<p>需要注意的是，这里我们使用了简化的父类子类的关系来表达类型的兼容性，而实际上 TypeScript 在判断类型的兼容性时，比这种情况复杂很多，详细请参考[类型的兼容性（TODO)][]章节。</p>\n<p>总之，若 <code>A</code> 兼容 <code>B</code>，那么 <code>A</code> 能够被断言为 <code>B</code>，<code>B</code> 也能被断言为 <code>A</code>。</p>\n<p>同理，若 <code>B</code> 兼容 <code>A</code>，那么 <code>A</code> 能够被断言为 <code>B</code>，<code>B</code> 也能被断言为 <code>A</code>。</p>\n<p>所以这也可以换一种说法：</p>\n<p>要使得 <code>A</code> 能够被断言为 <code>B</code>，只需要 <code>A</code> 兼容 <code>B</code> 或 <code>B</code> 兼容 <code>A</code> 即可，这也是为了在类型断言时的安全考虑，毕竟毫无根据的断言是非常危险的。</p>\n<p>综上所述：</p>\n<ul>\n<li>联合类型可以被断言为其中一个类型</li>\n<li>父类可以被断言为子类</li>\n<li>任何类型都可以被断言为 any</li>\n<li>any 可以被断言为任何类型</li>\n<li>要使得 <code>A</code> 能够被断言为 <code>B</code>，只需要 <code>A</code> 兼容 <code>B</code> 或 <code>B</code> 兼容 <code>A</code> 即可</li>\n</ul>\n<p>其实前四种情况都是最后一个的特例。</p>\n<h2 id=\"双重断言\"><a href=\"#双重断言\" class=\"headerlink\" title=\"双重断言\"></a>双重断言</h2><p>既然：</p>\n<ul>\n<li>任何类型都可以被断言为 any</li>\n<li>any 可以被断言为任何类型</li>\n</ul>\n<p>那么我们是不是可以使用双重断言 <code>as any as Foo</code> 来将任何一个类型断言为任何另一个类型呢？</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Cat &#123;\n    run(): void;\n&#125;\ninterface Fish &#123;\n    swim(): void;\n&#125;\n\nfunction testCat(cat: Cat) &#123;\n    return (cat as any as Fish);\n&#125;</code></pre>\n\n<p>在上面的例子中，若直接使用 <code>cat as Fish</code> 肯定会报错，因为 <code>Cat</code> 和 <code>Fish</code> 互相都不兼容。</p>\n<p>但是若使用双重断言，则可以打破「要使得 <code>A</code> 能够被断言为 <code>B</code>，只需要 <code>A</code> 兼容 <code>B</code> 或 <code>B</code> 兼容 <code>A</code> 即可」的限制，将任何一个类型断言为任何另一个类型。</p>\n<p>若你使用了这种双重断言，那么十有八九是非常错误的，它很可能会导致运行时错误。</p>\n<p><strong>除非迫不得已，千万别用双重断言。</strong></p>\n<h2 id=\"类型断言VS类型转换\"><a href=\"#类型断言VS类型转换\" class=\"headerlink\" title=\"类型断言VS类型转换\"></a>类型断言VS类型转换</h2><p>类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function toBoolean(something: any): boolean &#123;\n    return something as boolean;\n&#125;\n\ntoBoolean(1);\n&#x2F;&#x2F; 返回值为 1</code></pre>\n\n<p>在上面的例子中，将 <code>something</code> 断言为 <code>boolean</code> 虽然可以通过编译，但是并没有什么用，代码在编译后会变成：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function toBoolean(something) &#123;\n    return something;\n&#125;\n\ntoBoolean(1);\n&#x2F;&#x2F; 返回值为 1</code></pre>\n\n<p>所以类型断言不是类型转换，它不会真的影响到变量的类型。</p>\n<p>若要进行类型转换，需要直接调用类型转换的方法：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function toBoolean(something: any): boolean &#123;\n    return Boolean(something);\n&#125;\n\ntoBoolean(1);\n&#x2F;&#x2F; 返回值为 true</code></pre>\n\n<h2 id=\"类型断言-vs-类型声明\"><a href=\"#类型断言-vs-类型声明\" class=\"headerlink\" title=\"类型断言 vs 类型声明\"></a>类型断言 vs 类型声明</h2><p>在这个例子中：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getCacheData(key: string): any &#123;\n    return (window as any).cache[key];\n&#125;\n\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst tom &#x3D; getCacheData(&#39;tom&#39;) as Cat;\ntom.run();</code></pre>\n\n<p>我们使用 <code>as Cat</code> 将 <code>any</code> 类型断言为了 <code>Cat</code> 类型。</p>\n<p>但实际上还有其他方式可以解决这个问题：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getCacheData(key: string): any &#123;\n    return (window as any).cache[key];\n&#125;\n\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst tom: Cat &#x3D; getCacheData(&#39;tom&#39;);\ntom.run();</code></pre>\n\n<p>上面的例子中，我们通过类型声明的方式，将 <code>tom</code> 声明为 <code>Cat</code>，然后再将 <code>any</code> 类型的 <code>getCacheData(&#39;tom&#39;)</code> 赋值给 <code>Cat</code> 类型的 <code>tom</code>。</p>\n<p>这和类型断言是非常相似的，而且产生的结果也几乎是一样的——<code>tom</code> 在接下来的代码中都变成了 <code>Cat</code> 类型。</p>\n<p>它们的区别，可以通过这个例子来理解：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n    name: string;\n&#125;\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst animal: Animal &#x3D; &#123;\n    name: &#39;tom&#39;\n&#125;;\nlet tom &#x3D; animal as Cat;</code></pre>\n\n<p>在上面的例子中，由于 <code>Animal</code> 兼容 <code>Cat</code>，故可以将 <code>animal</code> 断言为 <code>Cat</code> 赋值给 <code>tom</code>。</p>\n<p>但是若直接声明 <code>tom</code> 为 <code>Cat</code> 类型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n    name: string;\n&#125;\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst animal: Animal &#x3D; &#123;\n    name: &#39;tom&#39;\n&#125;;\nlet tom: Cat &#x3D; animal;\n\n&#x2F;&#x2F; index.ts:12:5 - error TS2741: Property &#39;run&#39; is missing in type &#39;Animal&#39; but required in type &#39;Cat&#39;.</code></pre>\n\n<p>则会报错，不允许将 <code>animal</code> 赋值为 <code>Cat</code> 类型的 <code>tom</code>。</p>\n<p>这很容易理解，<code>Animal</code> 可以看作是 <code>Cat</code> 的父类，当然不能将父类的实例赋值给类型为子类的变量。</p>\n<p>深入的讲，它们的核心区别就在于：</p>\n<ul>\n<li><code>animal</code> 断言为 <code>Cat</code>，只需要满足 <code>Animal</code> 兼容 <code>Cat</code> 或 <code>Cat</code> 兼容 <code>Animal</code> 即可</li>\n<li><code>animal</code> 赋值给 <code>tom</code>，需要满足 <code>Cat</code> 兼容 <code>Animal</code> 才行</li>\n</ul>\n<p>但是 <code>Cat</code> 并不兼容 <code>Animal</code>。</p>\n<p>而在前一个例子中，由于 <code>getCacheData(&#39;tom&#39;)</code> 是 <code>any</code> 类型，<code>any</code> 兼容 <code>Cat</code>，<code>Cat</code> 也兼容 <code>any</code>，故</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const tom &#x3D; getCacheData(&#39;tom&#39;) as Cat;</code></pre>\n\n<p>等价于</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const tom: Cat &#x3D; getCacheData(&#39;tom&#39;);</code></pre>\n\n<p>知道了它们的核心区别，就知道了类型声明是比类型断言更加严格的。</p>\n<p>所以为了增加代码的质量，我们最好优先使用类型声明，这也比类型断言的 <code>as</code> 语法更加优雅。</p>\n<h2 id=\"类型断言-vs-泛型\"><a href=\"#类型断言-vs-泛型\" class=\"headerlink\" title=\"类型断言 vs 泛型\"></a>类型断言 vs 泛型</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>本小节的前置知识点：<a href=\"/post/typescript/%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B\">泛型</a></p></blockquote>\n<p>还是这个例子：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getCacheData(key: string): any &#123;\n    return (window as any).cache[key];\n&#125;\n\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst tom &#x3D; getCacheData(&#39;tom&#39;) as Cat;\ntom.run();</code></pre>\n\n<p>我们还有第三种方式可以解决这个问题，那就是泛型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getCacheData&lt;T&gt;(key: string): T &#123;\n    return (window as any).cache[key];\n&#125;\n\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst tom &#x3D; getCacheData&lt;Cat&gt;(&#39;tom&#39;);\ntom.run();</code></pre>\n\n<p>通过给 <code>getCacheData</code> 函数添加了一个泛型 <code>&lt;T&gt;</code>，我们可以更加规范的实现对 <code>getCacheData</code> 返回值的约束，这也同时去除掉了代码中的 <code>any</code>，是最优的一个解决方案。</p>\n<h2 id=\"参考§\"><a href=\"#参考§\" class=\"headerlink\" title=\"参考§\"></a>参考<a href=\"https://ts.xcatliu.com/basics/type-assertion.html#%E5%8F%82%E8%80%83\">§</a></h2><ul>\n<li><a href=\"https://basarat.gitbooks.io/typescript/content/docs/types/type-assertion.html\">TypeScript Deep Dive / Type Assertion</a></li>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types\">Advanced Types # Type Guards and Differentiating Types</a>（[中文版](<a href=\"https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced\">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced</a> Types.html#类型保护与区分类型（type-guards-and-differentiating-types）)）</li>\n<li><a href=\"https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals\">TypeScript 的设计理念</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h1><h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">值 as 类型 \n&#x2F;&#x2F; 或者\n&lt;类型&gt;值</code></pre>\n\n<h2 id=\"类型断言的用途\"><a href=\"#类型断言的用途\" class=\"headerlink\" title=\"类型断言的用途\"></a>类型断言的用途</h2><p>类型断言的常见用途有以下几种</p>\n<h3 id=\"将一个联合类型断言为其中一种\"><a href=\"#将一个联合类型断言为其中一种\" class=\"headerlink\" title=\"将一个联合类型断言为其中一种\"></a>将一个联合类型断言为其中一种</h3><p><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B#%E8%AE%BF%E9%97%AE%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E6%88%96%E6%96%B9%E6%B3%95\">之前提到过</a>，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型中共有的属性或方法</strong>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Cat &#123;\n    name: &#39;mimi;&#39;\n    cry(): void;\n&#125;\n\ninterface Dog &#123;\n    name: &#39;来福&#39;\n    cay(): void;\n&#125;\n\nfunction (fun: Cat | Dog) &#123;\n    return Cat.name\n&#125;</code></pre>\n\n<p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法，比如：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Cat &#123;\n    name: &#39;mimi;&#39;\n    cry(): void;\n&#125;\n\ninterface Dog &#123;\n    name: &#39;来福&#39;\n    run(): void;\n&#125;\n\nfunction (fun: Cat | Dog): boolean &#123;\n    if (typeof fun.cry &#x3D;&#x3D; &#39;function&#39;) return true\n    return false\n&#125;\n&#x2F;&#x2F; index.ts:11:23 - error TS2339: Property &#39;cry&#39; does not exist on type &#39;Cat | Dog&#39;.\n&#x2F;&#x2F;   Property &#39;cry&#39; does not exist on type &#39;Cat&#39;.</code></pre>\n\n<p>上面的例子中，获取 <code>animal.swim</code> 的时候会报错。</p>\n<p>此时可以使用类型断言，将 <code>animal</code> 断言成 <code>Fish</code>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Cat &#123;\n    name: &#39;mimi;&#39;\n    cry(): void;\n&#125;\n\ninterface Dog &#123;\n    name: &#39;来福&#39;\n    run(): void;\n&#125;\n\nfunction (fun: Cat | Dog): boolean &#123;\n    if (typeof (fun.cry as Cat) &#x3D;&#x3D; &#39;function&#39;) return true\n    return false\n&#125;</code></pre>\n\n<p>这样就可以解决访问 <code>animal.swim</code> 时报错的问题了。</p>\n<p>:::tip</p>\n<p>需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误：</p>\n<p>:::</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Cat &#123;\n    name: &#39;mimi;&#39;\n    cry(): void;\n&#125;\n\ninterface Dog &#123;\n    name: &#39;来福&#39;\n    run(): void;\n&#125;\n\nfunction dosth (fun: Cat | Dog): boolean &#123;\n    if (typeof (fun.cry as Cat) &#x3D;&#x3D; &#39;function&#39;) return true\n    return false\n&#125;\n\nconst jeck: Dog &#x3D; &#123;\n    name: &#39;哼哈&#39;,\n    run() &#123; console.log(&#39;run&#39;) &#125;\n&#125;\n\ndosth(jeck)\n&#x2F;&#x2F; Uncaught TypeError: fun.cry is not a function&#96;</code></pre>\n\n<p>报错的原因是因为 <code>(fun.cry as Cat)</code> 隐藏了<code>fun</code>为<code>Dog</code>的可能性, 直接将<code>fun</code>断言为了<code>Cat</code>而<code>Cat</code>类型里就没有<code>run</code>方法, 就会导致运行时错误了。</p>\n<blockquote>\n<p>总之，使用类型断言时一定要格外小心，尽量避免断言后调用方法或引用深层属性，以减少不必要的运行时错误。</p>\n</blockquote>\n<h3 id=\"将一个父类断言为更具体的子类\"><a href=\"#将一个父类断言为更具体的子类\" class=\"headerlink\" title=\"将一个父类断言为更具体的子类\"></a>将一个父类断言为更具体的子类</h3><p>当类之间有继承关系的时候, 类型断言也是很常见的</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class ApiError extends Error &#123;\n    code: number &#x3D; 0\n&#125;\n\nclass HttpError extends Error &#123;\n    statuscode: number &#x3D; 200\n&#125;\n\nfunction isHttpError (error: Error) &#123;\n    if (typeof (error as HttpError).statuscode &#x3D; &#39;number&#39;) return true\n    return false\n&#125;</code></pre>\n\n<p>上面的例子中，我们声明了函数 <code>isHttpError</code>，它用来判断传入的参数是不是 <code>HttpError</code> 类型，为了实现这样一个函数，它的参数的类型肯定得是比<code>ApiError</code>和<code>HttpError</code>更抽象的父类 <code>Error</code>，这样的话这个函数就能接受 <code>Error</code> 或它的子类作为参数了。</p>\n<p>但是由于父类 <code>Error</code> 中没有 <code>statuscode</code> 属性，故直接获取 <code>error.statuscode</code> 会报错，需要使用类型断言获取 <code>(error as HttpError).code</code>。</p>\n<p>大家可能会注意到，在这个例子中有一个更合适的方式来判断是不是 <code>HttpError</code>，那就是使用 <code>instanceof</code>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class ApiError extends Error &#123;\n    code: number &#x3D; 0\n&#125;\n\nclass HttpError extends Error &#123;\n    statuscode: number &#x3D; 200\n&#125;\n\nfunction isHttpError (error: Error) &#123;\n    if (error instanceof HttpError) return true\n    return false\n&#125;</code></pre>\n\n<p>:::tip</p>\n<p>上面的例子中，确实使用 <code>instanceof</code> 更加合适，因为 <code>HttpError</code> 是一个 JavaScript 的类，能够通过 <code>instanceof</code> 来判断 <code>error</code> 是否是它的实例。</p>\n<p>但是有的情况下 <code>ApiError</code> 和 <code>HttpError</code> 不是一个真正的类，而只是一个 TypeScript 的接口（<code>interface</code>），接口是一个类型，不是一个真正的值，它在编译结果中会被删除，当然就无法使用 <code>instanceof</code> 来做运行时判断了</p>\n<p>:::</p>\n<p>此时就只能用类型断言，通过判断是否存在 <code>code</code> 属性，来判断传入的参数是不是 <code>ApiError</code> 了：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface ApiError extends Error &#123;\n    code: number;\n&#125;\ninterface HttpError extends Error &#123;\n    statusCode: number;\n&#125;\n\nfunction isApiError(error: Error) &#123;\n    if (typeof (error as ApiError).code &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;\n        return true;\n    &#125;\n    return false;\n&#125;</code></pre>\n\n<h3 id=\"将任何一个类型断言为\"><a href=\"#将任何一个类型断言为\" class=\"headerlink\" title=\"将任何一个类型断言为\"></a>将任何一个类型断言为</h3><p>理想情况下，TypeScript 的类型系统运转良好，每个值的类型都具体而精确。</p>\n<p>当我们引用一个在此类型上不存在的属性或方法时，就会报错：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const foo: number &#x3D; 1;\nfoo.length &#x3D; 1;\n\n&#x2F;&#x2F; index.ts:2:5 - error TS2339: Property &#39;length&#39; does not exist on type &#39;number&#39;.</code></pre>\n\n<p>上面的例子中，数字类型的变量 <code>foo</code> 上是没有 <code>length</code> 属性的，故 TypeScript 给出了相应的错误提示。</p>\n<p>这种错误提示显然是非常有用的。</p>\n<p>但有的时候，我们非常确定这段代码不会出错，比如下面这个例子：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">window.foo &#x3D; 1;\n\n&#x2F;&#x2F; index.ts:1:8 - error TS2339: Property &#39;foo&#39; does not exist on type &#39;Window &amp; typeof globalThis&#39;.</code></pre>\n\n<p>上面的例子中，我们需要将 <code>window</code> 上添加一个属性 <code>foo</code>，但 TypeScript 编译时会报错，提示我们 <code>window</code> 上不存在 <code>foo</code> 属性。</p>\n<p>此时我们可以使用 <code>as any</code> 临时将 <code>window</code> 断言为 <code>any</code> 类型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">(window as any).foo &#x3D; 1;</code></pre>\n\n<p>在 <code>any</code> 类型的变量上，访问任何属性都是允许的。</p>\n<p>需要注意的是，将一个变量断言为 <code>any</code> 可以说是解决 TypeScript 中类型问题的最后一个手段。</p>\n<p><strong>它极有可能掩盖了真正的类型错误，所以如果不是非常确定，就不要使用 <code>as any</code>。</strong></p>\n<p>上面的例子中，我们也可以通过[扩展 window 的类型（TODO）][]解决这个错误，不过如果只是临时的增加 <code>foo</code> 属性，<code>as any</code> 会更加方便。</p>\n<p>总之，<strong>一方面不能滥用 <code>as any</code>，另一方面也不要完全否定它的作用，我们需要在类型的严格性和开发的便利性之间掌握平衡</strong>（这也是 <a href=\"https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals\">TypeScript 的设计理念</a>之一），才能发挥出 TypeScript 最大的价值。</p>\n<h3 id=\"将-any-断言为一个具体的类型\"><a href=\"#将-any-断言为一个具体的类型\" class=\"headerlink\" title=\"将 any 断言为一个具体的类型\"></a>将 <code>any</code> 断言为一个具体的类型</h3><p>在日常的开发中，我们不可避免的需要处理 <code>any</code> 类型的变量，它们可能是由于第三方库未能定义好自己的类型，也有可能是历史遗留的或其他人编写的烂代码，还可能是受到 TypeScript 类型系统的限制而无法精确定义类型的场景。</p>\n<p>遇到 <code>any</code> 类型的变量时，我们可以选择无视它，任由它滋生更多的 <code>any</code>。</p>\n<p>我们也可以选择改进它，通过类型断言及时的把 <code>any</code> 断言为精确的类型，亡羊补牢，使我们的代码向着高可维护性的目标发展。</p>\n<p>举例来说，历史遗留的代码中有个 <code>getCacheData</code>，它的返回值是 <code>any</code>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getCacheData(key: string): any &#123;\n    return (window as any).cache[key];\n&#125;</code></pre>\n\n<p>那么我们在使用它时，最好能够将调用了它之后的返回值断言成一个精确的类型，这样就方便了后续的操作：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getCacheData(key: string): any &#123;\n    return (window as any).cache[key];\n&#125;\n\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst tom &#x3D; getCacheData(&#39;tom&#39;) as Cat;\ntom.run();</code></pre>\n\n<p>上面的例子中，我们调用完 <code>getCacheData</code> 之后，立即将它断言为 <code>Cat</code> 类型。这样的话明确了 <code>tom</code> 的类型，后续对 <code>tom</code> 的访问时就有了代码补全，提高了代码的可维护性。</p>\n<h2 id=\"类型断言的限制\"><a href=\"#类型断言的限制\" class=\"headerlink\" title=\"类型断言的限制\"></a>类型断言的限制</h2><p>从上面的例子中，我们可以总结出：</p>\n<ul>\n<li>联合类型可以被断言为其中一个类型</li>\n<li>父类可以被断言为子类</li>\n<li>任何类型都可以被断言为 any</li>\n<li>any 可以被断言为任何类型</li>\n</ul>\n<p>那么类型断言有没有什么限制呢？是不是任何一个类型都可以被断言为任何另一个类型呢？</p>\n<p>答案是否定的——并不是任何一个类型都可以被断言为任何另一个类型。</p>\n<p>具体来说，若 <code>A</code> 兼容 <code>B</code>，那么 <code>A</code> 能够被断言为 <code>B</code>，<code>B</code> 也能被断言为 <code>A</code>。</p>\n<p>下面我们通过一个简化的例子，来理解类型断言的限制：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n    name: string;\n&#125;\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nlet tom: Cat &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    run: () &#x3D;&gt; &#123; console.log(&#39;run&#39;) &#125;\n&#125;;\nlet animal: Animal &#x3D; tom;</code></pre>\n\n<p>我们知道，TypeScript 是结构类型系统，类型之间的对比只会比较它们最终的结构，而会忽略它们定义时的关系。</p>\n<p>在上面的例子中，<code>Cat</code> 包含了 <code>Animal</code> 中的所有属性，除此之外，它还有一个额外的方法 <code>run</code>。TypeScript 并不关心 <code>Cat</code> 和 <code>Animal</code> 之间定义时是什么关系，而只会看它们最终的结构有什么关系——所以它与 <code>Cat extends Animal</code> 是等价的：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n    name: string;\n&#125;\ninterface Cat extends Animal &#123;\n    run(): void;\n&#125;</code></pre>\n\n<p>那么也不难理解为什么 <code>Cat</code> 类型的 <code>tom</code> 可以赋值给 <code>Animal</code> 类型的 <code>animal</code> 了——就像面向对象编程中我们可以将子类的实例赋值给类型为父类的变量。</p>\n<p>我们把它换成 TypeScript 中更专业的说法，即：<code>Animal</code> 兼容 <code>Cat</code>。</p>\n<p>当 <code>Animal</code> 兼容 <code>Cat</code> 时，它们就可以互相进行类型断言了：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n    name: string;\n&#125;\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nfunction testAnimal(animal: Animal) &#123;\n    return (animal as Cat);\n&#125;\nfunction testCat(cat: Cat) &#123;\n    return (cat as Animal);\n&#125;</code></pre>\n\n<p>这样的设计其实也很容易就能理解：</p>\n<ul>\n<li>允许 <code>animal as Cat</code> 是因为「父类可以被断言为子类」，这个前面已经学习过了</li>\n<li>允许 <code>cat as Animal</code> 是因为既然子类拥有父类的属性和方法，那么被断言为父类，获取父类的属性、调用父类的方法，就不会有任何问题，故「子类可以被断言为父类」</li>\n</ul>\n<p>需要注意的是，这里我们使用了简化的父类子类的关系来表达类型的兼容性，而实际上 TypeScript 在判断类型的兼容性时，比这种情况复杂很多，详细请参考[类型的兼容性（TODO)][]章节。</p>\n<p>总之，若 <code>A</code> 兼容 <code>B</code>，那么 <code>A</code> 能够被断言为 <code>B</code>，<code>B</code> 也能被断言为 <code>A</code>。</p>\n<p>同理，若 <code>B</code> 兼容 <code>A</code>，那么 <code>A</code> 能够被断言为 <code>B</code>，<code>B</code> 也能被断言为 <code>A</code>。</p>\n<p>所以这也可以换一种说法：</p>\n<p>要使得 <code>A</code> 能够被断言为 <code>B</code>，只需要 <code>A</code> 兼容 <code>B</code> 或 <code>B</code> 兼容 <code>A</code> 即可，这也是为了在类型断言时的安全考虑，毕竟毫无根据的断言是非常危险的。</p>\n<p>综上所述：</p>\n<ul>\n<li>联合类型可以被断言为其中一个类型</li>\n<li>父类可以被断言为子类</li>\n<li>任何类型都可以被断言为 any</li>\n<li>any 可以被断言为任何类型</li>\n<li>要使得 <code>A</code> 能够被断言为 <code>B</code>，只需要 <code>A</code> 兼容 <code>B</code> 或 <code>B</code> 兼容 <code>A</code> 即可</li>\n</ul>\n<p>其实前四种情况都是最后一个的特例。</p>\n<h2 id=\"双重断言\"><a href=\"#双重断言\" class=\"headerlink\" title=\"双重断言\"></a>双重断言</h2><p>既然：</p>\n<ul>\n<li>任何类型都可以被断言为 any</li>\n<li>any 可以被断言为任何类型</li>\n</ul>\n<p>那么我们是不是可以使用双重断言 <code>as any as Foo</code> 来将任何一个类型断言为任何另一个类型呢？</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Cat &#123;\n    run(): void;\n&#125;\ninterface Fish &#123;\n    swim(): void;\n&#125;\n\nfunction testCat(cat: Cat) &#123;\n    return (cat as any as Fish);\n&#125;</code></pre>\n\n<p>在上面的例子中，若直接使用 <code>cat as Fish</code> 肯定会报错，因为 <code>Cat</code> 和 <code>Fish</code> 互相都不兼容。</p>\n<p>但是若使用双重断言，则可以打破「要使得 <code>A</code> 能够被断言为 <code>B</code>，只需要 <code>A</code> 兼容 <code>B</code> 或 <code>B</code> 兼容 <code>A</code> 即可」的限制，将任何一个类型断言为任何另一个类型。</p>\n<p>若你使用了这种双重断言，那么十有八九是非常错误的，它很可能会导致运行时错误。</p>\n<p><strong>除非迫不得已，千万别用双重断言。</strong></p>\n<h2 id=\"类型断言VS类型转换\"><a href=\"#类型断言VS类型转换\" class=\"headerlink\" title=\"类型断言VS类型转换\"></a>类型断言VS类型转换</h2><p>类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function toBoolean(something: any): boolean &#123;\n    return something as boolean;\n&#125;\n\ntoBoolean(1);\n&#x2F;&#x2F; 返回值为 1</code></pre>\n\n<p>在上面的例子中，将 <code>something</code> 断言为 <code>boolean</code> 虽然可以通过编译，但是并没有什么用，代码在编译后会变成：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function toBoolean(something) &#123;\n    return something;\n&#125;\n\ntoBoolean(1);\n&#x2F;&#x2F; 返回值为 1</code></pre>\n\n<p>所以类型断言不是类型转换，它不会真的影响到变量的类型。</p>\n<p>若要进行类型转换，需要直接调用类型转换的方法：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function toBoolean(something: any): boolean &#123;\n    return Boolean(something);\n&#125;\n\ntoBoolean(1);\n&#x2F;&#x2F; 返回值为 true</code></pre>\n\n<h2 id=\"类型断言-vs-类型声明\"><a href=\"#类型断言-vs-类型声明\" class=\"headerlink\" title=\"类型断言 vs 类型声明\"></a>类型断言 vs 类型声明</h2><p>在这个例子中：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getCacheData(key: string): any &#123;\n    return (window as any).cache[key];\n&#125;\n\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst tom &#x3D; getCacheData(&#39;tom&#39;) as Cat;\ntom.run();</code></pre>\n\n<p>我们使用 <code>as Cat</code> 将 <code>any</code> 类型断言为了 <code>Cat</code> 类型。</p>\n<p>但实际上还有其他方式可以解决这个问题：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getCacheData(key: string): any &#123;\n    return (window as any).cache[key];\n&#125;\n\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst tom: Cat &#x3D; getCacheData(&#39;tom&#39;);\ntom.run();</code></pre>\n\n<p>上面的例子中，我们通过类型声明的方式，将 <code>tom</code> 声明为 <code>Cat</code>，然后再将 <code>any</code> 类型的 <code>getCacheData(&#39;tom&#39;)</code> 赋值给 <code>Cat</code> 类型的 <code>tom</code>。</p>\n<p>这和类型断言是非常相似的，而且产生的结果也几乎是一样的——<code>tom</code> 在接下来的代码中都变成了 <code>Cat</code> 类型。</p>\n<p>它们的区别，可以通过这个例子来理解：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n    name: string;\n&#125;\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst animal: Animal &#x3D; &#123;\n    name: &#39;tom&#39;\n&#125;;\nlet tom &#x3D; animal as Cat;</code></pre>\n\n<p>在上面的例子中，由于 <code>Animal</code> 兼容 <code>Cat</code>，故可以将 <code>animal</code> 断言为 <code>Cat</code> 赋值给 <code>tom</code>。</p>\n<p>但是若直接声明 <code>tom</code> 为 <code>Cat</code> 类型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n    name: string;\n&#125;\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst animal: Animal &#x3D; &#123;\n    name: &#39;tom&#39;\n&#125;;\nlet tom: Cat &#x3D; animal;\n\n&#x2F;&#x2F; index.ts:12:5 - error TS2741: Property &#39;run&#39; is missing in type &#39;Animal&#39; but required in type &#39;Cat&#39;.</code></pre>\n\n<p>则会报错，不允许将 <code>animal</code> 赋值为 <code>Cat</code> 类型的 <code>tom</code>。</p>\n<p>这很容易理解，<code>Animal</code> 可以看作是 <code>Cat</code> 的父类，当然不能将父类的实例赋值给类型为子类的变量。</p>\n<p>深入的讲，它们的核心区别就在于：</p>\n<ul>\n<li><code>animal</code> 断言为 <code>Cat</code>，只需要满足 <code>Animal</code> 兼容 <code>Cat</code> 或 <code>Cat</code> 兼容 <code>Animal</code> 即可</li>\n<li><code>animal</code> 赋值给 <code>tom</code>，需要满足 <code>Cat</code> 兼容 <code>Animal</code> 才行</li>\n</ul>\n<p>但是 <code>Cat</code> 并不兼容 <code>Animal</code>。</p>\n<p>而在前一个例子中，由于 <code>getCacheData(&#39;tom&#39;)</code> 是 <code>any</code> 类型，<code>any</code> 兼容 <code>Cat</code>，<code>Cat</code> 也兼容 <code>any</code>，故</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const tom &#x3D; getCacheData(&#39;tom&#39;) as Cat;</code></pre>\n\n<p>等价于</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const tom: Cat &#x3D; getCacheData(&#39;tom&#39;);</code></pre>\n\n<p>知道了它们的核心区别，就知道了类型声明是比类型断言更加严格的。</p>\n<p>所以为了增加代码的质量，我们最好优先使用类型声明，这也比类型断言的 <code>as</code> 语法更加优雅。</p>\n<h2 id=\"类型断言-vs-泛型\"><a href=\"#类型断言-vs-泛型\" class=\"headerlink\" title=\"类型断言 vs 泛型\"></a>类型断言 vs 泛型</h2><blockquote>\n<p>本小节的前置知识点：<a href=\"/post/typescript/%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B\">泛型</a></p>\n</blockquote>\n<p>还是这个例子：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getCacheData(key: string): any &#123;\n    return (window as any).cache[key];\n&#125;\n\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst tom &#x3D; getCacheData(&#39;tom&#39;) as Cat;\ntom.run();</code></pre>\n\n<p>我们还有第三种方式可以解决这个问题，那就是泛型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getCacheData&lt;T&gt;(key: string): T &#123;\n    return (window as any).cache[key];\n&#125;\n\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst tom &#x3D; getCacheData&lt;Cat&gt;(&#39;tom&#39;);\ntom.run();</code></pre>\n\n<p>通过给 <code>getCacheData</code> 函数添加了一个泛型 <code>&lt;T&gt;</code>，我们可以更加规范的实现对 <code>getCacheData</code> 返回值的约束，这也同时去除掉了代码中的 <code>any</code>，是最优的一个解决方案。</p>\n<h2 id=\"参考§\"><a href=\"#参考§\" class=\"headerlink\" title=\"参考§\"></a>参考<a href=\"https://ts.xcatliu.com/basics/type-assertion.html#%E5%8F%82%E8%80%83\">§</a></h2><ul>\n<li><a href=\"https://basarat.gitbooks.io/typescript/content/docs/types/type-assertion.html\">TypeScript Deep Dive / Type Assertion</a></li>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types\">Advanced Types # Type Guards and Differentiating Types</a>（[中文版](<a href=\"https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced\">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced</a> Types.html#类型保护与区分类型（type-guards-and-differentiating-types）)）</li>\n<li><a href=\"https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals\">TypeScript 的设计理念</a></li>\n</ul>\n"},{"title":"基础 - 类型推论","cover":"https://whitelabelcoders.com/app/uploads/18.jpg","_content":"\n# 类型推论\n\n如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。\n\n## 什么是类型推论\n\n以下代码虽然没有指定类型，但是会在编译的时候报错:\n\n```TypeScript\nlet myFavoriteNumber = 'seven';\nmyFavoriteNumber = 7;\n\n// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'\n```\n\n事实上，它等价于：\n\n```TypeScript\nlet myFavoriteNumber: string = 'seven';\nmyFavoriteNumber = 7;\n\n// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.\n```\n\nTypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。\n\n**如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：**\n\n```TypeScript\nlet myFavoriteNumber;\nmyFavoriteNumber = 'seven';\nmyFavoriteNumber = 7;\n```\n\n## 参考\n\n- [Type Interface](https://www.typescriptlang.org/docs/handbook/type-inference.html)","source":"_posts/typescript/基础/类型推论.md","raw":"---\ntitle: 基础 - 类型推论\ncover: https://whitelabelcoders.com/app/uploads/18.jpg\ncategories:\n  - TypeScript入门\ntags:\n  - TypeScript\n  - 基础\n---\n\n# 类型推论\n\n如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。\n\n## 什么是类型推论\n\n以下代码虽然没有指定类型，但是会在编译的时候报错:\n\n```TypeScript\nlet myFavoriteNumber = 'seven';\nmyFavoriteNumber = 7;\n\n// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'\n```\n\n事实上，它等价于：\n\n```TypeScript\nlet myFavoriteNumber: string = 'seven';\nmyFavoriteNumber = 7;\n\n// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.\n```\n\nTypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。\n\n**如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：**\n\n```TypeScript\nlet myFavoriteNumber;\nmyFavoriteNumber = 'seven';\nmyFavoriteNumber = 7;\n```\n\n## 参考\n\n- [Type Interface](https://www.typescriptlang.org/docs/handbook/type-inference.html)","slug":"typescript/基础/类型推论","published":1,"date":"2023-01-05T07:51:40.501Z","updated":"2023-01-05T08:04:38.377Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcq06l0x0039ysvn6pf0e2tb","content":"<h1 id=\"类型推论\"><a href=\"#类型推论\" class=\"headerlink\" title=\"类型推论\"></a>类型推论</h1><p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</p>\n<h2 id=\"什么是类型推论\"><a href=\"#什么是类型推论\" class=\"headerlink\" title=\"什么是类型推论\"></a>什么是类型推论</h2><p>以下代码虽然没有指定类型，但是会在编译的时候报错:</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;</code></pre>\n\n<p>事实上，它等价于：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: string &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre>\n\n<p>TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。</p>\n<p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：</strong></p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber;\nmyFavoriteNumber &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/type-inference.html\">Type Interface</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"类型推论\"><a href=\"#类型推论\" class=\"headerlink\" title=\"类型推论\"></a>类型推论</h1><p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</p>\n<h2 id=\"什么是类型推论\"><a href=\"#什么是类型推论\" class=\"headerlink\" title=\"什么是类型推论\"></a>什么是类型推论</h2><p>以下代码虽然没有指定类型，但是会在编译的时候报错:</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;</code></pre>\n\n<p>事实上，它等价于：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: string &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre>\n\n<p>TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。</p>\n<p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：</strong></p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber;\nmyFavoriteNumber &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/type-inference.html\">Type Interface</a></li>\n</ul>\n"},{"title":"基础 - 联合类型","cover":"https://whitelabelcoders.com/app/uploads/18.jpg","_content":"\n# 联合类型\n\n联合类型（Union Types）表示取值可以为多种类型中的一种。\n\n```TypeScript\nlet myFavoriteNumber: string | number;\nmyFavoriteNumber = 'seven';\nmyFavoriteNumber = 7;\n```\n\n```TypeScript\nlet myFavoriteNumber: string | number;\nmyFavoriteNumber = true;\n\n// index.ts(2,1): error TS2322: Type 'boolean' is not assignable to type 'string | number'.\n//   Type 'boolean' is not assignable to type 'number'.\n```\n\n:::tip\n联合类型使用 `|` 分隔每个类型。\n\n这里的 `let myFavoriteNumber: string | number` 的含义是，允许 `myFavoriteNumber` 的类型是 `string` 或者 `number`，但是不能是其他类型。\n:::\n\n## 访问联合类型的属性或方法\n\n当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们**只能访问此联合类型的所有类型里共有的属性或方法：**\n\n```TypeScript\nfunction getLength(something: string | number): number {\n    return something.length;\n}\n\n// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.\n//   Property 'length' does not exist on type 'number'.\n```\n\n上例中，`length` 不是 `string` 和 `number` 的共有属性，所以会报错。\n\n访问 `string` 和 `number` 的共有属性是没问题的：\n\n```TypeScript\nfunction getString(something: string | number): string {\n    return something.toString();\n}\n```\n\n联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：\n\n```TypeScript\nlet myFavoriteNumber: string | number;\nmyFavoriteNumber = 'seven';\nconsole.log(myFavoriteNumber.length); // 5\nmyFavoriteNumber = 7;\nconsole.log(myFavoriteNumber.length); // 编译时报错\n\n// index.ts(5,30): error TS2339: Property 'length' does not exist on type 'number'.\n```\n\n## 参考\n\n- [Advanced Types # Union Types](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html)","source":"_posts/typescript/基础/联合类型.md","raw":"---\ntitle: 基础 - 联合类型\ncover: https://whitelabelcoders.com/app/uploads/18.jpg\ncategories:\n  - TypeScript入门\ntags:\n  - TypeScript\n  - 类型\n---\n\n# 联合类型\n\n联合类型（Union Types）表示取值可以为多种类型中的一种。\n\n```TypeScript\nlet myFavoriteNumber: string | number;\nmyFavoriteNumber = 'seven';\nmyFavoriteNumber = 7;\n```\n\n```TypeScript\nlet myFavoriteNumber: string | number;\nmyFavoriteNumber = true;\n\n// index.ts(2,1): error TS2322: Type 'boolean' is not assignable to type 'string | number'.\n//   Type 'boolean' is not assignable to type 'number'.\n```\n\n:::tip\n联合类型使用 `|` 分隔每个类型。\n\n这里的 `let myFavoriteNumber: string | number` 的含义是，允许 `myFavoriteNumber` 的类型是 `string` 或者 `number`，但是不能是其他类型。\n:::\n\n## 访问联合类型的属性或方法\n\n当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们**只能访问此联合类型的所有类型里共有的属性或方法：**\n\n```TypeScript\nfunction getLength(something: string | number): number {\n    return something.length;\n}\n\n// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.\n//   Property 'length' does not exist on type 'number'.\n```\n\n上例中，`length` 不是 `string` 和 `number` 的共有属性，所以会报错。\n\n访问 `string` 和 `number` 的共有属性是没问题的：\n\n```TypeScript\nfunction getString(something: string | number): string {\n    return something.toString();\n}\n```\n\n联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：\n\n```TypeScript\nlet myFavoriteNumber: string | number;\nmyFavoriteNumber = 'seven';\nconsole.log(myFavoriteNumber.length); // 5\nmyFavoriteNumber = 7;\nconsole.log(myFavoriteNumber.length); // 编译时报错\n\n// index.ts(5,30): error TS2339: Property 'length' does not exist on type 'number'.\n```\n\n## 参考\n\n- [Advanced Types # Union Types](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html)","slug":"typescript/基础/联合类型","published":1,"date":"2023-01-05T08:05:08.103Z","updated":"2023-01-05T08:12:00.078Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcq06l0y003bysvn9a1g3yq9","content":"<h1 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h1><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: string | number;\nmyFavoriteNumber &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;</code></pre>\n\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: string | number;\nmyFavoriteNumber &#x3D; true;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;boolean&#39; is not assignable to type &#39;string | number&#39;.\n&#x2F;&#x2F;   Type &#39;boolean&#39; is not assignable to type &#39;number&#39;.</code></pre>\n\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>联合类型使用 <code>|</code> 分隔每个类型。</p>\n<p>这里的 <code>let myFavoriteNumber: string | number</code> 的含义是，允许 <code>myFavoriteNumber</code> 的类型是 <code>string</code> 或者 <code>number</code>，但是不能是其他类型。</p>\n</div>\n<h2 id=\"访问联合类型的属性或方法\"><a href=\"#访问联合类型的属性或方法\" class=\"headerlink\" title=\"访问联合类型的属性或方法\"></a>访问联合类型的属性或方法</h2><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法：</strong></p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function getLength(something: string | number): number &#123;\n    return something.length;\n&#125;\n\n&#x2F;&#x2F; index.ts(2,22): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.\n&#x2F;&#x2F;   Property &#39;length&#39; does not exist on type &#39;number&#39;.</code></pre>\n\n<p>上例中，<code>length</code> 不是 <code>string</code> 和 <code>number</code> 的共有属性，所以会报错。</p>\n<p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function getString(something: string | number): string &#123;\n    return something.toString();\n&#125;</code></pre>\n\n<p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: string | number;\nmyFavoriteNumber &#x3D; &#39;seven&#39;;\nconsole.log(myFavoriteNumber.length); &#x2F;&#x2F; 5\nmyFavoriteNumber &#x3D; 7;\nconsole.log(myFavoriteNumber.length); &#x2F;&#x2F; 编译时报错\n\n&#x2F;&#x2F; index.ts(5,30): error TS2339: Property &#39;length&#39; does not exist on type &#39;number&#39;.</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/2/types-from-types.html\">Advanced Types # Union Types</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h1><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: string | number;\nmyFavoriteNumber &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;</code></pre>\n\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: string | number;\nmyFavoriteNumber &#x3D; true;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;boolean&#39; is not assignable to type &#39;string | number&#39;.\n&#x2F;&#x2F;   Type &#39;boolean&#39; is not assignable to type &#39;number&#39;.</code></pre>\n\n<p>:::tip<br>联合类型使用 <code>|</code> 分隔每个类型。</p>\n<p>这里的 <code>let myFavoriteNumber: string | number</code> 的含义是，允许 <code>myFavoriteNumber</code> 的类型是 <code>string</code> 或者 <code>number</code>，但是不能是其他类型。<br>:::</p>\n<h2 id=\"访问联合类型的属性或方法\"><a href=\"#访问联合类型的属性或方法\" class=\"headerlink\" title=\"访问联合类型的属性或方法\"></a>访问联合类型的属性或方法</h2><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法：</strong></p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function getLength(something: string | number): number &#123;\n    return something.length;\n&#125;\n\n&#x2F;&#x2F; index.ts(2,22): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.\n&#x2F;&#x2F;   Property &#39;length&#39; does not exist on type &#39;number&#39;.</code></pre>\n\n<p>上例中，<code>length</code> 不是 <code>string</code> 和 <code>number</code> 的共有属性，所以会报错。</p>\n<p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function getString(something: string | number): string &#123;\n    return something.toString();\n&#125;</code></pre>\n\n<p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: string | number;\nmyFavoriteNumber &#x3D; &#39;seven&#39;;\nconsole.log(myFavoriteNumber.length); &#x2F;&#x2F; 5\nmyFavoriteNumber &#x3D; 7;\nconsole.log(myFavoriteNumber.length); &#x2F;&#x2F; 编译时报错\n\n&#x2F;&#x2F; index.ts(5,30): error TS2339: Property &#39;length&#39; does not exist on type &#39;number&#39;.</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/2/types-from-types.html\">Advanced Types # Union Types</a></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clcq06kzf0001ysvn36dbgrdh","category_id":"clcq06kzk0003ysvnd6mphrcg","_id":"clcq06kzw000cysvn7ufb1fqk"},{"post_id":"clcq06kzi0002ysvnhld427pd","category_id":"clcq06kzs0008ysvnbywh97cl","_id":"clcq06l01000kysvn3h3l43qp"},{"post_id":"clcq06kzm0005ysvngzauef60","category_id":"clcq06kzs0008ysvnbywh97cl","_id":"clcq06l04000pysvncz80cwvy"},{"post_id":"clcq06kzo0006ysvn9tuxe2aa","category_id":"clcq06kzs0008ysvnbywh97cl","_id":"clcq06l06000tysvn5wsd0xm5"},{"post_id":"clcq06kzr0007ysvn5lv5ccfs","category_id":"clcq06l03000oysvn1lzy1qf8","_id":"clcq06l080010ysvn01o8g9to"},{"post_id":"clcq06kzu000aysvnf5zlgsp1","category_id":"clcq06l03000oysvn1lzy1qf8","_id":"clcq06l0a0015ysvnc2td646x"},{"post_id":"clcq06kzw000bysvn7omiglxy","category_id":"clcq06l03000oysvn1lzy1qf8","_id":"clcq06l0a0017ysvn9w4b8nef"},{"post_id":"clcq06kzy000fysvn8irn91de","category_id":"clcq06l0a0014ysvnfrp6a12m","_id":"clcq06l0c001cysvn7euz755k"},{"post_id":"clcq06l00000hysvn81ok7q96","category_id":"clcq06l0a0014ysvnfrp6a12m","_id":"clcq06l0d001hysvnccvhb5qk"},{"post_id":"clcq06l01000mysvnavml8xpq","category_id":"clcq06l0a0014ysvnfrp6a12m","_id":"clcq06l0f001kysvn74tthdff"},{"post_id":"clcq06l03000nysvn1hzx18y9","category_id":"clcq06l0a0014ysvnfrp6a12m","_id":"clcq06l0g001oysvn3z3y3r07"},{"post_id":"clcq06l04000rysvnat714gbw","category_id":"clcq06l0a0014ysvnfrp6a12m","_id":"clcq06l0g001tysvn3l0qc3cx"},{"post_id":"clcq06l05000sysvn5flfe7tj","category_id":"clcq06l0a0014ysvnfrp6a12m","_id":"clcq06l0h001xysvnhqsrclkr"},{"post_id":"clcq06l07000vysvnhd9h6svl","category_id":"clcq06l0a0014ysvnfrp6a12m","_id":"clcq06l0h0020ysvngd5ie3zu"},{"post_id":"clcq06l08000yysvn58b119zy","category_id":"clcq06l0a0014ysvnfrp6a12m","_id":"clcq06l0i0022ysvng9rg5iy5"},{"post_id":"clcq06l0t0038ysvndyyh5z4f","category_id":"clcq06l0a0014ysvnfrp6a12m","_id":"clcq06l10003dysvn2oae415b"},{"post_id":"clcq06l0x0039ysvn6pf0e2tb","category_id":"clcq06l0a0014ysvnfrp6a12m","_id":"clcq06l10003fysvn67g358fo"},{"post_id":"clcq06l0y003bysvn9a1g3yq9","category_id":"clcq06l0a0014ysvnfrp6a12m","_id":"clcq06l11003hysvncima5g6c"}],"PostTag":[{"post_id":"clcq06kzf0001ysvn36dbgrdh","tag_id":"clcq06kzl0004ysvn0u5138te","_id":"clcq06kzz000gysvngjbud3zo"},{"post_id":"clcq06kzf0001ysvn36dbgrdh","tag_id":"clcq06kzs0009ysvn5sc29z6p","_id":"clcq06l00000iysvnb13ocl7k"},{"post_id":"clcq06kzi0002ysvnhld427pd","tag_id":"clcq06kzx000eysvn68mleu6w","_id":"clcq06l08000xysvnatxza90q"},{"post_id":"clcq06kzi0002ysvnhld427pd","tag_id":"clcq06l01000lysvn0mjn0781","_id":"clcq06l090011ysvnhcoxhks9"},{"post_id":"clcq06kzi0002ysvnhld427pd","tag_id":"clcq06l04000qysvn4yte0s96","_id":"clcq06l090013ysvng85qf22r"},{"post_id":"clcq06kzm0005ysvngzauef60","tag_id":"clcq06kzx000eysvn68mleu6w","_id":"clcq06l0b001aysvn2vmw73t0"},{"post_id":"clcq06kzm0005ysvngzauef60","tag_id":"clcq06l01000lysvn0mjn0781","_id":"clcq06l0c001dysvnhlsg5k0w"},{"post_id":"clcq06kzm0005ysvngzauef60","tag_id":"clcq06l04000qysvn4yte0s96","_id":"clcq06l0c001fysvn5962gdui"},{"post_id":"clcq06kzo0006ysvn9tuxe2aa","tag_id":"clcq06kzx000eysvn68mleu6w","_id":"clcq06l0f001mysvndl5ecesa"},{"post_id":"clcq06kzo0006ysvn9tuxe2aa","tag_id":"clcq06kzs0009ysvn5sc29z6p","_id":"clcq06l0g001pysvnhopyhkgk"},{"post_id":"clcq06kzo0006ysvn9tuxe2aa","tag_id":"clcq06l0d001iysvnbnzl543p","_id":"clcq06l0g001rysvn135i49xc"},{"post_id":"clcq06kzr0007ysvn5lv5ccfs","tag_id":"clcq06l0f001lysvn5egugzsx","_id":"clcq06l0h001vysvn2g5m992k"},{"post_id":"clcq06kzr0007ysvn5lv5ccfs","tag_id":"clcq06l0g001qysvn893ye2g7","_id":"clcq06l0h001yysvn7ckq51rl"},{"post_id":"clcq06kzu000aysvnf5zlgsp1","tag_id":"clcq06l0f001lysvn5egugzsx","_id":"clcq06l0i0023ysvnfmuh20tm"},{"post_id":"clcq06kzu000aysvnf5zlgsp1","tag_id":"clcq06l0h001zysvnc2aza95r","_id":"clcq06l0i0024ysvnds579pmf"},{"post_id":"clcq06kzw000bysvn7omiglxy","tag_id":"clcq06l0f001lysvn5egugzsx","_id":"clcq06l0j0028ysvn24xs72ak"},{"post_id":"clcq06kzw000bysvn7omiglxy","tag_id":"clcq06l0i0025ysvn14jufs83","_id":"clcq06l0j0029ysvndjon4q9z"},{"post_id":"clcq06kzw000bysvn7omiglxy","tag_id":"clcq06l0i0026ysvn1p06fx69","_id":"clcq06l0j002bysvne3hrf5i2"},{"post_id":"clcq06kzy000fysvn8irn91de","tag_id":"clcq06l0f001lysvn5egugzsx","_id":"clcq06l0k002dysvn0h57ah12"},{"post_id":"clcq06kzy000fysvn8irn91de","tag_id":"clcq06l0j002aysvn96v2311x","_id":"clcq06l0k002eysvn2jdihprs"},{"post_id":"clcq06l00000hysvn81ok7q96","tag_id":"clcq06l0f001lysvn5egugzsx","_id":"clcq06l0l002iysvn9je784tu"},{"post_id":"clcq06l00000hysvn81ok7q96","tag_id":"clcq06l0k002fysvn2voqdghb","_id":"clcq06l0l002jysvn35j5fems"},{"post_id":"clcq06l00000hysvn81ok7q96","tag_id":"clcq06l0k002gysvnh3wuc0o9","_id":"clcq06l0l002lysvnao0q0vp1"},{"post_id":"clcq06l01000mysvnavml8xpq","tag_id":"clcq06l0f001lysvn5egugzsx","_id":"clcq06l0m002nysvne86ha4we"},{"post_id":"clcq06l01000mysvnavml8xpq","tag_id":"clcq06l0j002aysvn96v2311x","_id":"clcq06l0m002oysvnceow5sb4"},{"post_id":"clcq06l03000nysvn1hzx18y9","tag_id":"clcq06l0f001lysvn5egugzsx","_id":"clcq06l0n002rysvn9oihhmpu"},{"post_id":"clcq06l03000nysvn1hzx18y9","tag_id":"clcq06l0j002aysvn96v2311x","_id":"clcq06l0n002sysvnbkxuc882"},{"post_id":"clcq06l04000rysvnat714gbw","tag_id":"clcq06l0f001lysvn5egugzsx","_id":"clcq06l0o002vysvn5uqjda6f"},{"post_id":"clcq06l04000rysvnat714gbw","tag_id":"clcq06l0j002aysvn96v2311x","_id":"clcq06l0o002wysvn493g3c5t"},{"post_id":"clcq06l05000sysvn5flfe7tj","tag_id":"clcq06l0f001lysvn5egugzsx","_id":"clcq06l0o002yysvn465b4u88"},{"post_id":"clcq06l07000vysvnhd9h6svl","tag_id":"clcq06l0f001lysvn5egugzsx","_id":"clcq06l0p0031ysvnd2zog216"},{"post_id":"clcq06l07000vysvnhd9h6svl","tag_id":"clcq06l0k002fysvn2voqdghb","_id":"clcq06l0p0032ysvn0k8j5lg0"},{"post_id":"clcq06l08000yysvn58b119zy","tag_id":"clcq06l0f001lysvn5egugzsx","_id":"clcq06l0q0035ysvndmcbcjdg"},{"post_id":"clcq06l08000yysvn58b119zy","tag_id":"clcq06l0k002fysvn2voqdghb","_id":"clcq06l0q0036ysvn61o6fggf"},{"post_id":"clcq06l08000yysvn58b119zy","tag_id":"clcq06l0q0034ysvn00yvgs6a","_id":"clcq06l0r0037ysvn9joxe615"},{"post_id":"clcq06l0t0038ysvndyyh5z4f","tag_id":"clcq06l0f001lysvn5egugzsx","_id":"clcq06l0y003aysvn5f7m3lj4"},{"post_id":"clcq06l0t0038ysvndyyh5z4f","tag_id":"clcq06l0j002aysvn96v2311x","_id":"clcq06l0z003cysvn2yzw0lux"},{"post_id":"clcq06l0x0039ysvn6pf0e2tb","tag_id":"clcq06l0f001lysvn5egugzsx","_id":"clcq06l10003eysvn7wsvg8zq"},{"post_id":"clcq06l0x0039ysvn6pf0e2tb","tag_id":"clcq06l0j002aysvn96v2311x","_id":"clcq06l10003gysvnhclq6dzf"},{"post_id":"clcq06l0y003bysvn9a1g3yq9","tag_id":"clcq06l0f001lysvn5egugzsx","_id":"clcq06l11003iysvn9rcsd4tp"},{"post_id":"clcq06l0y003bysvn9a1g3yq9","tag_id":"clcq06l0k002fysvn2voqdghb","_id":"clcq06l11003jysvn6ky37iz2"}],"Tag":[{"name":"Centos","_id":"clcq06kzl0004ysvn0u5138te"},{"name":"镜像","_id":"clcq06kzs0009ysvn5sc29z6p"},{"name":"Docker","_id":"clcq06kzx000eysvn68mleu6w"},{"name":"容器","_id":"clcq06l01000lysvn0mjn0781"},{"name":"container","_id":"clcq06l04000qysvn4yte0s96"},{"name":"images","_id":"clcq06l0d001iysvnbnzl543p"},{"name":"TypeScript","_id":"clcq06l0f001lysvn5egugzsx"},{"name":"tsconfig","_id":"clcq06l0g001qysvn893ye2g7"},{"name":"数据类型","_id":"clcq06l0h001zysvnc2aza95r"},{"name":"环境搭建","_id":"clcq06l0i0025ysvn14jufs83"},{"name":"webpack","_id":"clcq06l0i0026ysvn1p06fx69"},{"name":"基础","_id":"clcq06l0j002aysvn96v2311x"},{"name":"类型","_id":"clcq06l0k002fysvn2voqdghb"},{"name":"函数","_id":"clcq06l0k002gysvnh3wuc0o9"},{"name":"数组","_id":"clcq06l0q0034ysvn00yvgs6a"}]}}