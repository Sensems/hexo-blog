{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-Aurora/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/icons/favicon-16x16.png","path":"icons/favicon-16x16.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/icons/favicon-32x32.png","path":"icons/favicon-32x32.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/404.1a6cd5bd.css","path":"static/css/404.1a6cd5bd.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/about.32dfa3b0.css","path":"static/css/about.32dfa3b0.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/archives.c0d49bd5.css","path":"static/css/archives.c0d49bd5.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/app.0d31776f.css","path":"static/css/app.0d31776f.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/page.749ad047.css","path":"static/css/page.749ad047.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/categories.10e2be12.css","path":"static/css/categories.10e2be12.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/chunk-libs.eebac533.css","path":"static/css/chunk-libs.eebac533.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/result.10e2be12.css","path":"static/css/result.10e2be12.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/post.9f951a60.css","path":"static/css/post.9f951a60.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/tags.10e2be12.css","path":"static/css/tags.10e2be12.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/404.00d640a8.js","path":"static/js/404.00d640a8.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/about.024aacd1.js","path":"static/js/about.024aacd1.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/app.6d2c358d.js","path":"static/js/app.6d2c358d.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/categories.90aa5475.js","path":"static/js/categories.90aa5475.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/img/default-cover.df7c128c.jpg","path":"static/img/default-cover.df7c128c.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/archives.574ac664.js","path":"static/js/archives.574ac664.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/chunk-libs.dc6146cd.js","path":"static/js/chunk-libs.dc6146cd.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/result.39470350.js","path":"static/js/result.39470350.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/page.a02618ad.js","path":"static/js/page.a02618ad.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/tags.2ad613f5.js","path":"static/js/tags.2ad613f5.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/post.cebfbaa4.js","path":"static/js/post.cebfbaa4.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"83c679868a95497228d71a2df4ebbfdabdd1b61c","modified":1672898573616},{"_id":"source/about/index.md","hash":"b2ea07876b524191ee963194c9da39f89dc270f6","modified":1672736543279},{"_id":"source/_posts/typescript/TypeScript的数据类型.md","hash":"dbc0804fed31313b245c7fa52af3c37d7e3ec188","modified":1672736543278},{"_id":"source/_posts/typescript/webpack 搭建 ts 开发环境.md","hash":"22afc784be731b9373410a7819c30dcb4c87f29e","modified":1672736543279},{"_id":"source/_posts/docker/Docker 容器连接.md","hash":"e0df5090709c17423e02f16289001d55a625d064","modified":1672736543277},{"_id":"source/_posts/typescript/tsconfig.json 编译配置.md","hash":"18b84b5c1ec9b429773306d2a7adf3b5bfcc1d26","modified":1672736543279},{"_id":"source/_posts/typescript/基础/函数的类型.md","hash":"c8509ea662fc69c866a9dba21a74a9d1782d94a9","modified":1672984860745},{"_id":"source/_posts/docker/Docker 容器的使用.md","hash":"31e8f72b69f8421e75ae0bae207433d68fb2426a","modified":1672736543277},{"_id":"source/_posts/docker/Docker 镜像的使用.md","hash":"4ce77fa74aaab20d6748cfe98652414d856434a9","modified":1672736543278},{"_id":"source/_posts/typescript/基础/任意值.md","hash":"529aef3cbde49afe13d0d6a0b0a62880dc67ba6c","modified":1672905236019},{"_id":"source/_posts/typescript/基础/基础.md","hash":"e11ad9f327abb91cbb2b6fecc648693180bb6500","modified":1672905246832},{"_id":"source/_posts/typescript/基础/原始数据类型.md","hash":"fe3adc8fba22c5ba44b27cb32ba3c8233de0e4f6","modified":1672905251780},{"_id":"source/_posts/typescript/基础/对象的类型——接口.md","hash":"6e4190a4a910644b4fdf61467649a8b8fffade94","modified":1672911874672},{"_id":"source/_posts/typescript/基础/类型推论.md","hash":"adbf44804e8b0c05c5b9ae62ed8ba8dc29a6bf27","modified":1672905878377},{"_id":"source/_posts/typescript/基础/数组的类型.md","hash":"6ffce96533aeede8c2cfdedffaaf2a99aa6ee63a","modified":1672912864290},{"_id":"node_modules/hexo-theme-Aurora/.browserslistrc","hash":"db215b841182d2af3259a1c1d6e1957bca333970","modified":1672726126472},{"_id":"source/_posts/typescript/基础/联合类型.md","hash":"a907483c4c069ab18b1c4733c9a13bacfe99962e","modified":1672906320078},{"_id":"node_modules/hexo-theme-Aurora/CHANGELOG.md","hash":"e68f3af8af17d326a48e1b317e01d7429193217e","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/LICENSE","hash":"21cf269018b0cf04e1126b6b9b1a5e6af7c5e61f","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/_config.yml","hash":"e6b2335cb393444b8a1fc1ad65331f4a30bc8915","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/package.json","hash":"1b312a6a2de107ba9dc952614f1078c78664a4e4","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/CHANGELOG_CN.md","hash":"5d13c251e8b77fd86870da50f3be98f8822edc66","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/data/cn.yml","hash":"4f5dcc1e2953df7a8e4e683c1a9115f6e0041f5e","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/jest.config.js","hash":"425f08cb718a56630ce61ae0686f35c55ef565df","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/.circleci/config.yml","hash":"534051be311581f69aa8287120275a04539290e4","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/index.js","hash":"2a3c62a860581ee6813ca4bcaa7c952f614e818c","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/README.md","hash":"c50f58b08b75780990c18ab85761e3e24aac0d90","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/data/en.yml","hash":"7bbd6c0da0ae2f93f8a786a3be77fbe4e95a787e","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/favicon.ico","hash":"c39d3ad80489cffed0d3df82c8cb05a049ab39a3","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/filters/index.js","hash":"5eacff9446dd6c9a7eb0a0c84be9187055440454","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/icons/favicon-16x16.png","hash":"849cad2a5ae49fa54c20372f7a21ae95192bafcf","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/category.js","hash":"0ae21ffcf6e471ebfb72ac62a833991fae86ec8a","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/index.js","hash":"dfbb0fdbf990bd67684ed891a4aaa1fd8dcd23f2","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/page.js","hash":"1be54ea9cdf8e293e67bf457075fcdd8a72b8779","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/search.js","hash":"a2a636e1df76efdcaca37226b490afa539ce766b","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/post.js","hash":"76c3268e8b6887fb1fd11c4d71004aad9dc215fc","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/site.js","hash":"b5f5ce813b4b0b322eceb11b036dc65201604256","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/tag.js","hash":"975e79e73d2503a33dbc63655b948100cc46d44f","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/statistic.js","hash":"1c641956e15cec96490de16a88ccc7bec0c9d5c4","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/helpers/mapper.js","hash":"7a99508d910321b90b4afa0df02ad90f62336901","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/helpers/truncate-html.js","hash":"49d4832af027eabe5b8383a24e66dceae761533e","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/helpers/symbols-count-time.js","hash":"d1a81e31b2988edcdf4b4761cec7326a980f097a","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/helpers/toc.js","hash":"5c7348c550ef7f164d492847801a360cdefc60a2","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/helpers/utils.js","hash":"93ff75f0e35a1dc40d5406cc097f5988dd820600","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/injector/index.js","hash":"7ca562ea3af3068ee925b5a8afdce0eaa1e15e64","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/about.32dfa3b0.css","hash":"614ef7c4e52877c76ffddb26192bf8fffddcb8d8","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/404.1a6cd5bd.css","hash":"a7a4d83756520d8f6c410ac0ffe9a45d63868113","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/archives.c0d49bd5.css","hash":"c56213315c57254d0a6e6301ef24c2186fef4d2b","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/page.749ad047.css","hash":"6fcf0e6f3c628954c5f8105791e0e7f3e6512da6","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/chunk-libs.eebac533.css","hash":"41226b6c29aadcc6190fe7c2c4c37464855b8453","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/categories.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/result.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/tags.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/post.9f951a60.css","hash":"8e360582d745d6483fdfc18c46f75897b44721a6","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/icons/favicon-32x32.png","hash":"9dbabf6f4d825da99dcb2e91583755ae8d3b3ff4","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/404.00d640a8.js","hash":"74f1da9e0f953e73e4fe1a6554433f56fdcdf54d","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/layout/index.ejs","hash":"94732830a65b718d2fa506b8598df44f14399fd8","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/about.024aacd1.js","hash":"7ce2b3f7d232dd3b3930ac993bb841452e2cde89","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/categories.90aa5475.js","hash":"0dde3d731fc665962a4c330338a2c663c330be26","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/img/default-cover.df7c128c.jpg","hash":"1934ace0c6f2397d15729f9b08cc4d42e45bf437","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/archives.574ac664.js","hash":"fbb094fb4f7a01bffd6975aca27142935bfdca73","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/result.39470350.js","hash":"f6f5ab2ca7274dad169ec600a419d1a2aeb2347c","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/page.a02618ad.js","hash":"db775fbfbaa1cf8bbf4cc4f2b0a869519d508e3a","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/app.0d31776f.css","hash":"43b43acd76bd8dc22f34cc49c7e026c45c3a5004","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/tags.2ad613f5.js","hash":"4f49139e435788710115fc884dc26a5b1e0d4833","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/post.cebfbaa4.js","hash":"53586f9dab5886a366e9397eb17088e74af5cde1","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/app.6d2c358d.js","hash":"e176c20c22ce36e38935f463977e9b89b281c715","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/chunk-libs.dc6146cd.js","hash":"534266637d09abf39278f4d3a21bd36728740105","modified":1672726126472},{"_id":"public/api/posts/1.json","hash":"5971c871c3795a8788837b3a03513e57fe97e236","modified":1672986069133},{"_id":"public/api/posts/2.json","hash":"aa9f775d27f44793a65117c3bf744fc8f67fcca9","modified":1672986069133},{"_id":"public/api/articles/typescript/基础/函数的类型.json","hash":"3b9f28341eac741d15caf125ab6da4f82ac76aaf","modified":1672986069133},{"_id":"public/api/articles/typescript/基础/数组的类型.json","hash":"291d3c9333a8d34666217a222a13713851103e7c","modified":1672986069133},{"_id":"public/api/articles/typescript/基础/对象的类型——接口.json","hash":"fe60e91d96a7ab60836d9da1d1c468262509d33e","modified":1672986069133},{"_id":"public/api/articles/typescript/基础/联合类型.json","hash":"9edaa83fdba9401f39357141af3591e470d2fb54","modified":1672986069133},{"_id":"public/api/articles/typescript/基础/类型推论.json","hash":"386efcd9a8a17c59e33bb9bc9afa09d4d548ac98","modified":1672986069133},{"_id":"public/api/articles/typescript/基础/任意值.json","hash":"318605c2c31cf02a168b3523edce4d0e8011e5ff","modified":1672986069133},{"_id":"public/api/articles/typescript/基础/基础.json","hash":"a8de0b2a7c43aa0b9c76536575a97377cea0927c","modified":1672986069133},{"_id":"public/api/articles/typescript/基础/原始数据类型.json","hash":"c8c1d9ed8b5e0d19a4b6f2d701436c8d7539dcf6","modified":1672986069133},{"_id":"public/api/articles/docker/Docker 容器连接.json","hash":"1f21f41e19dbb48a42bbf8d3ce13b2e2bec41947","modified":1672986069133},{"_id":"public/api/articles/docker/Docker 镜像的使用.json","hash":"eaf87aef7e3775bd0dd43dcf5268dd02734b57bc","modified":1672986069133},{"_id":"public/api/articles/docker/Docker 容器的使用.json","hash":"5e5f632bf8699eaf690f68b8f2d0448369949890","modified":1672986069133},{"_id":"public/api/articles/typescript/webpack 搭建 ts 开发环境.json","hash":"c76909572533f4761b9155b469a207c767f6ae61","modified":1672986069133},{"_id":"public/api/articles/typescript/TypeScript的数据类型.json","hash":"9429b6a47a6fa5ad5421d0a6947e2ca7ff8cb6a4","modified":1672986069133},{"_id":"public/api/articles/typescript/tsconfig.json 编译配置.json","hash":"3b49e334d5b0765b2e261ff78e244c250d5d6ccc","modified":1672986069133},{"_id":"public/api/features.json","hash":"db5349d70d3bfb1fa459beb74d539cc4267f59e8","modified":1672986069133},{"_id":"public/api/authors/blog-author.json","hash":"74f48ea3edf23e5fe49656439427dd2a083a51c7","modified":1672986069133},{"_id":"public/api/site.json","hash":"09e71a251d26a5a292efc87f64a966f1332959c1","modified":1672986069133},{"_id":"public/api/categories.json","hash":"ce9ff23b823d5c15a59526e9785219ac9ab410ab","modified":1672986069133},{"_id":"public/api/categories/TypeScript.json","hash":"99a585bbd292cc11d11db9ece44c1353d57faa49","modified":1672986069133},{"_id":"public/api/categories/Docker.json","hash":"78846b2377fbb6ceaf618240fb894397ea0cfdee","modified":1672986069133},{"_id":"public/api/categories/TypeScript入门.json","hash":"a8aeb59e2593b09e031e1a3cb8fcf8c366f93262","modified":1672986069133},{"_id":"public/api/tags.json","hash":"9187b3e1a88b9be3035d422a8a6e49649b3b2f61","modified":1672986069133},{"_id":"public/api/tags/TypeScript.json","hash":"28140995614d72195e5074be0d60c7554ef53ef7","modified":1672986069133},{"_id":"public/api/tags/数据类型.json","hash":"2bfd1dd74f1ebd25b002c3ee403514b807790a25","modified":1672986069133},{"_id":"public/api/tags/环境搭建.json","hash":"50fdac0518feae11c4c851e60f450507f816a12b","modified":1672986069133},{"_id":"public/api/tags/webpack.json","hash":"903d564ff80d7757a6917d0834e81433fff8ab5c","modified":1672986069133},{"_id":"public/api/tags/tsconfig.json","hash":"767fc1b95b24073fb405aef68dd8e0c84cc21855","modified":1672986069133},{"_id":"public/api/tags/Docker.json","hash":"78846b2377fbb6ceaf618240fb894397ea0cfdee","modified":1672986069133},{"_id":"public/api/tags/容器.json","hash":"c7f947a3a5e92326dd05d2ae0c473e49ff885889","modified":1672986069133},{"_id":"public/api/tags/container.json","hash":"848ebe23d317d59cff7e684ea69e755dfa0d7349","modified":1672986069133},{"_id":"public/api/tags/镜像.json","hash":"c06fec60460d1e9bb728cacc41c990d605e132ba","modified":1672986069133},{"_id":"public/api/tags/images.json","hash":"0e1c4b87255c2b45afedee39081e9508938e3f00","modified":1672986069133},{"_id":"public/api/tags/基础.json","hash":"a0e6540321ddf11a3ff1cf64f6550f57d833046c","modified":1672986069133},{"_id":"public/api/tags/类型.json","hash":"bdb3ddc546a8ffb3144bea68bd2b7d5a0f488665","modified":1672986069133},{"_id":"public/api/tags/函数.json","hash":"26b5c7544205f5f5fa459055286693b2b20f430e","modified":1672986069133},{"_id":"public/api/tags/数组.json","hash":"a704690afcc19e1fe9b79ebe009ec2ea60166700","modified":1672986069133},{"_id":"public/api/pages/about/index.json","hash":"30874f92cc0dbd6d6a02f1d5f33c3fb8bf0889db","modified":1672986069133},{"_id":"public/api/statistic.json","hash":"4d93ad603103c7be923b6588c08083df31f435e2","modified":1672986069133},{"_id":"public/api/search.json","hash":"1b2aa724d8b2e925263c8d0c2d98fd78037b30a1","modified":1672986069133},{"_id":"public/post/typescript/基础/函数的类型.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672986069133},{"_id":"public/post/typescript/基础/数组的类型.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672986069133},{"_id":"public/post/typescript/基础/对象的类型——接口.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672986069133},{"_id":"public/post/typescript/基础/联合类型.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672986069133},{"_id":"public/post/typescript/基础/类型推论.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672986069133},{"_id":"public/post/typescript/基础/任意值.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672986069133},{"_id":"public/post/typescript/基础/基础.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672986069133},{"_id":"public/post/typescript/基础/原始数据类型.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672986069133},{"_id":"public/post/docker/Docker 镜像的使用.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672986069133},{"_id":"public/post/docker/Docker 容器连接.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672986069133},{"_id":"public/post/docker/Docker 容器的使用.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672986069133},{"_id":"public/post/typescript/webpack 搭建 ts 开发环境.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672986069133},{"_id":"public/index.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672986069133},{"_id":"public/post/typescript/TypeScript的数据类型.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672986069133},{"_id":"public/post/typescript/tsconfig.json 编译配置.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672986069133},{"_id":"public/page/2/index.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672986069133},{"_id":"public/tags/index.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672986069133},{"_id":"public/archives/index.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672986069133},{"_id":"public/page/about/index.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672986069133},{"_id":"public/tags/search/index.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672986069133},{"_id":"public/CNAME","hash":"83c679868a95497228d71a2df4ebbfdabdd1b61c","modified":1672986069133},{"_id":"public/icons/favicon-16x16.png","hash":"849cad2a5ae49fa54c20372f7a21ae95192bafcf","modified":1672986069133},{"_id":"public/favicon.ico","hash":"c39d3ad80489cffed0d3df82c8cb05a049ab39a3","modified":1672986069133},{"_id":"public/icons/favicon-32x32.png","hash":"9dbabf6f4d825da99dcb2e91583755ae8d3b3ff4","modified":1672986069133},{"_id":"public/static/img/default-cover.df7c128c.jpg","hash":"1934ace0c6f2397d15729f9b08cc4d42e45bf437","modified":1672986069133},{"_id":"public/static/css/about.32dfa3b0.css","hash":"614ef7c4e52877c76ffddb26192bf8fffddcb8d8","modified":1672986069133},{"_id":"public/static/css/archives.c0d49bd5.css","hash":"c56213315c57254d0a6e6301ef24c2186fef4d2b","modified":1672986069133},{"_id":"public/static/css/404.1a6cd5bd.css","hash":"a7a4d83756520d8f6c410ac0ffe9a45d63868113","modified":1672986069133},{"_id":"public/static/css/categories.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1672986069133},{"_id":"public/static/css/page.749ad047.css","hash":"6fcf0e6f3c628954c5f8105791e0e7f3e6512da6","modified":1672986069133},{"_id":"public/static/css/chunk-libs.eebac533.css","hash":"41226b6c29aadcc6190fe7c2c4c37464855b8453","modified":1672986069133},{"_id":"public/static/css/result.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1672986069133},{"_id":"public/static/css/post.9f951a60.css","hash":"8e360582d745d6483fdfc18c46f75897b44721a6","modified":1672986069133},{"_id":"public/static/css/tags.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1672986069133},{"_id":"public/static/js/404.00d640a8.js","hash":"74f1da9e0f953e73e4fe1a6554433f56fdcdf54d","modified":1672986069133},{"_id":"public/static/js/about.024aacd1.js","hash":"7ce2b3f7d232dd3b3930ac993bb841452e2cde89","modified":1672986069133},{"_id":"public/static/js/categories.90aa5475.js","hash":"0dde3d731fc665962a4c330338a2c663c330be26","modified":1672986069133},{"_id":"public/static/js/archives.574ac664.js","hash":"fbb094fb4f7a01bffd6975aca27142935bfdca73","modified":1672986069133},{"_id":"public/static/js/result.39470350.js","hash":"f6f5ab2ca7274dad169ec600a419d1a2aeb2347c","modified":1672986069133},{"_id":"public/static/js/page.a02618ad.js","hash":"db775fbfbaa1cf8bbf4cc4f2b0a869519d508e3a","modified":1672986069133},{"_id":"public/static/js/tags.2ad613f5.js","hash":"4f49139e435788710115fc884dc26a5b1e0d4833","modified":1672986069133},{"_id":"public/static/js/post.cebfbaa4.js","hash":"53586f9dab5886a366e9397eb17088e74af5cde1","modified":1672986069133},{"_id":"public/static/css/app.0d31776f.css","hash":"43b43acd76bd8dc22f34cc49c7e026c45c3a5004","modified":1672986069133},{"_id":"public/static/js/app.6d2c358d.js","hash":"e176c20c22ce36e38935f463977e9b89b281c715","modified":1672986069133},{"_id":"public/static/js/chunk-libs.dc6146cd.js","hash":"534266637d09abf39278f4d3a21bd36728740105","modified":1672986069133}],"Category":[{"name":"TypeScript","_id":"clck4pkz300032ovn05ib16cn"},{"name":"Docker","_id":"clck4pkze000i2ovn2ov87gfy"},{"name":"TypeScript入门","_id":"clck4pkzo000y2ovn6k3b0pq8"}],"Data":[],"Page":[{"_content":"### 哈哈哈","source":"about/index.md","raw":"### 哈哈哈","date":"2023-01-03T09:02:23.279Z","updated":"2023-01-03T09:02:23.279Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"clck4pkz000012ovn5nuhewss","content":"<h3 id=\"哈哈哈\"><a href=\"#哈哈哈\" class=\"headerlink\" title=\"哈哈哈\"></a>哈哈哈</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"哈哈哈\"><a href=\"#哈哈哈\" class=\"headerlink\" title=\"哈哈哈\"></a>哈哈哈</h3>"}],"Post":[{"title":"TypeScript的数据类型","date":"2022-03-05T08:47:36.000Z","cover":"https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png","_content":"\n# TypeScript的数据类型\n\n> 变量一但定义了某个数据类型后就不允许赋值其他数据类型的数值了\n\n\n## 基础数据类型\n\n### number\n\n### string\n\n### boolean\n\n### void\n\n### null\n\n### undefinded\n\n### any (使用 TS 时不建议使用 any 类型)\n\n```typescript\n// 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet d; <=> let d: any;\n\n// any 类型还可以赋值给任意类型的变量\nlet s: string;\ns = d // 这时候是成立的\n```\n\n### unknown\n\n```typescript\n// 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet un: unknown;\n\n// any 类型还可以赋值给任意类型的变量\nlet s: string;\ns = un // 这时候是不成立的\n// 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n// unknown 实际上就是一个类型安全的 any\n// unknown 类型的变量不能直接赋值给其他类型的变量,可以间接实现\nif (typeof un === 'string') {\n  s = un; // 由于先进行了类型判断, 所以这时候赋值是成立的\n}\n```\n\n### enum(枚举类型)\n\n```typescript\n// 使用场景\nenum Gender {\n  male,\n  female\n}\n\nlet p: { name: string, gender: Gender }\np = {\n  name: '林丹',\n  gnder: Gender.male\n}\n```\n\n## 引用数据类型\n\n### array\n\n### object\n\n```typescript\n// 基础的定义方式\n// 由于在 js 中几乎万物皆是对象,所以不推荐这样使用\nlet o: object\no = {}\no = function\n\n// 可以用字面量的方式\nlet o1: { name: string, age: number }\no1 = { name: 'hanler', age: 12 }\n\n// 如果要可选常数则在常数后面加个问号\nlet o2: { name: string, age?: number }\no2 = { name: 'hehe' }\n\n// 当你需要一个固定值, 但是又需要其他值且不清楚数量的时候可以像以下定义\n/**\n * @param {string} propsName 这个是属性名, 后面的 string 代表的是 string 格式的属性名\n * 中括号后面的 string 代表的是属性(propsName)的值的格式\n * */\nlet o3: { name: string, [propsName: string]: string }\no3 = { name: 'str', age: '12' }\n```\n\n## 类型断言\n\n> 可以用来告诉 ts 解析器变量的实际数据类型\n\n\n```typescript\nlet un: nuknown;\nun = 'string'\n\nlet s: string;\n\ns = un; // 此时是不成立的\n// 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n// 由于此时的 un 确实是 string 类型,我们可以使用类型断言来告诉解析器 un 就是 string 类型的来解决解析器报错问题\n\n// 两种写法\ns = un as string;\ns = <string>un;\n```\n","source":"_posts/typescript/TypeScript的数据类型.md","raw":"---\ntitle: TypeScript的数据类型\ndate: 2022/3/5 16:47:36\ncover: https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png\ncategories:\n  - TypeScript\ntags:\n  - TypeScript\n  - 数据类型\n---\n\n# TypeScript的数据类型\n\n> 变量一但定义了某个数据类型后就不允许赋值其他数据类型的数值了\n\n\n## 基础数据类型\n\n### number\n\n### string\n\n### boolean\n\n### void\n\n### null\n\n### undefinded\n\n### any (使用 TS 时不建议使用 any 类型)\n\n```typescript\n// 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet d; <=> let d: any;\n\n// any 类型还可以赋值给任意类型的变量\nlet s: string;\ns = d // 这时候是成立的\n```\n\n### unknown\n\n```typescript\n// 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet un: unknown;\n\n// any 类型还可以赋值给任意类型的变量\nlet s: string;\ns = un // 这时候是不成立的\n// 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n// unknown 实际上就是一个类型安全的 any\n// unknown 类型的变量不能直接赋值给其他类型的变量,可以间接实现\nif (typeof un === 'string') {\n  s = un; // 由于先进行了类型判断, 所以这时候赋值是成立的\n}\n```\n\n### enum(枚举类型)\n\n```typescript\n// 使用场景\nenum Gender {\n  male,\n  female\n}\n\nlet p: { name: string, gender: Gender }\np = {\n  name: '林丹',\n  gnder: Gender.male\n}\n```\n\n## 引用数据类型\n\n### array\n\n### object\n\n```typescript\n// 基础的定义方式\n// 由于在 js 中几乎万物皆是对象,所以不推荐这样使用\nlet o: object\no = {}\no = function\n\n// 可以用字面量的方式\nlet o1: { name: string, age: number }\no1 = { name: 'hanler', age: 12 }\n\n// 如果要可选常数则在常数后面加个问号\nlet o2: { name: string, age?: number }\no2 = { name: 'hehe' }\n\n// 当你需要一个固定值, 但是又需要其他值且不清楚数量的时候可以像以下定义\n/**\n * @param {string} propsName 这个是属性名, 后面的 string 代表的是 string 格式的属性名\n * 中括号后面的 string 代表的是属性(propsName)的值的格式\n * */\nlet o3: { name: string, [propsName: string]: string }\no3 = { name: 'str', age: '12' }\n```\n\n## 类型断言\n\n> 可以用来告诉 ts 解析器变量的实际数据类型\n\n\n```typescript\nlet un: nuknown;\nun = 'string'\n\nlet s: string;\n\ns = un; // 此时是不成立的\n// 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n// 由于此时的 un 确实是 string 类型,我们可以使用类型断言来告诉解析器 un 就是 string 类型的来解决解析器报错问题\n\n// 两种写法\ns = un as string;\ns = <string>un;\n```\n","slug":"typescript/TypeScript的数据类型","published":1,"updated":"2023-01-03T09:02:23.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clck4pkyv00002ovnf8ey8xgr","content":"<h1 id=\"TypeScript的数据类型\"><a href=\"#TypeScript的数据类型\" class=\"headerlink\" title=\"TypeScript的数据类型\"></a>TypeScript的数据类型</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>变量一但定义了某个数据类型后就不允许赋值其他数据类型的数值了</p></blockquote>\n<h2 id=\"基础数据类型\"><a href=\"#基础数据类型\" class=\"headerlink\" title=\"基础数据类型\"></a>基础数据类型</h2><h3 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\"number\"></a>number</h3><h3 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h3><h3 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h3><h3 id=\"void\"><a href=\"#void\" class=\"headerlink\" title=\"void\"></a>void</h3><h3 id=\"null\"><a href=\"#null\" class=\"headerlink\" title=\"null\"></a>null</h3><h3 id=\"undefinded\"><a href=\"#undefinded\" class=\"headerlink\" title=\"undefinded\"></a>undefinded</h3><h3 id=\"any-使用-TS-时不建议使用-any-类型\"><a href=\"#any-使用-TS-时不建议使用-any-类型\" class=\"headerlink\" title=\"any (使用 TS 时不建议使用 any 类型)\"></a>any (使用 TS 时不建议使用 any 类型)</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet d; &lt;&#x3D;&gt; let d: any;\n\n&#x2F;&#x2F; any 类型还可以赋值给任意类型的变量\nlet s: string;\ns &#x3D; d &#x2F;&#x2F; 这时候是成立的</code></pre>\n\n<h3 id=\"unknown\"><a href=\"#unknown\" class=\"headerlink\" title=\"unknown\"></a>unknown</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet un: unknown;\n\n&#x2F;&#x2F; any 类型还可以赋值给任意类型的变量\nlet s: string;\ns &#x3D; un &#x2F;&#x2F; 这时候是不成立的\n&#x2F;&#x2F; 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n&#x2F;&#x2F; unknown 实际上就是一个类型安全的 any\n&#x2F;&#x2F; unknown 类型的变量不能直接赋值给其他类型的变量,可以间接实现\nif (typeof un &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;\n  s &#x3D; un; &#x2F;&#x2F; 由于先进行了类型判断, 所以这时候赋值是成立的\n&#125;</code></pre>\n\n<h3 id=\"enum-枚举类型\"><a href=\"#enum-枚举类型\" class=\"headerlink\" title=\"enum(枚举类型)\"></a>enum(枚举类型)</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 使用场景\nenum Gender &#123;\n  male,\n  female\n&#125;\n\nlet p: &#123; name: string, gender: Gender &#125;\np &#x3D; &#123;\n  name: &#39;林丹&#39;,\n  gnder: Gender.male\n&#125;</code></pre>\n\n<h2 id=\"引用数据类型\"><a href=\"#引用数据类型\" class=\"headerlink\" title=\"引用数据类型\"></a>引用数据类型</h2><h3 id=\"array\"><a href=\"#array\" class=\"headerlink\" title=\"array\"></a>array</h3><h3 id=\"object\"><a href=\"#object\" class=\"headerlink\" title=\"object\"></a>object</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 基础的定义方式\n&#x2F;&#x2F; 由于在 js 中几乎万物皆是对象,所以不推荐这样使用\nlet o: object\no &#x3D; &#123;&#125;\no &#x3D; function\n\n&#x2F;&#x2F; 可以用字面量的方式\nlet o1: &#123; name: string, age: number &#125;\no1 &#x3D; &#123; name: &#39;hanler&#39;, age: 12 &#125;\n\n&#x2F;&#x2F; 如果要可选常数则在常数后面加个问号\nlet o2: &#123; name: string, age?: number &#125;\no2 &#x3D; &#123; name: &#39;hehe&#39; &#125;\n\n&#x2F;&#x2F; 当你需要一个固定值, 但是又需要其他值且不清楚数量的时候可以像以下定义\n&#x2F;**\n * @param &#123;string&#125; propsName 这个是属性名, 后面的 string 代表的是 string 格式的属性名\n * 中括号后面的 string 代表的是属性(propsName)的值的格式\n * *&#x2F;\nlet o3: &#123; name: string, [propsName: string]: string &#125;\no3 &#x3D; &#123; name: &#39;str&#39;, age: &#39;12&#39; &#125;</code></pre>\n\n<h2 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>可以用来告诉 ts 解析器变量的实际数据类型</p></blockquote>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let un: nuknown;\nun &#x3D; &#39;string&#39;\n\nlet s: string;\n\ns &#x3D; un; &#x2F;&#x2F; 此时是不成立的\n&#x2F;&#x2F; 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n&#x2F;&#x2F; 由于此时的 un 确实是 string 类型,我们可以使用类型断言来告诉解析器 un 就是 string 类型的来解决解析器报错问题\n\n&#x2F;&#x2F; 两种写法\ns &#x3D; un as string;\ns &#x3D; &lt;string&gt;un;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"TypeScript的数据类型\"><a href=\"#TypeScript的数据类型\" class=\"headerlink\" title=\"TypeScript的数据类型\"></a>TypeScript的数据类型</h1><blockquote>\n<p>变量一但定义了某个数据类型后就不允许赋值其他数据类型的数值了</p>\n</blockquote>\n<h2 id=\"基础数据类型\"><a href=\"#基础数据类型\" class=\"headerlink\" title=\"基础数据类型\"></a>基础数据类型</h2><h3 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\"number\"></a>number</h3><h3 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h3><h3 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h3><h3 id=\"void\"><a href=\"#void\" class=\"headerlink\" title=\"void\"></a>void</h3><h3 id=\"null\"><a href=\"#null\" class=\"headerlink\" title=\"null\"></a>null</h3><h3 id=\"undefinded\"><a href=\"#undefinded\" class=\"headerlink\" title=\"undefinded\"></a>undefinded</h3><h3 id=\"any-使用-TS-时不建议使用-any-类型\"><a href=\"#any-使用-TS-时不建议使用-any-类型\" class=\"headerlink\" title=\"any (使用 TS 时不建议使用 any 类型)\"></a>any (使用 TS 时不建议使用 any 类型)</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet d; &lt;&#x3D;&gt; let d: any;\n\n&#x2F;&#x2F; any 类型还可以赋值给任意类型的变量\nlet s: string;\ns &#x3D; d &#x2F;&#x2F; 这时候是成立的</code></pre>\n\n<h3 id=\"unknown\"><a href=\"#unknown\" class=\"headerlink\" title=\"unknown\"></a>unknown</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet un: unknown;\n\n&#x2F;&#x2F; any 类型还可以赋值给任意类型的变量\nlet s: string;\ns &#x3D; un &#x2F;&#x2F; 这时候是不成立的\n&#x2F;&#x2F; 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n&#x2F;&#x2F; unknown 实际上就是一个类型安全的 any\n&#x2F;&#x2F; unknown 类型的变量不能直接赋值给其他类型的变量,可以间接实现\nif (typeof un &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;\n  s &#x3D; un; &#x2F;&#x2F; 由于先进行了类型判断, 所以这时候赋值是成立的\n&#125;</code></pre>\n\n<h3 id=\"enum-枚举类型\"><a href=\"#enum-枚举类型\" class=\"headerlink\" title=\"enum(枚举类型)\"></a>enum(枚举类型)</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 使用场景\nenum Gender &#123;\n  male,\n  female\n&#125;\n\nlet p: &#123; name: string, gender: Gender &#125;\np &#x3D; &#123;\n  name: &#39;林丹&#39;,\n  gnder: Gender.male\n&#125;</code></pre>\n\n<h2 id=\"引用数据类型\"><a href=\"#引用数据类型\" class=\"headerlink\" title=\"引用数据类型\"></a>引用数据类型</h2><h3 id=\"array\"><a href=\"#array\" class=\"headerlink\" title=\"array\"></a>array</h3><h3 id=\"object\"><a href=\"#object\" class=\"headerlink\" title=\"object\"></a>object</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 基础的定义方式\n&#x2F;&#x2F; 由于在 js 中几乎万物皆是对象,所以不推荐这样使用\nlet o: object\no &#x3D; &#123;&#125;\no &#x3D; function\n\n&#x2F;&#x2F; 可以用字面量的方式\nlet o1: &#123; name: string, age: number &#125;\no1 &#x3D; &#123; name: &#39;hanler&#39;, age: 12 &#125;\n\n&#x2F;&#x2F; 如果要可选常数则在常数后面加个问号\nlet o2: &#123; name: string, age?: number &#125;\no2 &#x3D; &#123; name: &#39;hehe&#39; &#125;\n\n&#x2F;&#x2F; 当你需要一个固定值, 但是又需要其他值且不清楚数量的时候可以像以下定义\n&#x2F;**\n * @param &#123;string&#125; propsName 这个是属性名, 后面的 string 代表的是 string 格式的属性名\n * 中括号后面的 string 代表的是属性(propsName)的值的格式\n * *&#x2F;\nlet o3: &#123; name: string, [propsName: string]: string &#125;\no3 &#x3D; &#123; name: &#39;str&#39;, age: &#39;12&#39; &#125;</code></pre>\n\n<h2 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h2><blockquote>\n<p>可以用来告诉 ts 解析器变量的实际数据类型</p>\n</blockquote>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let un: nuknown;\nun &#x3D; &#39;string&#39;\n\nlet s: string;\n\ns &#x3D; un; &#x2F;&#x2F; 此时是不成立的\n&#x2F;&#x2F; 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n&#x2F;&#x2F; 由于此时的 un 确实是 string 类型,我们可以使用类型断言来告诉解析器 un 就是 string 类型的来解决解析器报错问题\n\n&#x2F;&#x2F; 两种写法\ns &#x3D; un as string;\ns &#x3D; &lt;string&gt;un;</code></pre>\n"},{"title":"webpack 创建简单的 ts 开发环境","date":"2022-03-05T08:55:46.000Z","cover":"https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png","_content":"\n# webpack 创建简单的 ts 开发环境\n\n## 前置要求\n\n需要的的 `npm` 插件\n\n>\n> 1. webpack ( webpack 本体 )\n> 2. webpack-cli ( webpack 的命令行工具 )\n> 3. typescript ( typescript 核心代码 )\n> 4. ts-loader (typescript 的 webpck 编译模块)\n> 5. clean-webpack-plugin ( 打包前清除之前打包的文件夹 )\n>\n\n\n\n## ts 开发环境目录\n![Snipaste_2022-03-05_15-32-16.png](https://s2.loli.net/2023/01/03/XS1lVDEMyifWocg.png)\n\n## tsconfig.json 配置\n\n```json\n  {\n    \"compilerOptions\": {\n\n      \"module\": \"ES6\",             // 使用的模块规则\n\n      \"target\": \"ES6\",             // 编译生成 js 的版本\n\n      \"noImplicitAny\": true,       // 不允许隐式的 any 类型\n\n      \"removeComments\": true,      // 删除注释\n\n      \"preserveConstEnums\": true,  // 保留 const 和 enum 声明\n\n      \"strict\": true               // 使用严格模式\n    },\n\n    // 需要编译的 ts 文件\n    \"include\": [\n      \"./src/**/*\"\n    ]\n  }\n```\n\n## webpack.config.js 配置\n\n### 基本配置\n\n```javascript\n  const path = require(\"path\")\n  const { CleanWebpackPlugin } = require(\"clean-webpack-plugin\")\n\n  module.exports = {\n    // 入口文件\n    entry: \"./src/index.ts\",\n\n    // 打包后的出口文件\n    output: {\n      // 文件路径\n      path: path.resolve(__dirname, \"dist\"),\n\n      // 文件名\n      filename: \"bundle.js\",\n    },\n    // 使用的编译模块\n    module: {\n\n      // 指定要加载的规则\n      rules: [\n        {\n          // test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n          test: /\\.ts$/,\n\n          // 要使用的 loader\n          use: ['ts-loader'],\n\n          // 排除要编译的文件夹\n          exclude: /node_modules/\n        }\n      ]\n    },\n\n    // 用来设置需要引用的模块文件 (这里包括了 ts 和 js) 不设置的话, 引用其他 ts/js 文件会编译报错\n    resolve: {\n      extensions: ['.ts', '.js']\n    },\n\n    // 配置 webpack 插件\n    plugins: [\n      new CleanWebpackPlugin()\n    ],\n  }\n```\n\n### 使用 html 文件配置\n\n> 前端项目中我们编译完的 js 文件最终会用到 html 文件中. 我们手动创建并引入 js 的话也不是不行, 但是很麻烦, 如果以后要增加一些其他的 js 或者 css 都得重新去手动引入. 这时候就可以用 `webpack` 给我们提供的一个自动引入经过 loader 编译后的文件 html 的插件 `html-webpack-plugin`\n>\n> `**_npm install -D html-webpack-plugin_**`\n\n\n在最外层的 `plugins` 中配置\n\n[更多 html-webpack-plugin 的配置信息看这里](https://github.com/jantimon/html-webpack-plugin#configuration)\n\n```javascript\n  // 引入插件\n  const HtmlWebpackPlugin = require(\"html-webpack-plugin\")\n\n  module.exprots = {\n    // 配置 webpack 插件\n    plugins: [\n      new HtmlWebpackPlugin({\n        // 配置 html 模板文件的目录\n        template: path.resolve(__dirname, 'public/index.html')\n      })\n    ],\n  }\n```\n\n### 使用 webpack-server 实时编译\n\n> 弄好 `html` 自动引入后我们需要打开网页去调试我们的 ts 程序, 按照普通方式来修改一次又要打包一遍, 又要重新刷新一遍网页的话就很麻烦, 这时我们可以用 `webpack-server` 来进行开发服务器部署\n>\n> `**_npm install -D webpack-server_**`\n>\n> 安装完后直接在 `package.json` 中进行配置运行命令运行就行了\n\n\n```json\n  {\n    \"scripts\": {\n      \"dev\": \"webpack server --mode development\"\n    }\n  }\n```\n\n### 配置 babel 来进行浏览器兼容\n\n在日常的开发中我们会经常遇到要兼容低版本浏览器的需要, 这时候为了增加开发效率我们可以用 `**_babel_**` 来将一些 `**_ES6_**` 中的高级属性来转换为低版本浏览器中的兼容属性\n\n需要的开发依赖\n\n>\n> 1. @babel/core ( babel 的核心代码 )\n> 2. @babel/preset-env ( babel 的兼容库 )\n> 3. core-js ( 高级属性的兼容性替代方案 )\n>\n\n> `**_npm install -D @babel/core @babel/preset-env core-js_**`\n\n\nwebpack 配置\n\n```javascript\n\n  module.exports = {\n\n    // 使用的编译模块\n    module: {\n      // 指定要加载的规则\n      rules: [\n        {\n          // test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n          test: /\\.ts$/,\n\n          // 要使用的 loader\n          use: [\n\n            // 配置 babel\n            {\n              // 指定要用的加载器\n              loader: 'babel-loader',\n\n              options: {\n                // 设置预定义的环境\n                presets: [\n                  [\n                    \"@babel-preset-env\",\n\n                    {\n                      // 需要兼容的目标浏览器, 根据项目需求填写\n                      targets: {\n                        \"chrome\": 95\n                      },\n\n                      // 指定的 core 版本\n                      \"corejs\": '3',\n\n                      // 使用 corejs 的方式 \"usage\" 按需加载\n                      \"useBuiltIns\": \"usage\"\n                    }\n                  ]\n                ]\n              }\n            },\n\n            // 由于 webpack 中 rules 是从数组从后往前执行的, 所以 ts-loader 放在后面, 让 ts 先编译为 js 在通过 babel 进行兼容性转换\n            'ts-loader'\n          ],\n        }\n      ]\n    }\n  }\n```\n","source":"_posts/typescript/webpack 搭建 ts 开发环境.md","raw":"---\ntitle: webpack 创建简单的 ts 开发环境\ndate: 2022/3/5 16:55:46\ncover: https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png\ncategories:\n  - TypeScript\ntags:\n  - TypeScript\n  - 环境搭建\n  - webpack\n---\n\n# webpack 创建简单的 ts 开发环境\n\n## 前置要求\n\n需要的的 `npm` 插件\n\n>\n> 1. webpack ( webpack 本体 )\n> 2. webpack-cli ( webpack 的命令行工具 )\n> 3. typescript ( typescript 核心代码 )\n> 4. ts-loader (typescript 的 webpck 编译模块)\n> 5. clean-webpack-plugin ( 打包前清除之前打包的文件夹 )\n>\n\n\n\n## ts 开发环境目录\n![Snipaste_2022-03-05_15-32-16.png](https://s2.loli.net/2023/01/03/XS1lVDEMyifWocg.png)\n\n## tsconfig.json 配置\n\n```json\n  {\n    \"compilerOptions\": {\n\n      \"module\": \"ES6\",             // 使用的模块规则\n\n      \"target\": \"ES6\",             // 编译生成 js 的版本\n\n      \"noImplicitAny\": true,       // 不允许隐式的 any 类型\n\n      \"removeComments\": true,      // 删除注释\n\n      \"preserveConstEnums\": true,  // 保留 const 和 enum 声明\n\n      \"strict\": true               // 使用严格模式\n    },\n\n    // 需要编译的 ts 文件\n    \"include\": [\n      \"./src/**/*\"\n    ]\n  }\n```\n\n## webpack.config.js 配置\n\n### 基本配置\n\n```javascript\n  const path = require(\"path\")\n  const { CleanWebpackPlugin } = require(\"clean-webpack-plugin\")\n\n  module.exports = {\n    // 入口文件\n    entry: \"./src/index.ts\",\n\n    // 打包后的出口文件\n    output: {\n      // 文件路径\n      path: path.resolve(__dirname, \"dist\"),\n\n      // 文件名\n      filename: \"bundle.js\",\n    },\n    // 使用的编译模块\n    module: {\n\n      // 指定要加载的规则\n      rules: [\n        {\n          // test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n          test: /\\.ts$/,\n\n          // 要使用的 loader\n          use: ['ts-loader'],\n\n          // 排除要编译的文件夹\n          exclude: /node_modules/\n        }\n      ]\n    },\n\n    // 用来设置需要引用的模块文件 (这里包括了 ts 和 js) 不设置的话, 引用其他 ts/js 文件会编译报错\n    resolve: {\n      extensions: ['.ts', '.js']\n    },\n\n    // 配置 webpack 插件\n    plugins: [\n      new CleanWebpackPlugin()\n    ],\n  }\n```\n\n### 使用 html 文件配置\n\n> 前端项目中我们编译完的 js 文件最终会用到 html 文件中. 我们手动创建并引入 js 的话也不是不行, 但是很麻烦, 如果以后要增加一些其他的 js 或者 css 都得重新去手动引入. 这时候就可以用 `webpack` 给我们提供的一个自动引入经过 loader 编译后的文件 html 的插件 `html-webpack-plugin`\n>\n> `**_npm install -D html-webpack-plugin_**`\n\n\n在最外层的 `plugins` 中配置\n\n[更多 html-webpack-plugin 的配置信息看这里](https://github.com/jantimon/html-webpack-plugin#configuration)\n\n```javascript\n  // 引入插件\n  const HtmlWebpackPlugin = require(\"html-webpack-plugin\")\n\n  module.exprots = {\n    // 配置 webpack 插件\n    plugins: [\n      new HtmlWebpackPlugin({\n        // 配置 html 模板文件的目录\n        template: path.resolve(__dirname, 'public/index.html')\n      })\n    ],\n  }\n```\n\n### 使用 webpack-server 实时编译\n\n> 弄好 `html` 自动引入后我们需要打开网页去调试我们的 ts 程序, 按照普通方式来修改一次又要打包一遍, 又要重新刷新一遍网页的话就很麻烦, 这时我们可以用 `webpack-server` 来进行开发服务器部署\n>\n> `**_npm install -D webpack-server_**`\n>\n> 安装完后直接在 `package.json` 中进行配置运行命令运行就行了\n\n\n```json\n  {\n    \"scripts\": {\n      \"dev\": \"webpack server --mode development\"\n    }\n  }\n```\n\n### 配置 babel 来进行浏览器兼容\n\n在日常的开发中我们会经常遇到要兼容低版本浏览器的需要, 这时候为了增加开发效率我们可以用 `**_babel_**` 来将一些 `**_ES6_**` 中的高级属性来转换为低版本浏览器中的兼容属性\n\n需要的开发依赖\n\n>\n> 1. @babel/core ( babel 的核心代码 )\n> 2. @babel/preset-env ( babel 的兼容库 )\n> 3. core-js ( 高级属性的兼容性替代方案 )\n>\n\n> `**_npm install -D @babel/core @babel/preset-env core-js_**`\n\n\nwebpack 配置\n\n```javascript\n\n  module.exports = {\n\n    // 使用的编译模块\n    module: {\n      // 指定要加载的规则\n      rules: [\n        {\n          // test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n          test: /\\.ts$/,\n\n          // 要使用的 loader\n          use: [\n\n            // 配置 babel\n            {\n              // 指定要用的加载器\n              loader: 'babel-loader',\n\n              options: {\n                // 设置预定义的环境\n                presets: [\n                  [\n                    \"@babel-preset-env\",\n\n                    {\n                      // 需要兼容的目标浏览器, 根据项目需求填写\n                      targets: {\n                        \"chrome\": 95\n                      },\n\n                      // 指定的 core 版本\n                      \"corejs\": '3',\n\n                      // 使用 corejs 的方式 \"usage\" 按需加载\n                      \"useBuiltIns\": \"usage\"\n                    }\n                  ]\n                ]\n              }\n            },\n\n            // 由于 webpack 中 rules 是从数组从后往前执行的, 所以 ts-loader 放在后面, 让 ts 先编译为 js 在通过 babel 进行兼容性转换\n            'ts-loader'\n          ],\n        }\n      ]\n    }\n  }\n```\n","slug":"typescript/webpack 搭建 ts 开发环境","published":1,"updated":"2023-01-03T09:02:23.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clck4pkz100022ovnenjv6jnx","content":"<h1 id=\"webpack-创建简单的-ts-开发环境\"><a href=\"#webpack-创建简单的-ts-开发环境\" class=\"headerlink\" title=\"webpack 创建简单的 ts 开发环境\"></a>webpack 创建简单的 ts 开发环境</h1><h2 id=\"前置要求\"><a href=\"#前置要求\" class=\"headerlink\" title=\"前置要求\"></a>前置要求</h2><p>需要的的 <code>npm</code> 插件</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>webpack ( webpack 本体 )</li>\n<li>webpack-cli ( webpack 的命令行工具 )</li>\n<li>typescript ( typescript 核心代码 )</li>\n<li>ts-loader (typescript 的 webpck 编译模块)</li>\n<li>clean-webpack-plugin ( 打包前清除之前打包的文件夹 )</li>\n</ol></blockquote>\n<h2 id=\"ts-开发环境目录\"><a href=\"#ts-开发环境目录\" class=\"headerlink\" title=\"ts 开发环境目录\"></a>ts 开发环境目录</h2><p><img src=\"https://s2.loli.net/2023/01/03/XS1lVDEMyifWocg.png\" alt=\"Snipaste_2022-03-05_15-32-16.png\"></p>\n<h2 id=\"tsconfig-json-配置\"><a href=\"#tsconfig-json-配置\" class=\"headerlink\" title=\"tsconfig.json 配置\"></a>tsconfig.json 配置</h2><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;compilerOptions&quot;: &#123;\n\n    &quot;module&quot;: &quot;ES6&quot;,             &#x2F;&#x2F; 使用的模块规则\n\n    &quot;target&quot;: &quot;ES6&quot;,             &#x2F;&#x2F; 编译生成 js 的版本\n\n    &quot;noImplicitAny&quot;: true,       &#x2F;&#x2F; 不允许隐式的 any 类型\n\n    &quot;removeComments&quot;: true,      &#x2F;&#x2F; 删除注释\n\n    &quot;preserveConstEnums&quot;: true,  &#x2F;&#x2F; 保留 const 和 enum 声明\n\n    &quot;strict&quot;: true               &#x2F;&#x2F; 使用严格模式\n  &#125;,\n\n  &#x2F;&#x2F; 需要编译的 ts 文件\n  &quot;include&quot;: [\n    &quot;.&#x2F;src&#x2F;**&#x2F;*&quot;\n  ]\n&#125;</code></pre>\n\n<h2 id=\"webpack-config-js-配置\"><a href=\"#webpack-config-js-配置\" class=\"headerlink\" title=\"webpack.config.js 配置\"></a>webpack.config.js 配置</h2><h3 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const path &#x3D; require(&quot;path&quot;)\nconst &#123; CleanWebpackPlugin &#125; &#x3D; require(&quot;clean-webpack-plugin&quot;)\n\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; 入口文件\n  entry: &quot;.&#x2F;src&#x2F;index.ts&quot;,\n\n  &#x2F;&#x2F; 打包后的出口文件\n  output: &#123;\n    &#x2F;&#x2F; 文件路径\n    path: path.resolve(__dirname, &quot;dist&quot;),\n\n    &#x2F;&#x2F; 文件名\n    filename: &quot;bundle.js&quot;,\n  &#125;,\n  &#x2F;&#x2F; 使用的编译模块\n  module: &#123;\n\n    &#x2F;&#x2F; 指定要加载的规则\n    rules: [\n      &#123;\n        &#x2F;&#x2F; test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n        test: &#x2F;\\.ts$&#x2F;,\n\n        &#x2F;&#x2F; 要使用的 loader\n        use: [&#39;ts-loader&#39;],\n\n        &#x2F;&#x2F; 排除要编译的文件夹\n        exclude: &#x2F;node_modules&#x2F;\n      &#125;\n    ]\n  &#125;,\n\n  &#x2F;&#x2F; 用来设置需要引用的模块文件 (这里包括了 ts 和 js) 不设置的话, 引用其他 ts&#x2F;js 文件会编译报错\n  resolve: &#123;\n    extensions: [&#39;.ts&#39;, &#39;.js&#39;]\n  &#125;,\n\n  &#x2F;&#x2F; 配置 webpack 插件\n  plugins: [\n    new CleanWebpackPlugin()\n  ],\n&#125;</code></pre>\n\n<h3 id=\"使用-html-文件配置\"><a href=\"#使用-html-文件配置\" class=\"headerlink\" title=\"使用 html 文件配置\"></a>使用 html 文件配置</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>前端项目中我们编译完的 js 文件最终会用到 html 文件中. 我们手动创建并引入 js 的话也不是不行, 但是很麻烦, 如果以后要增加一些其他的 js 或者 css 都得重新去手动引入. 这时候就可以用 <code>webpack</code> 给我们提供的一个自动引入经过 loader 编译后的文件 html 的插件 <code>html-webpack-plugin</code></p>\n<p><code>**_npm install -D html-webpack-plugin_**</code></p></blockquote>\n<p>在最外层的 <code>plugins</code> 中配置</p>\n<p><a href=\"https://github.com/jantimon/html-webpack-plugin#configuration\">更多 html-webpack-plugin 的配置信息看这里</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 引入插件\nconst HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;)\n\nmodule.exprots &#x3D; &#123;\n  &#x2F;&#x2F; 配置 webpack 插件\n  plugins: [\n    new HtmlWebpackPlugin(&#123;\n      &#x2F;&#x2F; 配置 html 模板文件的目录\n      template: path.resolve(__dirname, &#39;public&#x2F;index.html&#39;)\n    &#125;)\n  ],\n&#125;</code></pre>\n\n<h3 id=\"使用-webpack-server-实时编译\"><a href=\"#使用-webpack-server-实时编译\" class=\"headerlink\" title=\"使用 webpack-server 实时编译\"></a>使用 webpack-server 实时编译</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>弄好 <code>html</code> 自动引入后我们需要打开网页去调试我们的 ts 程序, 按照普通方式来修改一次又要打包一遍, 又要重新刷新一遍网页的话就很麻烦, 这时我们可以用 <code>webpack-server</code> 来进行开发服务器部署</p>\n<p><code>**_npm install -D webpack-server_**</code></p>\n<p>安装完后直接在 <code>package.json</code> 中进行配置运行命令运行就行了</p></blockquote>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;webpack server --mode development&quot;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"配置-babel-来进行浏览器兼容\"><a href=\"#配置-babel-来进行浏览器兼容\" class=\"headerlink\" title=\"配置 babel 来进行浏览器兼容\"></a>配置 babel 来进行浏览器兼容</h3><p>在日常的开发中我们会经常遇到要兼容低版本浏览器的需要, 这时候为了增加开发效率我们可以用 <code>**_babel_**</code> 来将一些 <code>**_ES6_**</code> 中的高级属性来转换为低版本浏览器中的兼容属性</p>\n<p>需要的开发依赖</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>@babel/core ( babel 的核心代码 )</li>\n<li>@babel/preset-env ( babel 的兼容库 )</li>\n<li>core-js ( 高级属性的兼容性替代方案 )</li>\n</ol></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>**_npm install -D @babel/core @babel/preset-env core-js_**</code></p></blockquote>\n<p>webpack 配置</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\nmodule.exports &#x3D; &#123;\n\n  &#x2F;&#x2F; 使用的编译模块\n  module: &#123;\n    &#x2F;&#x2F; 指定要加载的规则\n    rules: [\n      &#123;\n        &#x2F;&#x2F; test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n        test: &#x2F;\\.ts$&#x2F;,\n\n        &#x2F;&#x2F; 要使用的 loader\n        use: [\n\n          &#x2F;&#x2F; 配置 babel\n          &#123;\n            &#x2F;&#x2F; 指定要用的加载器\n            loader: &#39;babel-loader&#39;,\n\n            options: &#123;\n              &#x2F;&#x2F; 设置预定义的环境\n              presets: [\n                [\n                  &quot;@babel-preset-env&quot;,\n\n                  &#123;\n                    &#x2F;&#x2F; 需要兼容的目标浏览器, 根据项目需求填写\n                    targets: &#123;\n                      &quot;chrome&quot;: 95\n                    &#125;,\n\n                    &#x2F;&#x2F; 指定的 core 版本\n                    &quot;corejs&quot;: &#39;3&#39;,\n\n                    &#x2F;&#x2F; 使用 corejs 的方式 &quot;usage&quot; 按需加载\n                    &quot;useBuiltIns&quot;: &quot;usage&quot;\n                  &#125;\n                ]\n              ]\n            &#125;\n          &#125;,\n\n          &#x2F;&#x2F; 由于 webpack 中 rules 是从数组从后往前执行的, 所以 ts-loader 放在后面, 让 ts 先编译为 js 在通过 babel 进行兼容性转换\n          &#39;ts-loader&#39;\n        ],\n      &#125;\n    ]\n  &#125;\n&#125;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"webpack-创建简单的-ts-开发环境\"><a href=\"#webpack-创建简单的-ts-开发环境\" class=\"headerlink\" title=\"webpack 创建简单的 ts 开发环境\"></a>webpack 创建简单的 ts 开发环境</h1><h2 id=\"前置要求\"><a href=\"#前置要求\" class=\"headerlink\" title=\"前置要求\"></a>前置要求</h2><p>需要的的 <code>npm</code> 插件</p>\n<blockquote>\n<ol>\n<li>webpack ( webpack 本体 )</li>\n<li>webpack-cli ( webpack 的命令行工具 )</li>\n<li>typescript ( typescript 核心代码 )</li>\n<li>ts-loader (typescript 的 webpck 编译模块)</li>\n<li>clean-webpack-plugin ( 打包前清除之前打包的文件夹 )</li>\n</ol>\n</blockquote>\n<h2 id=\"ts-开发环境目录\"><a href=\"#ts-开发环境目录\" class=\"headerlink\" title=\"ts 开发环境目录\"></a>ts 开发环境目录</h2><p><img src=\"https://s2.loli.net/2023/01/03/XS1lVDEMyifWocg.png\" alt=\"Snipaste_2022-03-05_15-32-16.png\"></p>\n<h2 id=\"tsconfig-json-配置\"><a href=\"#tsconfig-json-配置\" class=\"headerlink\" title=\"tsconfig.json 配置\"></a>tsconfig.json 配置</h2><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;compilerOptions&quot;: &#123;\n\n    &quot;module&quot;: &quot;ES6&quot;,             &#x2F;&#x2F; 使用的模块规则\n\n    &quot;target&quot;: &quot;ES6&quot;,             &#x2F;&#x2F; 编译生成 js 的版本\n\n    &quot;noImplicitAny&quot;: true,       &#x2F;&#x2F; 不允许隐式的 any 类型\n\n    &quot;removeComments&quot;: true,      &#x2F;&#x2F; 删除注释\n\n    &quot;preserveConstEnums&quot;: true,  &#x2F;&#x2F; 保留 const 和 enum 声明\n\n    &quot;strict&quot;: true               &#x2F;&#x2F; 使用严格模式\n  &#125;,\n\n  &#x2F;&#x2F; 需要编译的 ts 文件\n  &quot;include&quot;: [\n    &quot;.&#x2F;src&#x2F;**&#x2F;*&quot;\n  ]\n&#125;</code></pre>\n\n<h2 id=\"webpack-config-js-配置\"><a href=\"#webpack-config-js-配置\" class=\"headerlink\" title=\"webpack.config.js 配置\"></a>webpack.config.js 配置</h2><h3 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const path &#x3D; require(&quot;path&quot;)\nconst &#123; CleanWebpackPlugin &#125; &#x3D; require(&quot;clean-webpack-plugin&quot;)\n\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; 入口文件\n  entry: &quot;.&#x2F;src&#x2F;index.ts&quot;,\n\n  &#x2F;&#x2F; 打包后的出口文件\n  output: &#123;\n    &#x2F;&#x2F; 文件路径\n    path: path.resolve(__dirname, &quot;dist&quot;),\n\n    &#x2F;&#x2F; 文件名\n    filename: &quot;bundle.js&quot;,\n  &#125;,\n  &#x2F;&#x2F; 使用的编译模块\n  module: &#123;\n\n    &#x2F;&#x2F; 指定要加载的规则\n    rules: [\n      &#123;\n        &#x2F;&#x2F; test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n        test: &#x2F;\\.ts$&#x2F;,\n\n        &#x2F;&#x2F; 要使用的 loader\n        use: [&#39;ts-loader&#39;],\n\n        &#x2F;&#x2F; 排除要编译的文件夹\n        exclude: &#x2F;node_modules&#x2F;\n      &#125;\n    ]\n  &#125;,\n\n  &#x2F;&#x2F; 用来设置需要引用的模块文件 (这里包括了 ts 和 js) 不设置的话, 引用其他 ts&#x2F;js 文件会编译报错\n  resolve: &#123;\n    extensions: [&#39;.ts&#39;, &#39;.js&#39;]\n  &#125;,\n\n  &#x2F;&#x2F; 配置 webpack 插件\n  plugins: [\n    new CleanWebpackPlugin()\n  ],\n&#125;</code></pre>\n\n<h3 id=\"使用-html-文件配置\"><a href=\"#使用-html-文件配置\" class=\"headerlink\" title=\"使用 html 文件配置\"></a>使用 html 文件配置</h3><blockquote>\n<p>前端项目中我们编译完的 js 文件最终会用到 html 文件中. 我们手动创建并引入 js 的话也不是不行, 但是很麻烦, 如果以后要增加一些其他的 js 或者 css 都得重新去手动引入. 这时候就可以用 <code>webpack</code> 给我们提供的一个自动引入经过 loader 编译后的文件 html 的插件 <code>html-webpack-plugin</code></p>\n<p><code>**_npm install -D html-webpack-plugin_**</code></p>\n</blockquote>\n<p>在最外层的 <code>plugins</code> 中配置</p>\n<p><a href=\"https://github.com/jantimon/html-webpack-plugin#configuration\">更多 html-webpack-plugin 的配置信息看这里</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 引入插件\nconst HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;)\n\nmodule.exprots &#x3D; &#123;\n  &#x2F;&#x2F; 配置 webpack 插件\n  plugins: [\n    new HtmlWebpackPlugin(&#123;\n      &#x2F;&#x2F; 配置 html 模板文件的目录\n      template: path.resolve(__dirname, &#39;public&#x2F;index.html&#39;)\n    &#125;)\n  ],\n&#125;</code></pre>\n\n<h3 id=\"使用-webpack-server-实时编译\"><a href=\"#使用-webpack-server-实时编译\" class=\"headerlink\" title=\"使用 webpack-server 实时编译\"></a>使用 webpack-server 实时编译</h3><blockquote>\n<p>弄好 <code>html</code> 自动引入后我们需要打开网页去调试我们的 ts 程序, 按照普通方式来修改一次又要打包一遍, 又要重新刷新一遍网页的话就很麻烦, 这时我们可以用 <code>webpack-server</code> 来进行开发服务器部署</p>\n<p><code>**_npm install -D webpack-server_**</code></p>\n<p>安装完后直接在 <code>package.json</code> 中进行配置运行命令运行就行了</p>\n</blockquote>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;webpack server --mode development&quot;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"配置-babel-来进行浏览器兼容\"><a href=\"#配置-babel-来进行浏览器兼容\" class=\"headerlink\" title=\"配置 babel 来进行浏览器兼容\"></a>配置 babel 来进行浏览器兼容</h3><p>在日常的开发中我们会经常遇到要兼容低版本浏览器的需要, 这时候为了增加开发效率我们可以用 <code>**_babel_**</code> 来将一些 <code>**_ES6_**</code> 中的高级属性来转换为低版本浏览器中的兼容属性</p>\n<p>需要的开发依赖</p>\n<blockquote>\n<ol>\n<li>@babel/core ( babel 的核心代码 )</li>\n<li>@babel/preset-env ( babel 的兼容库 )</li>\n<li>core-js ( 高级属性的兼容性替代方案 )</li>\n</ol>\n</blockquote>\n<blockquote>\n<p><code>**_npm install -D @babel/core @babel/preset-env core-js_**</code></p>\n</blockquote>\n<p>webpack 配置</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\nmodule.exports &#x3D; &#123;\n\n  &#x2F;&#x2F; 使用的编译模块\n  module: &#123;\n    &#x2F;&#x2F; 指定要加载的规则\n    rules: [\n      &#123;\n        &#x2F;&#x2F; test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n        test: &#x2F;\\.ts$&#x2F;,\n\n        &#x2F;&#x2F; 要使用的 loader\n        use: [\n\n          &#x2F;&#x2F; 配置 babel\n          &#123;\n            &#x2F;&#x2F; 指定要用的加载器\n            loader: &#39;babel-loader&#39;,\n\n            options: &#123;\n              &#x2F;&#x2F; 设置预定义的环境\n              presets: [\n                [\n                  &quot;@babel-preset-env&quot;,\n\n                  &#123;\n                    &#x2F;&#x2F; 需要兼容的目标浏览器, 根据项目需求填写\n                    targets: &#123;\n                      &quot;chrome&quot;: 95\n                    &#125;,\n\n                    &#x2F;&#x2F; 指定的 core 版本\n                    &quot;corejs&quot;: &#39;3&#39;,\n\n                    &#x2F;&#x2F; 使用 corejs 的方式 &quot;usage&quot; 按需加载\n                    &quot;useBuiltIns&quot;: &quot;usage&quot;\n                  &#125;\n                ]\n              ]\n            &#125;\n          &#125;,\n\n          &#x2F;&#x2F; 由于 webpack 中 rules 是从数组从后往前执行的, 所以 ts-loader 放在后面, 让 ts 先编译为 js 在通过 babel 进行兼容性转换\n          &#39;ts-loader&#39;\n        ],\n      &#125;\n    ]\n  &#125;\n&#125;</code></pre>\n"},{"title":"tsconfig.json 编译配置","date":"2022-03-05T08:40:02.000Z","cover":"https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png","_content":"\n# tsconfig.json 编译配置\n\n```json\n  {\n    // 设置保存文件的时候自动编译，但需要编译器支持。\n    \"compileOnSave\": false,\n\n    // 编译选项配置\n    \"compilerOptions\": {\n      \"incremental\": true, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n\n      \"tsBuildInfoFile\": \"./buildFile\", // 增量编译文件的存储位置\n\n      \"diagnostics\": true, // 打印诊断信息\n\n      \"target\": \"ES5\", // 目标语言的版本\n\n      \"module\": \"CommonJS\", // 生成代码的模板标准\n\n      \"outFile\": \"./app.js\", // 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置\"module\": \"AMD\",\n\n      \"lib\": [\"DOM\", \"ES2015\", \"ScriptHost\", \"ES2019.Array\"], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入\"ES2019.Array\",\n\n      \"allowJS\": true, // 允许编译器编译JS，JSX文件\n\n      \"checkJs\": true, // 允许在JS文件中报错，通常与allowJS一起使用\n\n      \"outDir\": \"./dist\", // 指定输出目录\n\n      \"rootDir\": \"./\", // 指定输出文件目录(用于输出)，用于控制输出目录结构\n\n      \"declaration\": true, // 生成声明文件，开启后会自动生成声明文件\n\n      \"declarationDir\": \"./file\", // 指定生成声明文件存放目录\n\n      \"emitDeclarationOnly\": true, // 只生成声明文件，而不会生成js文件\n\n      \"sourceMap\": true, // 生成目标文件的sourceMap文件\n\n      \"inlineSourceMap\": true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n\n      \"declarationMap\": true, // 为声明文件生成sourceMap\n\n      \"typeRoots\": [], // 声明文件目录，默认时node_modules/@types\n\n      \"types\": [], // 加载的声明文件包\n\n      \"removeComments\":true, // 删除注释\n\n      \"noEmit\": true, // 不输出文件,即编译后不会生成任何js文件\n\n      \"noEmitOnError\": true, // 发送错误时不输出任何文件\n\n      \"noEmitHelpers\": true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n\n      \"importHelpers\": true, // 通过tslib引入helper函数，文件必须是模块\n\n      \"downlevelIteration\": true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现\n\n      \"strict\": true, // 开启所有严格的类型检查\n\n      \"alwaysStrict\": true, // 在代码中注入'use strict'\n\n      \"noImplicitAny\": true, // 不允许隐式的any类型\n\n      \"strictNullChecks\": true, // 不允许把null、undefined赋值给其他类型的变量\n\n      \"strictFunctionTypes\": true, // 不允许函数参数双向协变\n\n      \"strictPropertyInitialization\": true, // 类的实例属性必须初始化\n\n      \"strictBindCallApply\": true, // 严格的bind/call/apply检查\n\n      \"noImplicitThis\": true, // 不允许this有隐式的any类型\n\n      \"noUnusedLocals\": true, // 检查只声明、未使用的局部变量(只提示不报错)\n\n      \"noUnusedParameters\": true, // 检查未使用的函数参数(只提示不报错)\n\n      \"noFallthroughCasesInSwitch\": true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)\n\n      \"noImplicitReturns\": true, //每个分支都会有返回值\n\n      \"esModuleInterop\": true, // 允许export=导出，由import from 导入\n\n      \"allowUmdGlobalAccess\": true, // 允许在模块中全局变量的方式访问umd模块\n\n      \"moduleResolution\": \"node\", // 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n\n      \"baseUrl\": \"./\", // 解析非相对模块的基地址，默认是当前目录\n\n      \"paths\": { // 路径映射，相对于baseUrl\n        // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n        \"jquery\": [\"node_modules/jquery/dist/jquery.min.js\"]\n      },\n\n      \"rootDirs\": [\"src\",\"out\"], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n\n      \"listEmittedFiles\": true, // 打印输出文件\n\n      \"listFiles\": true// 打印编译的文件(包括引用的声明文件)\n    },\n\n    // include 属性作用是指定编译需要编译的文件或目录。\n    \"include\": [\"./src/**/*\"],\n\n    // exclude 属性作用是指定编译器需要排除的文件或文件夹。默认排除 node_modules 文件夹下文件。\n    \"exclude\": [\"./utils/**/*\"],\n\n    // extends 属性作用是引入其他配置文件，继承配置。\n    \"extends\": \"./tsconfig.base.json\",\n\n    // files 属性作用是指定需要编译的单个文件列表。 默认包含当前目录和子目录下所有 TypeScript 文件。\n    \"files\": [\n      // 指定编译文件是src目录下的leo.ts文件\n      \"scr/leo.ts\"\n    ],\n\n    // references 属性作用是指定工程引用依赖。\n    // 在项目开发中，有时候我们为了方便将前端项目和后端node项目放在同一个目录下开发，两个项目依赖同一个配置文件和通用文件，但我们希望前后端项目进行灵活的分别打包，那么我们可以进行如下配置：\n    \"references\": [ // 指定依赖的工程\n      {\"path\": \"./common\"}\n    ],\n\n    // typeAcquisition 属性作用是设置自动引入库类型定义文件(.d.ts)相关。\n    // enable  : 布尔类型，是否开启自动引入库类型定义文件(.d.ts)，默认为 false；\n    // include  : 数组类型，允许自动引入的库名，如：[\"jquery\", \"lodash\"]；\n    // exculde  : 数组类型，排除的库名。\n    \"typeAcquisition\": {\n      \"enable\": false,\n      \"exclude\": [\"jquery\"],\n      \"include\": [\"jest\"]\n    }\n  }\n```\n","source":"_posts/typescript/tsconfig.json 编译配置.md","raw":"---\ntitle: tsconfig.json 编译配置\ndate: 2022/3/5 16:40:02\ncover: https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png\ncategories:\n  - TypeScript\ntags:\n  - TypeScript\n  - tsconfig\n---\n\n# tsconfig.json 编译配置\n\n```json\n  {\n    // 设置保存文件的时候自动编译，但需要编译器支持。\n    \"compileOnSave\": false,\n\n    // 编译选项配置\n    \"compilerOptions\": {\n      \"incremental\": true, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n\n      \"tsBuildInfoFile\": \"./buildFile\", // 增量编译文件的存储位置\n\n      \"diagnostics\": true, // 打印诊断信息\n\n      \"target\": \"ES5\", // 目标语言的版本\n\n      \"module\": \"CommonJS\", // 生成代码的模板标准\n\n      \"outFile\": \"./app.js\", // 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置\"module\": \"AMD\",\n\n      \"lib\": [\"DOM\", \"ES2015\", \"ScriptHost\", \"ES2019.Array\"], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入\"ES2019.Array\",\n\n      \"allowJS\": true, // 允许编译器编译JS，JSX文件\n\n      \"checkJs\": true, // 允许在JS文件中报错，通常与allowJS一起使用\n\n      \"outDir\": \"./dist\", // 指定输出目录\n\n      \"rootDir\": \"./\", // 指定输出文件目录(用于输出)，用于控制输出目录结构\n\n      \"declaration\": true, // 生成声明文件，开启后会自动生成声明文件\n\n      \"declarationDir\": \"./file\", // 指定生成声明文件存放目录\n\n      \"emitDeclarationOnly\": true, // 只生成声明文件，而不会生成js文件\n\n      \"sourceMap\": true, // 生成目标文件的sourceMap文件\n\n      \"inlineSourceMap\": true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n\n      \"declarationMap\": true, // 为声明文件生成sourceMap\n\n      \"typeRoots\": [], // 声明文件目录，默认时node_modules/@types\n\n      \"types\": [], // 加载的声明文件包\n\n      \"removeComments\":true, // 删除注释\n\n      \"noEmit\": true, // 不输出文件,即编译后不会生成任何js文件\n\n      \"noEmitOnError\": true, // 发送错误时不输出任何文件\n\n      \"noEmitHelpers\": true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n\n      \"importHelpers\": true, // 通过tslib引入helper函数，文件必须是模块\n\n      \"downlevelIteration\": true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现\n\n      \"strict\": true, // 开启所有严格的类型检查\n\n      \"alwaysStrict\": true, // 在代码中注入'use strict'\n\n      \"noImplicitAny\": true, // 不允许隐式的any类型\n\n      \"strictNullChecks\": true, // 不允许把null、undefined赋值给其他类型的变量\n\n      \"strictFunctionTypes\": true, // 不允许函数参数双向协变\n\n      \"strictPropertyInitialization\": true, // 类的实例属性必须初始化\n\n      \"strictBindCallApply\": true, // 严格的bind/call/apply检查\n\n      \"noImplicitThis\": true, // 不允许this有隐式的any类型\n\n      \"noUnusedLocals\": true, // 检查只声明、未使用的局部变量(只提示不报错)\n\n      \"noUnusedParameters\": true, // 检查未使用的函数参数(只提示不报错)\n\n      \"noFallthroughCasesInSwitch\": true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)\n\n      \"noImplicitReturns\": true, //每个分支都会有返回值\n\n      \"esModuleInterop\": true, // 允许export=导出，由import from 导入\n\n      \"allowUmdGlobalAccess\": true, // 允许在模块中全局变量的方式访问umd模块\n\n      \"moduleResolution\": \"node\", // 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n\n      \"baseUrl\": \"./\", // 解析非相对模块的基地址，默认是当前目录\n\n      \"paths\": { // 路径映射，相对于baseUrl\n        // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n        \"jquery\": [\"node_modules/jquery/dist/jquery.min.js\"]\n      },\n\n      \"rootDirs\": [\"src\",\"out\"], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n\n      \"listEmittedFiles\": true, // 打印输出文件\n\n      \"listFiles\": true// 打印编译的文件(包括引用的声明文件)\n    },\n\n    // include 属性作用是指定编译需要编译的文件或目录。\n    \"include\": [\"./src/**/*\"],\n\n    // exclude 属性作用是指定编译器需要排除的文件或文件夹。默认排除 node_modules 文件夹下文件。\n    \"exclude\": [\"./utils/**/*\"],\n\n    // extends 属性作用是引入其他配置文件，继承配置。\n    \"extends\": \"./tsconfig.base.json\",\n\n    // files 属性作用是指定需要编译的单个文件列表。 默认包含当前目录和子目录下所有 TypeScript 文件。\n    \"files\": [\n      // 指定编译文件是src目录下的leo.ts文件\n      \"scr/leo.ts\"\n    ],\n\n    // references 属性作用是指定工程引用依赖。\n    // 在项目开发中，有时候我们为了方便将前端项目和后端node项目放在同一个目录下开发，两个项目依赖同一个配置文件和通用文件，但我们希望前后端项目进行灵活的分别打包，那么我们可以进行如下配置：\n    \"references\": [ // 指定依赖的工程\n      {\"path\": \"./common\"}\n    ],\n\n    // typeAcquisition 属性作用是设置自动引入库类型定义文件(.d.ts)相关。\n    // enable  : 布尔类型，是否开启自动引入库类型定义文件(.d.ts)，默认为 false；\n    // include  : 数组类型，允许自动引入的库名，如：[\"jquery\", \"lodash\"]；\n    // exculde  : 数组类型，排除的库名。\n    \"typeAcquisition\": {\n      \"enable\": false,\n      \"exclude\": [\"jquery\"],\n      \"include\": [\"jest\"]\n    }\n  }\n```\n","slug":"typescript/tsconfig.json 编译配置","published":1,"updated":"2023-01-03T09:02:23.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clck4pkz500052ovn41cf7diy","content":"<h1 id=\"tsconfig-json-编译配置\"><a href=\"#tsconfig-json-编译配置\" class=\"headerlink\" title=\"tsconfig.json 编译配置\"></a>tsconfig.json 编译配置</h1><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &#x2F;&#x2F; 设置保存文件的时候自动编译，但需要编译器支持。\n  &quot;compileOnSave&quot;: false,\n\n  &#x2F;&#x2F; 编译选项配置\n  &quot;compilerOptions&quot;: &#123;\n    &quot;incremental&quot;: true, &#x2F;&#x2F; TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n\n    &quot;tsBuildInfoFile&quot;: &quot;.&#x2F;buildFile&quot;, &#x2F;&#x2F; 增量编译文件的存储位置\n\n    &quot;diagnostics&quot;: true, &#x2F;&#x2F; 打印诊断信息\n\n    &quot;target&quot;: &quot;ES5&quot;, &#x2F;&#x2F; 目标语言的版本\n\n    &quot;module&quot;: &quot;CommonJS&quot;, &#x2F;&#x2F; 生成代码的模板标准\n\n    &quot;outFile&quot;: &quot;.&#x2F;app.js&quot;, &#x2F;&#x2F; 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置&quot;module&quot;: &quot;AMD&quot;,\n\n    &quot;lib&quot;: [&quot;DOM&quot;, &quot;ES2015&quot;, &quot;ScriptHost&quot;, &quot;ES2019.Array&quot;], &#x2F;&#x2F; TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入&quot;ES2019.Array&quot;,\n\n    &quot;allowJS&quot;: true, &#x2F;&#x2F; 允许编译器编译JS，JSX文件\n\n    &quot;checkJs&quot;: true, &#x2F;&#x2F; 允许在JS文件中报错，通常与allowJS一起使用\n\n    &quot;outDir&quot;: &quot;.&#x2F;dist&quot;, &#x2F;&#x2F; 指定输出目录\n\n    &quot;rootDir&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 指定输出文件目录(用于输出)，用于控制输出目录结构\n\n    &quot;declaration&quot;: true, &#x2F;&#x2F; 生成声明文件，开启后会自动生成声明文件\n\n    &quot;declarationDir&quot;: &quot;.&#x2F;file&quot;, &#x2F;&#x2F; 指定生成声明文件存放目录\n\n    &quot;emitDeclarationOnly&quot;: true, &#x2F;&#x2F; 只生成声明文件，而不会生成js文件\n\n    &quot;sourceMap&quot;: true, &#x2F;&#x2F; 生成目标文件的sourceMap文件\n\n    &quot;inlineSourceMap&quot;: true, &#x2F;&#x2F; 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n\n    &quot;declarationMap&quot;: true, &#x2F;&#x2F; 为声明文件生成sourceMap\n\n    &quot;typeRoots&quot;: [], &#x2F;&#x2F; 声明文件目录，默认时node_modules&#x2F;@types\n\n    &quot;types&quot;: [], &#x2F;&#x2F; 加载的声明文件包\n\n    &quot;removeComments&quot;:true, &#x2F;&#x2F; 删除注释\n\n    &quot;noEmit&quot;: true, &#x2F;&#x2F; 不输出文件,即编译后不会生成任何js文件\n\n    &quot;noEmitOnError&quot;: true, &#x2F;&#x2F; 发送错误时不输出任何文件\n\n    &quot;noEmitHelpers&quot;: true, &#x2F;&#x2F; 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n\n    &quot;importHelpers&quot;: true, &#x2F;&#x2F; 通过tslib引入helper函数，文件必须是模块\n\n    &quot;downlevelIteration&quot;: true, &#x2F;&#x2F; 降级遍历器实现，如果目标源是es3&#x2F;5，那么遍历器会有降级的实现\n\n    &quot;strict&quot;: true, &#x2F;&#x2F; 开启所有严格的类型检查\n\n    &quot;alwaysStrict&quot;: true, &#x2F;&#x2F; 在代码中注入&#39;use strict&#39;\n\n    &quot;noImplicitAny&quot;: true, &#x2F;&#x2F; 不允许隐式的any类型\n\n    &quot;strictNullChecks&quot;: true, &#x2F;&#x2F; 不允许把null、undefined赋值给其他类型的变量\n\n    &quot;strictFunctionTypes&quot;: true, &#x2F;&#x2F; 不允许函数参数双向协变\n\n    &quot;strictPropertyInitialization&quot;: true, &#x2F;&#x2F; 类的实例属性必须初始化\n\n    &quot;strictBindCallApply&quot;: true, &#x2F;&#x2F; 严格的bind&#x2F;call&#x2F;apply检查\n\n    &quot;noImplicitThis&quot;: true, &#x2F;&#x2F; 不允许this有隐式的any类型\n\n    &quot;noUnusedLocals&quot;: true, &#x2F;&#x2F; 检查只声明、未使用的局部变量(只提示不报错)\n\n    &quot;noUnusedParameters&quot;: true, &#x2F;&#x2F; 检查未使用的函数参数(只提示不报错)\n\n    &quot;noFallthroughCasesInSwitch&quot;: true, &#x2F;&#x2F; 防止switch语句贯穿(即如果没有break语句后面不会执行)\n\n    &quot;noImplicitReturns&quot;: true, &#x2F;&#x2F;每个分支都会有返回值\n\n    &quot;esModuleInterop&quot;: true, &#x2F;&#x2F; 允许export&#x3D;导出，由import from 导入\n\n    &quot;allowUmdGlobalAccess&quot;: true, &#x2F;&#x2F; 允许在模块中全局变量的方式访问umd模块\n\n    &quot;moduleResolution&quot;: &quot;node&quot;, &#x2F;&#x2F; 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n\n    &quot;baseUrl&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 解析非相对模块的基地址，默认是当前目录\n\n    &quot;paths&quot;: &#123; &#x2F;&#x2F; 路径映射，相对于baseUrl\n      &#x2F;&#x2F; 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n      &quot;jquery&quot;: [&quot;node_modules&#x2F;jquery&#x2F;dist&#x2F;jquery.min.js&quot;]\n    &#125;,\n\n    &quot;rootDirs&quot;: [&quot;src&quot;,&quot;out&quot;], &#x2F;&#x2F; 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n\n    &quot;listEmittedFiles&quot;: true, &#x2F;&#x2F; 打印输出文件\n\n    &quot;listFiles&quot;: true&#x2F;&#x2F; 打印编译的文件(包括引用的声明文件)\n  &#125;,\n\n  &#x2F;&#x2F; include 属性作用是指定编译需要编译的文件或目录。\n  &quot;include&quot;: [&quot;.&#x2F;src&#x2F;**&#x2F;*&quot;],\n\n  &#x2F;&#x2F; exclude 属性作用是指定编译器需要排除的文件或文件夹。默认排除 node_modules 文件夹下文件。\n  &quot;exclude&quot;: [&quot;.&#x2F;utils&#x2F;**&#x2F;*&quot;],\n\n  &#x2F;&#x2F; extends 属性作用是引入其他配置文件，继承配置。\n  &quot;extends&quot;: &quot;.&#x2F;tsconfig.base.json&quot;,\n\n  &#x2F;&#x2F; files 属性作用是指定需要编译的单个文件列表。 默认包含当前目录和子目录下所有 TypeScript 文件。\n  &quot;files&quot;: [\n    &#x2F;&#x2F; 指定编译文件是src目录下的leo.ts文件\n    &quot;scr&#x2F;leo.ts&quot;\n  ],\n\n  &#x2F;&#x2F; references 属性作用是指定工程引用依赖。\n  &#x2F;&#x2F; 在项目开发中，有时候我们为了方便将前端项目和后端node项目放在同一个目录下开发，两个项目依赖同一个配置文件和通用文件，但我们希望前后端项目进行灵活的分别打包，那么我们可以进行如下配置：\n  &quot;references&quot;: [ &#x2F;&#x2F; 指定依赖的工程\n    &#123;&quot;path&quot;: &quot;.&#x2F;common&quot;&#125;\n  ],\n\n  &#x2F;&#x2F; typeAcquisition 属性作用是设置自动引入库类型定义文件(.d.ts)相关。\n  &#x2F;&#x2F; enable  : 布尔类型，是否开启自动引入库类型定义文件(.d.ts)，默认为 false；\n  &#x2F;&#x2F; include  : 数组类型，允许自动引入的库名，如：[&quot;jquery&quot;, &quot;lodash&quot;]；\n  &#x2F;&#x2F; exculde  : 数组类型，排除的库名。\n  &quot;typeAcquisition&quot;: &#123;\n    &quot;enable&quot;: false,\n    &quot;exclude&quot;: [&quot;jquery&quot;],\n    &quot;include&quot;: [&quot;jest&quot;]\n  &#125;\n&#125;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"tsconfig-json-编译配置\"><a href=\"#tsconfig-json-编译配置\" class=\"headerlink\" title=\"tsconfig.json 编译配置\"></a>tsconfig.json 编译配置</h1><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &#x2F;&#x2F; 设置保存文件的时候自动编译，但需要编译器支持。\n  &quot;compileOnSave&quot;: false,\n\n  &#x2F;&#x2F; 编译选项配置\n  &quot;compilerOptions&quot;: &#123;\n    &quot;incremental&quot;: true, &#x2F;&#x2F; TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n\n    &quot;tsBuildInfoFile&quot;: &quot;.&#x2F;buildFile&quot;, &#x2F;&#x2F; 增量编译文件的存储位置\n\n    &quot;diagnostics&quot;: true, &#x2F;&#x2F; 打印诊断信息\n\n    &quot;target&quot;: &quot;ES5&quot;, &#x2F;&#x2F; 目标语言的版本\n\n    &quot;module&quot;: &quot;CommonJS&quot;, &#x2F;&#x2F; 生成代码的模板标准\n\n    &quot;outFile&quot;: &quot;.&#x2F;app.js&quot;, &#x2F;&#x2F; 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置&quot;module&quot;: &quot;AMD&quot;,\n\n    &quot;lib&quot;: [&quot;DOM&quot;, &quot;ES2015&quot;, &quot;ScriptHost&quot;, &quot;ES2019.Array&quot;], &#x2F;&#x2F; TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入&quot;ES2019.Array&quot;,\n\n    &quot;allowJS&quot;: true, &#x2F;&#x2F; 允许编译器编译JS，JSX文件\n\n    &quot;checkJs&quot;: true, &#x2F;&#x2F; 允许在JS文件中报错，通常与allowJS一起使用\n\n    &quot;outDir&quot;: &quot;.&#x2F;dist&quot;, &#x2F;&#x2F; 指定输出目录\n\n    &quot;rootDir&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 指定输出文件目录(用于输出)，用于控制输出目录结构\n\n    &quot;declaration&quot;: true, &#x2F;&#x2F; 生成声明文件，开启后会自动生成声明文件\n\n    &quot;declarationDir&quot;: &quot;.&#x2F;file&quot;, &#x2F;&#x2F; 指定生成声明文件存放目录\n\n    &quot;emitDeclarationOnly&quot;: true, &#x2F;&#x2F; 只生成声明文件，而不会生成js文件\n\n    &quot;sourceMap&quot;: true, &#x2F;&#x2F; 生成目标文件的sourceMap文件\n\n    &quot;inlineSourceMap&quot;: true, &#x2F;&#x2F; 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n\n    &quot;declarationMap&quot;: true, &#x2F;&#x2F; 为声明文件生成sourceMap\n\n    &quot;typeRoots&quot;: [], &#x2F;&#x2F; 声明文件目录，默认时node_modules&#x2F;@types\n\n    &quot;types&quot;: [], &#x2F;&#x2F; 加载的声明文件包\n\n    &quot;removeComments&quot;:true, &#x2F;&#x2F; 删除注释\n\n    &quot;noEmit&quot;: true, &#x2F;&#x2F; 不输出文件,即编译后不会生成任何js文件\n\n    &quot;noEmitOnError&quot;: true, &#x2F;&#x2F; 发送错误时不输出任何文件\n\n    &quot;noEmitHelpers&quot;: true, &#x2F;&#x2F; 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n\n    &quot;importHelpers&quot;: true, &#x2F;&#x2F; 通过tslib引入helper函数，文件必须是模块\n\n    &quot;downlevelIteration&quot;: true, &#x2F;&#x2F; 降级遍历器实现，如果目标源是es3&#x2F;5，那么遍历器会有降级的实现\n\n    &quot;strict&quot;: true, &#x2F;&#x2F; 开启所有严格的类型检查\n\n    &quot;alwaysStrict&quot;: true, &#x2F;&#x2F; 在代码中注入&#39;use strict&#39;\n\n    &quot;noImplicitAny&quot;: true, &#x2F;&#x2F; 不允许隐式的any类型\n\n    &quot;strictNullChecks&quot;: true, &#x2F;&#x2F; 不允许把null、undefined赋值给其他类型的变量\n\n    &quot;strictFunctionTypes&quot;: true, &#x2F;&#x2F; 不允许函数参数双向协变\n\n    &quot;strictPropertyInitialization&quot;: true, &#x2F;&#x2F; 类的实例属性必须初始化\n\n    &quot;strictBindCallApply&quot;: true, &#x2F;&#x2F; 严格的bind&#x2F;call&#x2F;apply检查\n\n    &quot;noImplicitThis&quot;: true, &#x2F;&#x2F; 不允许this有隐式的any类型\n\n    &quot;noUnusedLocals&quot;: true, &#x2F;&#x2F; 检查只声明、未使用的局部变量(只提示不报错)\n\n    &quot;noUnusedParameters&quot;: true, &#x2F;&#x2F; 检查未使用的函数参数(只提示不报错)\n\n    &quot;noFallthroughCasesInSwitch&quot;: true, &#x2F;&#x2F; 防止switch语句贯穿(即如果没有break语句后面不会执行)\n\n    &quot;noImplicitReturns&quot;: true, &#x2F;&#x2F;每个分支都会有返回值\n\n    &quot;esModuleInterop&quot;: true, &#x2F;&#x2F; 允许export&#x3D;导出，由import from 导入\n\n    &quot;allowUmdGlobalAccess&quot;: true, &#x2F;&#x2F; 允许在模块中全局变量的方式访问umd模块\n\n    &quot;moduleResolution&quot;: &quot;node&quot;, &#x2F;&#x2F; 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n\n    &quot;baseUrl&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 解析非相对模块的基地址，默认是当前目录\n\n    &quot;paths&quot;: &#123; &#x2F;&#x2F; 路径映射，相对于baseUrl\n      &#x2F;&#x2F; 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n      &quot;jquery&quot;: [&quot;node_modules&#x2F;jquery&#x2F;dist&#x2F;jquery.min.js&quot;]\n    &#125;,\n\n    &quot;rootDirs&quot;: [&quot;src&quot;,&quot;out&quot;], &#x2F;&#x2F; 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n\n    &quot;listEmittedFiles&quot;: true, &#x2F;&#x2F; 打印输出文件\n\n    &quot;listFiles&quot;: true&#x2F;&#x2F; 打印编译的文件(包括引用的声明文件)\n  &#125;,\n\n  &#x2F;&#x2F; include 属性作用是指定编译需要编译的文件或目录。\n  &quot;include&quot;: [&quot;.&#x2F;src&#x2F;**&#x2F;*&quot;],\n\n  &#x2F;&#x2F; exclude 属性作用是指定编译器需要排除的文件或文件夹。默认排除 node_modules 文件夹下文件。\n  &quot;exclude&quot;: [&quot;.&#x2F;utils&#x2F;**&#x2F;*&quot;],\n\n  &#x2F;&#x2F; extends 属性作用是引入其他配置文件，继承配置。\n  &quot;extends&quot;: &quot;.&#x2F;tsconfig.base.json&quot;,\n\n  &#x2F;&#x2F; files 属性作用是指定需要编译的单个文件列表。 默认包含当前目录和子目录下所有 TypeScript 文件。\n  &quot;files&quot;: [\n    &#x2F;&#x2F; 指定编译文件是src目录下的leo.ts文件\n    &quot;scr&#x2F;leo.ts&quot;\n  ],\n\n  &#x2F;&#x2F; references 属性作用是指定工程引用依赖。\n  &#x2F;&#x2F; 在项目开发中，有时候我们为了方便将前端项目和后端node项目放在同一个目录下开发，两个项目依赖同一个配置文件和通用文件，但我们希望前后端项目进行灵活的分别打包，那么我们可以进行如下配置：\n  &quot;references&quot;: [ &#x2F;&#x2F; 指定依赖的工程\n    &#123;&quot;path&quot;: &quot;.&#x2F;common&quot;&#125;\n  ],\n\n  &#x2F;&#x2F; typeAcquisition 属性作用是设置自动引入库类型定义文件(.d.ts)相关。\n  &#x2F;&#x2F; enable  : 布尔类型，是否开启自动引入库类型定义文件(.d.ts)，默认为 false；\n  &#x2F;&#x2F; include  : 数组类型，允许自动引入的库名，如：[&quot;jquery&quot;, &quot;lodash&quot;]；\n  &#x2F;&#x2F; exculde  : 数组类型，排除的库名。\n  &quot;typeAcquisition&quot;: &#123;\n    &quot;enable&quot;: false,\n    &quot;exclude&quot;: [&quot;jquery&quot;],\n    &quot;include&quot;: [&quot;jest&quot;]\n  &#125;\n&#125;</code></pre>\n"},{"title":"Docker 容器的使用","date":"2023-01-03T07:13:50.000Z","cover":"https://www.helloimg.com/images/2023/01/03/oCD5cE.png","_content":"\n# 网络端口映射\n有以下两种端口映射方式\n```shell\ndocker run -itd -P --name centos8 dokken/centos-8 /bin/bash\n```\n```shell\ndocker run -itd -p 1000:22 --name centos8 dokken/centos-8 /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- -d: 后台运行\n- -p 1000:22 :以指定的1000端口映射容器的22端口\n- -P: 容器内部端口随机映射到主机端口\n- --name: 容器别名\n- dokken/centos-8: 容器源名称\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n## 区别\n\n- -P :是容器内部端口随机映射到主机的端口。\n- -p : 是容器内部端口绑定到指定的主机端口。\n\n另外, 我们可以指定容器绑定的网络地址, 比如绑定 127.0.0.1\n```shell\ndocker run -itd -p 127.0.0.1:1000:22 --name centos8 dokken/centos-8 /bin/bash\n```\n这样我们就可以通过` 127.0.0.1:1000 `来访问容器的22端口了\n","source":"_posts/docker/Docker 容器连接.md","raw":"---\ntitle: Docker 容器的使用\ndate: 2023/1/3 15:13:50\ncover: https://www.helloimg.com/images/2023/01/03/oCD5cE.png\ncategories:\n  - Docker\ntags:\n  - Docker\n  - 容器\n  - container\n---\n\n# 网络端口映射\n有以下两种端口映射方式\n```shell\ndocker run -itd -P --name centos8 dokken/centos-8 /bin/bash\n```\n```shell\ndocker run -itd -p 1000:22 --name centos8 dokken/centos-8 /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- -d: 后台运行\n- -p 1000:22 :以指定的1000端口映射容器的22端口\n- -P: 容器内部端口随机映射到主机端口\n- --name: 容器别名\n- dokken/centos-8: 容器源名称\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n## 区别\n\n- -P :是容器内部端口随机映射到主机的端口。\n- -p : 是容器内部端口绑定到指定的主机端口。\n\n另外, 我们可以指定容器绑定的网络地址, 比如绑定 127.0.0.1\n```shell\ndocker run -itd -p 127.0.0.1:1000:22 --name centos8 dokken/centos-8 /bin/bash\n```\n这样我们就可以通过` 127.0.0.1:1000 `来访问容器的22端口了\n","slug":"docker/Docker 容器连接","published":1,"updated":"2023-01-03T09:02:23.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clck4pkz600062ovn5hlrbmy4","content":"<h1 id=\"网络端口映射\"><a href=\"#网络端口映射\" class=\"headerlink\" title=\"网络端口映射\"></a>网络端口映射</h1><p>有以下两种端口映射方式</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -itd -P --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash</code></pre>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -itd -p 1000:22 --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><ul>\n<li><p>-i：交互式操作</p>\n</li>\n<li><p>-t: 终端</p>\n</li>\n<li><p>-d: 后台运行</p>\n</li>\n<li><p>-p 1000:22 :以指定的1000端口映射容器的22端口</p>\n</li>\n<li><p>-P: 容器内部端口随机映射到主机端口</p>\n</li>\n<li><p>–name: 容器别名</p>\n</li>\n<li><p>dokken/centos-8: 容器源名称</p>\n</li>\n<li><p>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</p>\n<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2></li>\n<li><p>-P :是容器内部端口随机映射到主机的端口。</p>\n</li>\n<li><p>-p : 是容器内部端口绑定到指定的主机端口。</p>\n</li>\n</ul>\n<p>另外, 我们可以指定容器绑定的网络地址, 比如绑定 127.0.0.1</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -itd -p 127.0.0.1:1000:22 --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash</code></pre>\n<p>这样我们就可以通过<code>127.0.0.1:1000</code>来访问容器的22端口了</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"网络端口映射\"><a href=\"#网络端口映射\" class=\"headerlink\" title=\"网络端口映射\"></a>网络端口映射</h1><p>有以下两种端口映射方式</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -itd -P --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash</code></pre>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -itd -p 1000:22 --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><ul>\n<li><p>-i：交互式操作</p>\n</li>\n<li><p>-t: 终端</p>\n</li>\n<li><p>-d: 后台运行</p>\n</li>\n<li><p>-p 1000:22 :以指定的1000端口映射容器的22端口</p>\n</li>\n<li><p>-P: 容器内部端口随机映射到主机端口</p>\n</li>\n<li><p>–name: 容器别名</p>\n</li>\n<li><p>dokken/centos-8: 容器源名称</p>\n</li>\n<li><p>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</p>\n<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2></li>\n<li><p>-P :是容器内部端口随机映射到主机的端口。</p>\n</li>\n<li><p>-p : 是容器内部端口绑定到指定的主机端口。</p>\n</li>\n</ul>\n<p>另外, 我们可以指定容器绑定的网络地址, 比如绑定 127.0.0.1</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -itd -p 127.0.0.1:1000:22 --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash</code></pre>\n<p>这样我们就可以通过<code>127.0.0.1:1000</code>来访问容器的22端口了</p>\n"},{"title":"Docker 镜像的使用","date":"2023-01-03T07:15:43.000Z","cover":"https://www.helloimg.com/images/2023/01/03/oCD5cE.png","_content":"\n# 列出镜像列表\n我们可以使用 `docker images` 来列出本地主机上的镜像\n```shell\n$ docker images\n```\n![image.png](https://s2.loli.net/2023/01/03/jYuRFcMDSm1Orlx.png)\n## 选项说明\n\n- REPOSITORY: 表示镜像的仓库源\n- TAG:　镜像的标签\n- IMAGE ID: 镜像ID\n- CREATED: 镜像的创建时间\n- SIZE: 镜像大小\n> 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。\n\n# 获取一个新的镜像\n当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。\n```shell\ndocker pull centos:8\n```\n当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。\n# 查找镜像\n我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： [https://hub.docker.com/](https://hub.docker.com/)\n我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。\n```shell\n$ docker search httpd\n```\n![image.png](https://s2.loli.net/2023/01/03/zlKVAxekZowgcYq.png)\n## 选项说明\n\n- NAME: 镜像仓库源名称\n- DESCRIPTION: 镜像的描述\n- OFFICIAL: 是否 docker 官方发布\n- STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。\n- AUTOMATED: 自动构建。\n# 拖取镜像\n```shell\n$ docker pull httpd\n```\n下载完后我们就可以使用这个镜像了\n```shell\n$ docker run httpd\n```\n# 删除镜像\n```shell\n$ docker rmi httpd\n```\n","source":"_posts/docker/Docker 镜像的使用.md","raw":"---\ntitle: Docker 镜像的使用\ndate: 2023/1/3 15:15:43\ncover: https://www.helloimg.com/images/2023/01/03/oCD5cE.png\ncategories:\n  - Docker\ntags:\n  - Docker\n  - 镜像\n  - images\n---\n\n# 列出镜像列表\n我们可以使用 `docker images` 来列出本地主机上的镜像\n```shell\n$ docker images\n```\n![image.png](https://s2.loli.net/2023/01/03/jYuRFcMDSm1Orlx.png)\n## 选项说明\n\n- REPOSITORY: 表示镜像的仓库源\n- TAG:　镜像的标签\n- IMAGE ID: 镜像ID\n- CREATED: 镜像的创建时间\n- SIZE: 镜像大小\n> 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。\n\n# 获取一个新的镜像\n当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。\n```shell\ndocker pull centos:8\n```\n当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。\n# 查找镜像\n我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： [https://hub.docker.com/](https://hub.docker.com/)\n我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。\n```shell\n$ docker search httpd\n```\n![image.png](https://s2.loli.net/2023/01/03/zlKVAxekZowgcYq.png)\n## 选项说明\n\n- NAME: 镜像仓库源名称\n- DESCRIPTION: 镜像的描述\n- OFFICIAL: 是否 docker 官方发布\n- STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。\n- AUTOMATED: 自动构建。\n# 拖取镜像\n```shell\n$ docker pull httpd\n```\n下载完后我们就可以使用这个镜像了\n```shell\n$ docker run httpd\n```\n# 删除镜像\n```shell\n$ docker rmi httpd\n```\n","slug":"docker/Docker 镜像的使用","published":1,"updated":"2023-01-03T09:02:23.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clck4pkz700072ovnftbr2k4k","content":"<h1 id=\"列出镜像列表\"><a href=\"#列出镜像列表\" class=\"headerlink\" title=\"列出镜像列表\"></a>列出镜像列表</h1><p>我们可以使用 <code>docker images</code> 来列出本地主机上的镜像</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker images</code></pre>\n<p><img src=\"https://s2.loli.net/2023/01/03/jYuRFcMDSm1Orlx.png\" alt=\"image.png\"></p>\n<h2 id=\"选项说明\"><a href=\"#选项说明\" class=\"headerlink\" title=\"选项说明\"></a>选项说明</h2><ul>\n<li>REPOSITORY: 表示镜像的仓库源</li>\n<li>TAG:　镜像的标签</li>\n<li>IMAGE ID: 镜像ID</li>\n<li>CREATED: 镜像的创建时间</li>\n<li>SIZE: 镜像大小<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p></blockquote>\n</li>\n</ul>\n<h1 id=\"获取一个新的镜像\"><a href=\"#获取一个新的镜像\" class=\"headerlink\" title=\"获取一个新的镜像\"></a>获取一个新的镜像</h1><p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker pull centos:8</code></pre>\n<p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p>\n<h1 id=\"查找镜像\"><a href=\"#查找镜像\" class=\"headerlink\" title=\"查找镜像\"></a>查找镜像</h1><p>我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <a href=\"https://hub.docker.com/\">https://hub.docker.com/</a><br>我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker search httpd</code></pre>\n<p><img src=\"https://s2.loli.net/2023/01/03/zlKVAxekZowgcYq.png\" alt=\"image.png\"></p>\n<h2 id=\"选项说明-1\"><a href=\"#选项说明-1\" class=\"headerlink\" title=\"选项说明\"></a>选项说明</h2><ul>\n<li>NAME: 镜像仓库源名称</li>\n<li>DESCRIPTION: 镜像的描述</li>\n<li>OFFICIAL: 是否 docker 官方发布</li>\n<li>STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。</li>\n<li>AUTOMATED: 自动构建。<h1 id=\"拖取镜像\"><a href=\"#拖取镜像\" class=\"headerlink\" title=\"拖取镜像\"></a>拖取镜像</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker pull httpd</code></pre>\n下载完后我们就可以使用这个镜像了<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker run httpd</code></pre>\n<h1 id=\"删除镜像\"><a href=\"#删除镜像\" class=\"headerlink\" title=\"删除镜像\"></a>删除镜像</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker rmi httpd</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"列出镜像列表\"><a href=\"#列出镜像列表\" class=\"headerlink\" title=\"列出镜像列表\"></a>列出镜像列表</h1><p>我们可以使用 <code>docker images</code> 来列出本地主机上的镜像</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker images</code></pre>\n<p><img src=\"https://s2.loli.net/2023/01/03/jYuRFcMDSm1Orlx.png\" alt=\"image.png\"></p>\n<h2 id=\"选项说明\"><a href=\"#选项说明\" class=\"headerlink\" title=\"选项说明\"></a>选项说明</h2><ul>\n<li>REPOSITORY: 表示镜像的仓库源</li>\n<li>TAG:　镜像的标签</li>\n<li>IMAGE ID: 镜像ID</li>\n<li>CREATED: 镜像的创建时间</li>\n<li>SIZE: 镜像大小<blockquote>\n<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"获取一个新的镜像\"><a href=\"#获取一个新的镜像\" class=\"headerlink\" title=\"获取一个新的镜像\"></a>获取一个新的镜像</h1><p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker pull centos:8</code></pre>\n<p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p>\n<h1 id=\"查找镜像\"><a href=\"#查找镜像\" class=\"headerlink\" title=\"查找镜像\"></a>查找镜像</h1><p>我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <a href=\"https://hub.docker.com/\">https://hub.docker.com/</a><br>我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker search httpd</code></pre>\n<p><img src=\"https://s2.loli.net/2023/01/03/zlKVAxekZowgcYq.png\" alt=\"image.png\"></p>\n<h2 id=\"选项说明-1\"><a href=\"#选项说明-1\" class=\"headerlink\" title=\"选项说明\"></a>选项说明</h2><ul>\n<li>NAME: 镜像仓库源名称</li>\n<li>DESCRIPTION: 镜像的描述</li>\n<li>OFFICIAL: 是否 docker 官方发布</li>\n<li>STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。</li>\n<li>AUTOMATED: 自动构建。<h1 id=\"拖取镜像\"><a href=\"#拖取镜像\" class=\"headerlink\" title=\"拖取镜像\"></a>拖取镜像</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker pull httpd</code></pre>\n下载完后我们就可以使用这个镜像了<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker run httpd</code></pre>\n<h1 id=\"删除镜像\"><a href=\"#删除镜像\" class=\"headerlink\" title=\"删除镜像\"></a>删除镜像</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker rmi httpd</code></pre></li>\n</ul>\n"},{"title":"Docker 容器的使用","date":"2022-12-06T08:00:12.000Z","cover":"https://www.helloimg.com/images/2023/01/03/oCD5cE.png","_content":"\n# 获取容器\n我们可以使用docker pull 命令来下载 centos镜像\n```shell\n$ docker pull centos8\n```\n# 启动容器\n```shell\n$ docker run -it centos8 /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- centos8：centos8镜像\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n\n如果要退出终端那就使用\n```shell\n$ exit\n```\n# 查看所有容器\n```shell\n$ docker ps -a\n```\n# 启动一个已经停止的容器\n```shell\n$ docker start b750bbbcfd88(容器id)\n```\n# 停止一个已经启动的容器\n```shell\n$ docker stop b750bbbcfd88(容器id)\n```\n# 后台运行容器(不想进入容器的时候)\n```shell\n$ docker -itd --name content_8 centos8 /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- -d: 后台运行\n- --name: 运行时指定容器的名称\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n# 进入容器\n在使用参数 `-d` 时, 容器会进入后台, 这个时候如果想要进入容器内部可以使用以下命令\n```shell\n$ docker exec -it [容器ID] /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n# 导入和导出容器\n## 导出容器\n如果要导出到本地的某个容器, 可以使用 `docker export` 命令\n```shell\n$ docker export [容器ID] > centos8.tar\n```\n> 导出容器ID到本地文件的 centos8.tar\n\n## 导入容器\n```shell\n$ cat docker/ubuntu.tar | docker import - test/ubuntu:v1\n```\n此外, 还可以通过指定URL或某个目录来导入\n```shell\n$ docker import http://example.com/exampleimage.tgz example/imagerepo\n```\n## 删除容器\n```shell\n$ docker rm -f [容器ID]\n```\n清除所有处于终止状态下的容器\n```shell\n$ docker container prune\n```\n\n","source":"_posts/docker/Docker 容器的使用.md","raw":"---\ntitle: Docker 容器的使用\ndate: 2022/12/06 16:00:12\ncover: https://www.helloimg.com/images/2023/01/03/oCD5cE.png\ncategories:\n  - Docker\ntags:\n  - Docker\n  - 容器\n  - container\n---\n\n# 获取容器\n我们可以使用docker pull 命令来下载 centos镜像\n```shell\n$ docker pull centos8\n```\n# 启动容器\n```shell\n$ docker run -it centos8 /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- centos8：centos8镜像\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n\n如果要退出终端那就使用\n```shell\n$ exit\n```\n# 查看所有容器\n```shell\n$ docker ps -a\n```\n# 启动一个已经停止的容器\n```shell\n$ docker start b750bbbcfd88(容器id)\n```\n# 停止一个已经启动的容器\n```shell\n$ docker stop b750bbbcfd88(容器id)\n```\n# 后台运行容器(不想进入容器的时候)\n```shell\n$ docker -itd --name content_8 centos8 /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- -d: 后台运行\n- --name: 运行时指定容器的名称\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n# 进入容器\n在使用参数 `-d` 时, 容器会进入后台, 这个时候如果想要进入容器内部可以使用以下命令\n```shell\n$ docker exec -it [容器ID] /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n# 导入和导出容器\n## 导出容器\n如果要导出到本地的某个容器, 可以使用 `docker export` 命令\n```shell\n$ docker export [容器ID] > centos8.tar\n```\n> 导出容器ID到本地文件的 centos8.tar\n\n## 导入容器\n```shell\n$ cat docker/ubuntu.tar | docker import - test/ubuntu:v1\n```\n此外, 还可以通过指定URL或某个目录来导入\n```shell\n$ docker import http://example.com/exampleimage.tgz example/imagerepo\n```\n## 删除容器\n```shell\n$ docker rm -f [容器ID]\n```\n清除所有处于终止状态下的容器\n```shell\n$ docker container prune\n```\n\n","slug":"docker/Docker 容器的使用","published":1,"updated":"2023-01-03T09:02:23.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clck4pkz9000a2ovndlhk45vr","content":"<h1 id=\"获取容器\"><a href=\"#获取容器\" class=\"headerlink\" title=\"获取容器\"></a>获取容器</h1><p>我们可以使用docker pull 命令来下载 centos镜像</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker pull centos8</code></pre>\n<h1 id=\"启动容器\"><a href=\"#启动容器\" class=\"headerlink\" title=\"启动容器\"></a>启动容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker run -it centos8 &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><ul>\n<li>-i：交互式操作</li>\n<li>-t: 终端</li>\n<li>centos8：centos8镜像</li>\n<li>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</li>\n</ul>\n<p>如果要退出终端那就使用</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ exit</code></pre>\n<h1 id=\"查看所有容器\"><a href=\"#查看所有容器\" class=\"headerlink\" title=\"查看所有容器\"></a>查看所有容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker ps -a</code></pre>\n<h1 id=\"启动一个已经停止的容器\"><a href=\"#启动一个已经停止的容器\" class=\"headerlink\" title=\"启动一个已经停止的容器\"></a>启动一个已经停止的容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker start b750bbbcfd88(容器id)</code></pre>\n<h1 id=\"停止一个已经启动的容器\"><a href=\"#停止一个已经启动的容器\" class=\"headerlink\" title=\"停止一个已经启动的容器\"></a>停止一个已经启动的容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker stop b750bbbcfd88(容器id)</code></pre>\n<h1 id=\"后台运行容器-不想进入容器的时候\"><a href=\"#后台运行容器-不想进入容器的时候\" class=\"headerlink\" title=\"后台运行容器(不想进入容器的时候)\"></a>后台运行容器(不想进入容器的时候)</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker -itd --name content_8 centos8 &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明-1\"><a href=\"#参数说明-1\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><ul>\n<li><p>-i：交互式操作</p>\n</li>\n<li><p>-t: 终端</p>\n</li>\n<li><p>-d: 后台运行</p>\n</li>\n<li><p>–name: 运行时指定容器的名称</p>\n</li>\n<li><p>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</p>\n<h1 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h1><p>在使用参数 <code>-d</code> 时, 容器会进入后台, 这个时候如果想要进入容器内部可以使用以下命令</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker exec -it [容器ID] &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明-2\"><a href=\"#参数说明-2\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2></li>\n<li><p>-i：交互式操作</p>\n</li>\n<li><p>-t: 终端</p>\n</li>\n<li><p>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</p>\n<h1 id=\"导入和导出容器\"><a href=\"#导入和导出容器\" class=\"headerlink\" title=\"导入和导出容器\"></a>导入和导出容器</h1><h2 id=\"导出容器\"><a href=\"#导出容器\" class=\"headerlink\" title=\"导出容器\"></a>导出容器</h2><p>如果要导出到本地的某个容器, 可以使用 <code>docker export</code> 命令</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker export [容器ID] &gt; centos8.tar</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>导出容器ID到本地文件的 centos8.tar</p></blockquote>\n</li>\n</ul>\n<h2 id=\"导入容器\"><a href=\"#导入容器\" class=\"headerlink\" title=\"导入容器\"></a>导入容器</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ cat docker&#x2F;ubuntu.tar | docker import - test&#x2F;ubuntu:v1</code></pre>\n<p>此外, 还可以通过指定URL或某个目录来导入</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker import http:&#x2F;&#x2F;example.com&#x2F;exampleimage.tgz example&#x2F;imagerepo</code></pre>\n<h2 id=\"删除容器\"><a href=\"#删除容器\" class=\"headerlink\" title=\"删除容器\"></a>删除容器</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker rm -f [容器ID]</code></pre>\n<p>清除所有处于终止状态下的容器</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker container prune</code></pre>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"获取容器\"><a href=\"#获取容器\" class=\"headerlink\" title=\"获取容器\"></a>获取容器</h1><p>我们可以使用docker pull 命令来下载 centos镜像</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker pull centos8</code></pre>\n<h1 id=\"启动容器\"><a href=\"#启动容器\" class=\"headerlink\" title=\"启动容器\"></a>启动容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker run -it centos8 &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><ul>\n<li>-i：交互式操作</li>\n<li>-t: 终端</li>\n<li>centos8：centos8镜像</li>\n<li>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</li>\n</ul>\n<p>如果要退出终端那就使用</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ exit</code></pre>\n<h1 id=\"查看所有容器\"><a href=\"#查看所有容器\" class=\"headerlink\" title=\"查看所有容器\"></a>查看所有容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker ps -a</code></pre>\n<h1 id=\"启动一个已经停止的容器\"><a href=\"#启动一个已经停止的容器\" class=\"headerlink\" title=\"启动一个已经停止的容器\"></a>启动一个已经停止的容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker start b750bbbcfd88(容器id)</code></pre>\n<h1 id=\"停止一个已经启动的容器\"><a href=\"#停止一个已经启动的容器\" class=\"headerlink\" title=\"停止一个已经启动的容器\"></a>停止一个已经启动的容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker stop b750bbbcfd88(容器id)</code></pre>\n<h1 id=\"后台运行容器-不想进入容器的时候\"><a href=\"#后台运行容器-不想进入容器的时候\" class=\"headerlink\" title=\"后台运行容器(不想进入容器的时候)\"></a>后台运行容器(不想进入容器的时候)</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker -itd --name content_8 centos8 &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明-1\"><a href=\"#参数说明-1\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><ul>\n<li><p>-i：交互式操作</p>\n</li>\n<li><p>-t: 终端</p>\n</li>\n<li><p>-d: 后台运行</p>\n</li>\n<li><p>–name: 运行时指定容器的名称</p>\n</li>\n<li><p>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</p>\n<h1 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h1><p>在使用参数 <code>-d</code> 时, 容器会进入后台, 这个时候如果想要进入容器内部可以使用以下命令</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker exec -it [容器ID] &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明-2\"><a href=\"#参数说明-2\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2></li>\n<li><p>-i：交互式操作</p>\n</li>\n<li><p>-t: 终端</p>\n</li>\n<li><p>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</p>\n<h1 id=\"导入和导出容器\"><a href=\"#导入和导出容器\" class=\"headerlink\" title=\"导入和导出容器\"></a>导入和导出容器</h1><h2 id=\"导出容器\"><a href=\"#导出容器\" class=\"headerlink\" title=\"导出容器\"></a>导出容器</h2><p>如果要导出到本地的某个容器, 可以使用 <code>docker export</code> 命令</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker export [容器ID] &gt; centos8.tar</code></pre>\n<blockquote>\n<p>导出容器ID到本地文件的 centos8.tar</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"导入容器\"><a href=\"#导入容器\" class=\"headerlink\" title=\"导入容器\"></a>导入容器</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ cat docker&#x2F;ubuntu.tar | docker import - test&#x2F;ubuntu:v1</code></pre>\n<p>此外, 还可以通过指定URL或某个目录来导入</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker import http:&#x2F;&#x2F;example.com&#x2F;exampleimage.tgz example&#x2F;imagerepo</code></pre>\n<h2 id=\"删除容器\"><a href=\"#删除容器\" class=\"headerlink\" title=\"删除容器\"></a>删除容器</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker rm -f [容器ID]</code></pre>\n<p>清除所有处于终止状态下的容器</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker container prune</code></pre>\n\n"},{"title":"基础 - 任意值","cover":"https://whitelabelcoders.com/app/uploads/18.jpg","_content":"\n# 任意值\n\n任意值（Any）用来表示允许赋值为任意类型。\n\n## 什么是任意值类型\n\n如果是一个普通类型，在赋值过程中改变类型是不被允许的：\n\n```TypeScript\nlet myFavoriteNumber: string = 'seven';\nmyFavoriteNumber = 7;\n\n// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.\n```\n\n但如果是 any 类型，则允许被赋值为任意类型\n\n```TypeScript\nlet myFavoriteNumber: any = 'seven';\nmyFavoriteNumber = 7;\n```\n\n## 任意值的属性和方法\n\n在任意值上访问任何属性都是允许的：\n\n```TypeScript\nlet anyThing: any = 'hello';\nconsole.log(anyThing.myName);\nconsole.log(anyThing.myName.firstName);\n```\n\n也可以调用任何方法\n\n```TypeScript\nlet anyThing: any = 'Tom';\nanyThing.setName('Jerry');\nanyThing.setName('Jerry').sayHello();\nanyThing.myName.setFirstName('Cat');\n```\n\n可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值\n\n## 未声明类型的变量\n\n变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：\n\n```TypeScript\nlet something;\nsomething = 'seven';\nsomething = 7;\n\nsomething.setName('Tom');\n```\n\n等价于\n\n```TypeScript\nlet something: any;\nsomething = 'seven';\nsomething = 7;\n\nsomething.setName('Tom');\n```\n\n## 参考\n\n- [Basic Types # Any（中文版）](https://www.typescriptlang.org/zh/docs/handbook/2/everyday-types.html)","source":"_posts/typescript/基础/任意值.md","raw":"---\ntitle: 基础 - 任意值\ncover: https://whitelabelcoders.com/app/uploads/18.jpg\ncategories:\n  - TypeScript入门\ntags:\n  - TypeScript\n  - 基础\n---\n\n# 任意值\n\n任意值（Any）用来表示允许赋值为任意类型。\n\n## 什么是任意值类型\n\n如果是一个普通类型，在赋值过程中改变类型是不被允许的：\n\n```TypeScript\nlet myFavoriteNumber: string = 'seven';\nmyFavoriteNumber = 7;\n\n// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.\n```\n\n但如果是 any 类型，则允许被赋值为任意类型\n\n```TypeScript\nlet myFavoriteNumber: any = 'seven';\nmyFavoriteNumber = 7;\n```\n\n## 任意值的属性和方法\n\n在任意值上访问任何属性都是允许的：\n\n```TypeScript\nlet anyThing: any = 'hello';\nconsole.log(anyThing.myName);\nconsole.log(anyThing.myName.firstName);\n```\n\n也可以调用任何方法\n\n```TypeScript\nlet anyThing: any = 'Tom';\nanyThing.setName('Jerry');\nanyThing.setName('Jerry').sayHello();\nanyThing.myName.setFirstName('Cat');\n```\n\n可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值\n\n## 未声明类型的变量\n\n变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：\n\n```TypeScript\nlet something;\nsomething = 'seven';\nsomething = 7;\n\nsomething.setName('Tom');\n```\n\n等价于\n\n```TypeScript\nlet something: any;\nsomething = 'seven';\nsomething = 7;\n\nsomething.setName('Tom');\n```\n\n## 参考\n\n- [Basic Types # Any（中文版）](https://www.typescriptlang.org/zh/docs/handbook/2/everyday-types.html)","slug":"typescript/基础/任意值","published":1,"date":"2023-01-05T07:02:13.455Z","updated":"2023-01-05T07:53:56.019Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clck4pkza000b2ovn7khv8rcb","content":"<h1 id=\"任意值\"><a href=\"#任意值\" class=\"headerlink\" title=\"任意值\"></a>任意值</h1><p>任意值（Any）用来表示允许赋值为任意类型。</p>\n<h2 id=\"什么是任意值类型\"><a href=\"#什么是任意值类型\" class=\"headerlink\" title=\"什么是任意值类型\"></a>什么是任意值类型</h2><p>如果是一个普通类型，在赋值过程中改变类型是不被允许的：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: string &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre>\n\n<p>但如果是 any 类型，则允许被赋值为任意类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: any &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;</code></pre>\n\n<h2 id=\"任意值的属性和方法\"><a href=\"#任意值的属性和方法\" class=\"headerlink\" title=\"任意值的属性和方法\"></a>任意值的属性和方法</h2><p>在任意值上访问任何属性都是允许的：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let anyThing: any &#x3D; &#39;hello&#39;;\nconsole.log(anyThing.myName);\nconsole.log(anyThing.myName.firstName);</code></pre>\n\n<p>也可以调用任何方法</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let anyThing: any &#x3D; &#39;Tom&#39;;\nanyThing.setName(&#39;Jerry&#39;);\nanyThing.setName(&#39;Jerry&#39;).sayHello();\nanyThing.myName.setFirstName(&#39;Cat&#39;);</code></pre>\n\n<p>可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</p>\n<h2 id=\"未声明类型的变量\"><a href=\"#未声明类型的变量\" class=\"headerlink\" title=\"未声明类型的变量\"></a>未声明类型的变量</h2><p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let something;\nsomething &#x3D; &#39;seven&#39;;\nsomething &#x3D; 7;\n\nsomething.setName(&#39;Tom&#39;);</code></pre>\n\n<p>等价于</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let something: any;\nsomething &#x3D; &#39;seven&#39;;\nsomething &#x3D; 7;\n\nsomething.setName(&#39;Tom&#39;);</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.typescriptlang.org/zh/docs/handbook/2/everyday-types.html\">Basic Types # Any（中文版）</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"任意值\"><a href=\"#任意值\" class=\"headerlink\" title=\"任意值\"></a>任意值</h1><p>任意值（Any）用来表示允许赋值为任意类型。</p>\n<h2 id=\"什么是任意值类型\"><a href=\"#什么是任意值类型\" class=\"headerlink\" title=\"什么是任意值类型\"></a>什么是任意值类型</h2><p>如果是一个普通类型，在赋值过程中改变类型是不被允许的：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: string &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre>\n\n<p>但如果是 any 类型，则允许被赋值为任意类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: any &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;</code></pre>\n\n<h2 id=\"任意值的属性和方法\"><a href=\"#任意值的属性和方法\" class=\"headerlink\" title=\"任意值的属性和方法\"></a>任意值的属性和方法</h2><p>在任意值上访问任何属性都是允许的：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let anyThing: any &#x3D; &#39;hello&#39;;\nconsole.log(anyThing.myName);\nconsole.log(anyThing.myName.firstName);</code></pre>\n\n<p>也可以调用任何方法</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let anyThing: any &#x3D; &#39;Tom&#39;;\nanyThing.setName(&#39;Jerry&#39;);\nanyThing.setName(&#39;Jerry&#39;).sayHello();\nanyThing.myName.setFirstName(&#39;Cat&#39;);</code></pre>\n\n<p>可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</p>\n<h2 id=\"未声明类型的变量\"><a href=\"#未声明类型的变量\" class=\"headerlink\" title=\"未声明类型的变量\"></a>未声明类型的变量</h2><p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let something;\nsomething &#x3D; &#39;seven&#39;;\nsomething &#x3D; 7;\n\nsomething.setName(&#39;Tom&#39;);</code></pre>\n\n<p>等价于</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let something: any;\nsomething &#x3D; &#39;seven&#39;;\nsomething &#x3D; 7;\n\nsomething.setName(&#39;Tom&#39;);</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.typescriptlang.org/zh/docs/handbook/2/everyday-types.html\">Basic Types # Any（中文版）</a></li>\n</ul>\n"},{"title":"基础 - 函数的类型","cover":"https://whitelabelcoders.com/app/uploads/18.jpg","_content":"\n# 函数的类型\n\n## 函数的声明\n\n一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：\n\n```TypeScript\nfunction sum(x: number, y:number): number {\n  return x + y\n}\n```\n\n:::tip\n输入多余的（或者少于要求的）参数，都是不被允许的\n:::\n\n## 函数表达式\n\n我们现在写一个对函数的表达式( Function Expression ), 可能会写成这样\n\n```TypeScript\nlet mySum = function (x: number, y: number): number {\n    return x + y;\n};\n```\n\n这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 `mySum`，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 `mySum` 添加类型，则应该是这样：\n\n```ts\nlet mySum: (x: number, y: number) => number = function (x: number, y: number): number {\n    return x + y;\n};\n```\n\n注意不要混淆了 TypeScript 中的 `=>` 和 ES6 中的 `=>`。\n\n在 TypeScript 的类型定义中，`=>` 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。\n\n在 ES6 中，`=>` 叫做箭头函数，应用十分广泛，可以参考 [ES6 中的箭头函数](http://es6.ruanyifeng.com/#docs/function#箭头函数)。\n\n## 用接口定义函数的形状\n\n我们也可以使用接口的方式来定义一个函数需要符合的形状：\n\n```ts\ninterface SearchFunc {\n    (source: string, subString: string): boolean;\n}\n\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n    return source.search(subString) !== -1;\n}\n```\n\n采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。\n\n\n\n## 可选参数\n\n可选参数必须在必选参数的后面\n\n```ts\nfunction buildName(firstName: string, lastName?: string) {\n    if (lastName) {\n        return firstName + ' ' + lastName;\n    } else {\n        return firstName;\n    }\n}\n```\n\n需要注意的是, **可选参数后面不允许出现比选参数了**\n\n## 参数默认值\n\n在 ES6 中，我们允许给函数的参数添加默认值，**TypeScript 会将添加了默认值的参数识别为可选参数**：\n\n```ts\nfunction buildName(firstName: string, lastName: string = 'Cat') {\n    return firstName + ' ' + lastName;\n}\n```\n\n 给了参数默认值后就不受**可选参数必须在必选参数的后面**的限制了\n\n```ts\nfunction buildName(firstName?: string = 'dog', lastName: string) {\n    return firstName + ' ' + lastName;\n}\n```\n\n## 剩余参数\n\n在ES6中, 可以使用`...items`的方式来获取函数中的剩余参数(res参数)","source":"_posts/typescript/基础/函数的类型.md","raw":"---\ntitle: 基础 - 函数的类型\ncover: https://whitelabelcoders.com/app/uploads/18.jpg\ncategories:\n  - TypeScript入门\ntags:\n  - TypeScript\n  - 类型\n  - 函数\n---\n\n# 函数的类型\n\n## 函数的声明\n\n一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：\n\n```TypeScript\nfunction sum(x: number, y:number): number {\n  return x + y\n}\n```\n\n:::tip\n输入多余的（或者少于要求的）参数，都是不被允许的\n:::\n\n## 函数表达式\n\n我们现在写一个对函数的表达式( Function Expression ), 可能会写成这样\n\n```TypeScript\nlet mySum = function (x: number, y: number): number {\n    return x + y;\n};\n```\n\n这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 `mySum`，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 `mySum` 添加类型，则应该是这样：\n\n```ts\nlet mySum: (x: number, y: number) => number = function (x: number, y: number): number {\n    return x + y;\n};\n```\n\n注意不要混淆了 TypeScript 中的 `=>` 和 ES6 中的 `=>`。\n\n在 TypeScript 的类型定义中，`=>` 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。\n\n在 ES6 中，`=>` 叫做箭头函数，应用十分广泛，可以参考 [ES6 中的箭头函数](http://es6.ruanyifeng.com/#docs/function#箭头函数)。\n\n## 用接口定义函数的形状\n\n我们也可以使用接口的方式来定义一个函数需要符合的形状：\n\n```ts\ninterface SearchFunc {\n    (source: string, subString: string): boolean;\n}\n\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n    return source.search(subString) !== -1;\n}\n```\n\n采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。\n\n\n\n## 可选参数\n\n可选参数必须在必选参数的后面\n\n```ts\nfunction buildName(firstName: string, lastName?: string) {\n    if (lastName) {\n        return firstName + ' ' + lastName;\n    } else {\n        return firstName;\n    }\n}\n```\n\n需要注意的是, **可选参数后面不允许出现比选参数了**\n\n## 参数默认值\n\n在 ES6 中，我们允许给函数的参数添加默认值，**TypeScript 会将添加了默认值的参数识别为可选参数**：\n\n```ts\nfunction buildName(firstName: string, lastName: string = 'Cat') {\n    return firstName + ' ' + lastName;\n}\n```\n\n 给了参数默认值后就不受**可选参数必须在必选参数的后面**的限制了\n\n```ts\nfunction buildName(firstName?: string = 'dog', lastName: string) {\n    return firstName + ' ' + lastName;\n}\n```\n\n## 剩余参数\n\n在ES6中, 可以使用`...items`的方式来获取函数中的剩余参数(res参数)","slug":"typescript/基础/函数的类型","published":1,"date":"2023-01-06T02:30:32.294Z","updated":"2023-01-06T06:01:00.745Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clck4pkzc000f2ovncnrl5ffy","content":"<h1 id=\"函数的类型\"><a href=\"#函数的类型\" class=\"headerlink\" title=\"函数的类型\"></a>函数的类型</h1><h2 id=\"函数的声明\"><a href=\"#函数的声明\" class=\"headerlink\" title=\"函数的声明\"></a>函数的声明</h2><p>一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function sum(x: number, y:number): number &#123;\n  return x + y\n&#125;</code></pre>\n\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>输入多余的（或者少于要求的）参数，都是不被允许的</p>\n</div>\n<h2 id=\"函数表达式\"><a href=\"#函数表达式\" class=\"headerlink\" title=\"函数表达式\"></a>函数表达式</h2><p>我们现在写一个对函数的表达式( Function Expression ), 可能会写成这样</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let mySum &#x3D; function (x: number, y: number): number &#123;\n    return x + y;\n&#125;;</code></pre>\n\n<p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 <code>mySum</code>，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 <code>mySum</code> 添加类型，则应该是这样：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let mySum: (x: number, y: number) &#x3D;&gt; number &#x3D; function (x: number, y: number): number &#123;\n    return x + y;\n&#125;;</code></pre>\n\n<p>注意不要混淆了 TypeScript 中的 <code>=&gt;</code> 和 ES6 中的 <code>=&gt;</code>。</p>\n<p>在 TypeScript 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p>\n<p>在 ES6 中，<code>=&gt;</code> 叫做箭头函数，应用十分广泛，可以参考 <a href=\"http://es6.ruanyifeng.com/#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0\">ES6 中的箭头函数</a>。</p>\n<h2 id=\"用接口定义函数的形状\"><a href=\"#用接口定义函数的形状\" class=\"headerlink\" title=\"用接口定义函数的形状\"></a>用接口定义函数的形状</h2><p>我们也可以使用接口的方式来定义一个函数需要符合的形状：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface SearchFunc &#123;\n    (source: string, subString: string): boolean;\n&#125;\n\nlet mySearch: SearchFunc;\nmySearch &#x3D; function(source: string, subString: string) &#123;\n    return source.search(subString) !&#x3D;&#x3D; -1;\n&#125;</code></pre>\n\n<p>采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p>\n<h2 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h2><p>可选参数必须在必选参数的后面</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function buildName(firstName: string, lastName?: string) &#123;\n    if (lastName) &#123;\n        return firstName + &#39; &#39; + lastName;\n    &#125; else &#123;\n        return firstName;\n    &#125;\n&#125;</code></pre>\n\n<p>需要注意的是, <strong>可选参数后面不允许出现比选参数了</strong></p>\n<h2 id=\"参数默认值\"><a href=\"#参数默认值\" class=\"headerlink\" title=\"参数默认值\"></a>参数默认值</h2><p>在 ES6 中，我们允许给函数的参数添加默认值，<strong>TypeScript 会将添加了默认值的参数识别为可选参数</strong>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function buildName(firstName: string, lastName: string &#x3D; &#39;Cat&#39;) &#123;\n    return firstName + &#39; &#39; + lastName;\n&#125;</code></pre>\n\n<p> 给了参数默认值后就不受<strong>可选参数必须在必选参数的后面</strong>的限制了</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function buildName(firstName?: string &#x3D; &#39;dog&#39;, lastName: string) &#123;\n    return firstName + &#39; &#39; + lastName;\n&#125;</code></pre>\n\n<h2 id=\"剩余参数\"><a href=\"#剩余参数\" class=\"headerlink\" title=\"剩余参数\"></a>剩余参数</h2><p>在ES6中, 可以使用<code>...items</code>的方式来获取函数中的剩余参数(res参数)</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"函数的类型\"><a href=\"#函数的类型\" class=\"headerlink\" title=\"函数的类型\"></a>函数的类型</h1><h2 id=\"函数的声明\"><a href=\"#函数的声明\" class=\"headerlink\" title=\"函数的声明\"></a>函数的声明</h2><p>一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function sum(x: number, y:number): number &#123;\n  return x + y\n&#125;</code></pre>\n\n<p>:::tip<br>输入多余的（或者少于要求的）参数，都是不被允许的<br>:::</p>\n<h2 id=\"函数表达式\"><a href=\"#函数表达式\" class=\"headerlink\" title=\"函数表达式\"></a>函数表达式</h2><p>我们现在写一个对函数的表达式( Function Expression ), 可能会写成这样</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let mySum &#x3D; function (x: number, y: number): number &#123;\n    return x + y;\n&#125;;</code></pre>\n\n<p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 <code>mySum</code>，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 <code>mySum</code> 添加类型，则应该是这样：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let mySum: (x: number, y: number) &#x3D;&gt; number &#x3D; function (x: number, y: number): number &#123;\n    return x + y;\n&#125;;</code></pre>\n\n<p>注意不要混淆了 TypeScript 中的 <code>=&gt;</code> 和 ES6 中的 <code>=&gt;</code>。</p>\n<p>在 TypeScript 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p>\n<p>在 ES6 中，<code>=&gt;</code> 叫做箭头函数，应用十分广泛，可以参考 <a href=\"http://es6.ruanyifeng.com/#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0\">ES6 中的箭头函数</a>。</p>\n<h2 id=\"用接口定义函数的形状\"><a href=\"#用接口定义函数的形状\" class=\"headerlink\" title=\"用接口定义函数的形状\"></a>用接口定义函数的形状</h2><p>我们也可以使用接口的方式来定义一个函数需要符合的形状：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface SearchFunc &#123;\n    (source: string, subString: string): boolean;\n&#125;\n\nlet mySearch: SearchFunc;\nmySearch &#x3D; function(source: string, subString: string) &#123;\n    return source.search(subString) !&#x3D;&#x3D; -1;\n&#125;</code></pre>\n\n<p>采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p>\n<h2 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h2><p>可选参数必须在必选参数的后面</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function buildName(firstName: string, lastName?: string) &#123;\n    if (lastName) &#123;\n        return firstName + &#39; &#39; + lastName;\n    &#125; else &#123;\n        return firstName;\n    &#125;\n&#125;</code></pre>\n\n<p>需要注意的是, <strong>可选参数后面不允许出现比选参数了</strong></p>\n<h2 id=\"参数默认值\"><a href=\"#参数默认值\" class=\"headerlink\" title=\"参数默认值\"></a>参数默认值</h2><p>在 ES6 中，我们允许给函数的参数添加默认值，<strong>TypeScript 会将添加了默认值的参数识别为可选参数</strong>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function buildName(firstName: string, lastName: string &#x3D; &#39;Cat&#39;) &#123;\n    return firstName + &#39; &#39; + lastName;\n&#125;</code></pre>\n\n<p> 给了参数默认值后就不受<strong>可选参数必须在必选参数的后面</strong>的限制了</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function buildName(firstName?: string &#x3D; &#39;dog&#39;, lastName: string) &#123;\n    return firstName + &#39; &#39; + lastName;\n&#125;</code></pre>\n\n<h2 id=\"剩余参数\"><a href=\"#剩余参数\" class=\"headerlink\" title=\"剩余参数\"></a>剩余参数</h2><p>在ES6中, 可以使用<code>...items</code>的方式来获取函数中的剩余参数(res参数)</p>\n"},{"title":"基础 - 原始数据类型","cover":"https://whitelabelcoders.com/app/uploads/18.jpg","_content":"\n# 基础 - 原始数据类型\n\nJavaScript的数据类型分为两种: 原始数据类型([Primitive Data types](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive))和对象类型(Object types)\n\n原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。\n\n## 布尔值\n\n布尔值是最基础的数据类型, 在TypeScript中, 使用 `boolean`布尔值类型\n\n```TypeScript\nlet isMan: boolean = true\n\n// 编译通过\n```\n\n:::tip\n注意，使用构造函数 Boolean 创造的对象不是布尔值：\n:::\n\n```TypeScript\nlet createByNewBoolean: boolean = new Boolean(1)\n\n// 此时会编译报错\n// Type 'Boolean' is not assignable to type 'boolean'.\n//   'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible.\n```\n\n事实上 `new Boolean()` 返回的是一个`Boolean`对象:\n\n:::tip\n直接调用`Boolean`也可以返回一个boolean类型\n\n```TypeScript\nlet createdByBoolean: boolean = Boolean(1);\n```\n\n:::\n\n在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。\n\n## 数值\n\n使用 `number`定义数值类型\n\n```TypeScript\nlet decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\n// ES6 中的二进制表示法\nlet binaryLiteral: number = 0b1010;\n// ES6 中的八进制表示法\nlet octalLiteral: number = 0o744;\nlet notANumber: number = NaN;\nlet infinityNumber: number = Infinity;\n```\n\ntsc的编译结果\n\n```TypeScript\nvar decLiteral = 6;\nvar hexLiteral = 0xf00d;\n// ES6 中的二进制表示法\nvar binaryLiteral = 10;\n// ES6 中的八进制表示法\nvar octalLiteral = 484;\nvar notANumber = NaN;\nvar infinityNumber = Infinity;\n```\n\n其中 0b1010 和 0o744 是 [ES6 中的二进制和八进制表示法](https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95)，它们会被编译为十进制数字。\n\n## 字符串\n\n使用 `string`定义字符串类型\n\n```TypeScript\nlet str: string = 'jeck'\n\n// 模板字符串\nlet str_o: string = `my name is ${str}`\n```\n\n编译结果:\n\n```TypeScript\nvar str = jeck\n\n// 模板字符串\nvar str_o = 'my name is' + str\n```\n\n## 空值\n\nJavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：\n\n```TypeScript\nfunction alertName(): void {\n    alert('My name is Tom');\n}\n```\n\n声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null（只在 --strictNullChecks 未指定时）：\n\n```TypeScript\nlet unusable: void = undefined;\n```\n\n## Null 和 Undefined\n\n在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：\n\n```TypeScript\nlet u: undefined = undefined;\nlet n: null = null;\n```\n\n> 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：\n\n```TypeScript\n// 这样不会报错\nlet num: number = undefined;\n```\n\n```TypeScript\n// 这样也不会报错\nlet u: undefined;\nlet num: number = u;\n```\n\n而 void 类型的变量不能赋值给 number 类型的变量：\n\n```TypeScript\nlet u: void;\nlet num: number = u;\n\n// Type 'void' is not assignable to type 'number'.\n```\n\n## 参考\n\n- [Basic Types（中文版）](https://www.typescriptlang.org/zh/docs/handbook/2/everyday-types.html)\n- [Primitive data types](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)\n- [ES6 中的新类型 Symbol](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n- [ES6 中的二进制和八进制表示法](https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95)\n- [ES6 中的模板字符串](http://es6.ruanyifeng.com/#docs/string#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2)","source":"_posts/typescript/基础/原始数据类型.md","raw":"---\ntitle: 基础 - 原始数据类型\ncover: https://whitelabelcoders.com/app/uploads/18.jpg\ncategories:\n  - TypeScript入门\ntags:\n  - TypeScript\n  - 基础\n---\n\n# 基础 - 原始数据类型\n\nJavaScript的数据类型分为两种: 原始数据类型([Primitive Data types](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive))和对象类型(Object types)\n\n原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。\n\n## 布尔值\n\n布尔值是最基础的数据类型, 在TypeScript中, 使用 `boolean`布尔值类型\n\n```TypeScript\nlet isMan: boolean = true\n\n// 编译通过\n```\n\n:::tip\n注意，使用构造函数 Boolean 创造的对象不是布尔值：\n:::\n\n```TypeScript\nlet createByNewBoolean: boolean = new Boolean(1)\n\n// 此时会编译报错\n// Type 'Boolean' is not assignable to type 'boolean'.\n//   'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible.\n```\n\n事实上 `new Boolean()` 返回的是一个`Boolean`对象:\n\n:::tip\n直接调用`Boolean`也可以返回一个boolean类型\n\n```TypeScript\nlet createdByBoolean: boolean = Boolean(1);\n```\n\n:::\n\n在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。\n\n## 数值\n\n使用 `number`定义数值类型\n\n```TypeScript\nlet decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\n// ES6 中的二进制表示法\nlet binaryLiteral: number = 0b1010;\n// ES6 中的八进制表示法\nlet octalLiteral: number = 0o744;\nlet notANumber: number = NaN;\nlet infinityNumber: number = Infinity;\n```\n\ntsc的编译结果\n\n```TypeScript\nvar decLiteral = 6;\nvar hexLiteral = 0xf00d;\n// ES6 中的二进制表示法\nvar binaryLiteral = 10;\n// ES6 中的八进制表示法\nvar octalLiteral = 484;\nvar notANumber = NaN;\nvar infinityNumber = Infinity;\n```\n\n其中 0b1010 和 0o744 是 [ES6 中的二进制和八进制表示法](https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95)，它们会被编译为十进制数字。\n\n## 字符串\n\n使用 `string`定义字符串类型\n\n```TypeScript\nlet str: string = 'jeck'\n\n// 模板字符串\nlet str_o: string = `my name is ${str}`\n```\n\n编译结果:\n\n```TypeScript\nvar str = jeck\n\n// 模板字符串\nvar str_o = 'my name is' + str\n```\n\n## 空值\n\nJavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：\n\n```TypeScript\nfunction alertName(): void {\n    alert('My name is Tom');\n}\n```\n\n声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null（只在 --strictNullChecks 未指定时）：\n\n```TypeScript\nlet unusable: void = undefined;\n```\n\n## Null 和 Undefined\n\n在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：\n\n```TypeScript\nlet u: undefined = undefined;\nlet n: null = null;\n```\n\n> 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：\n\n```TypeScript\n// 这样不会报错\nlet num: number = undefined;\n```\n\n```TypeScript\n// 这样也不会报错\nlet u: undefined;\nlet num: number = u;\n```\n\n而 void 类型的变量不能赋值给 number 类型的变量：\n\n```TypeScript\nlet u: void;\nlet num: number = u;\n\n// Type 'void' is not assignable to type 'number'.\n```\n\n## 参考\n\n- [Basic Types（中文版）](https://www.typescriptlang.org/zh/docs/handbook/2/everyday-types.html)\n- [Primitive data types](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)\n- [ES6 中的新类型 Symbol](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n- [ES6 中的二进制和八进制表示法](https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95)\n- [ES6 中的模板字符串](http://es6.ruanyifeng.com/#docs/string#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2)","slug":"typescript/基础/原始数据类型","published":1,"date":"2023-01-05T02:23:28.205Z","updated":"2023-01-05T07:54:11.780Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clck4pkzd000h2ovn7x576jke","content":"<h1 id=\"基础-原始数据类型\"><a href=\"#基础-原始数据类型\" class=\"headerlink\" title=\"基础 - 原始数据类型\"></a>基础 - 原始数据类型</h1><p>JavaScript的数据类型分为两种: 原始数据类型(<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive\">Primitive Data types</a>)和对象类型(Object types)</p>\n<p>原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。</p>\n<h2 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h2><p>布尔值是最基础的数据类型, 在TypeScript中, 使用 <code>boolean</code>布尔值类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let isMan: boolean &#x3D; true\n\n&#x2F;&#x2F; 编译通过</code></pre>\n\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>注意，使用构造函数 Boolean 创造的对象不是布尔值：</p>\n</div>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let createByNewBoolean: boolean &#x3D; new Boolean(1)\n\n&#x2F;&#x2F; 此时会编译报错\n&#x2F;&#x2F; Type &#39;Boolean&#39; is not assignable to type &#39;boolean&#39;.\n&#x2F;&#x2F;   &#39;boolean&#39; is a primitive, but &#39;Boolean&#39; is a wrapper object. Prefer using &#39;boolean&#39; when possible.</code></pre>\n\n<p>事实上 <code>new Boolean()</code> 返回的是一个<code>Boolean</code>对象:</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>直接调用<code>Boolean</code>也可以返回一个boolean类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let createdByBoolean: boolean &#x3D; Boolean(1);</code></pre>\n\n</p>\n</div>\n<p>在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。</p>\n<h2 id=\"数值\"><a href=\"#数值\" class=\"headerlink\" title=\"数值\"></a>数值</h2><p>使用 <code>number</code>定义数值类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let decLiteral: number &#x3D; 6;\nlet hexLiteral: number &#x3D; 0xf00d;\n&#x2F;&#x2F; ES6 中的二进制表示法\nlet binaryLiteral: number &#x3D; 0b1010;\n&#x2F;&#x2F; ES6 中的八进制表示法\nlet octalLiteral: number &#x3D; 0o744;\nlet notANumber: number &#x3D; NaN;\nlet infinityNumber: number &#x3D; Infinity;</code></pre>\n\n<p>tsc的编译结果</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">var decLiteral &#x3D; 6;\nvar hexLiteral &#x3D; 0xf00d;\n&#x2F;&#x2F; ES6 中的二进制表示法\nvar binaryLiteral &#x3D; 10;\n&#x2F;&#x2F; ES6 中的八进制表示法\nvar octalLiteral &#x3D; 484;\nvar notANumber &#x3D; NaN;\nvar infinityNumber &#x3D; Infinity;</code></pre>\n\n<p>其中 0b1010 和 0o744 是 <a href=\"https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95\">ES6 中的二进制和八进制表示法</a>，它们会被编译为十进制数字。</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>使用 <code>string</code>定义字符串类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let str: string &#x3D; &#39;jeck&#39;\n\n&#x2F;&#x2F; 模板字符串\nlet str_o: string &#x3D; &#96;my name is $&#123;str&#125;&#96;</code></pre>\n\n<p>编译结果:</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">var str &#x3D; jeck\n\n&#x2F;&#x2F; 模板字符串\nvar str_o &#x3D; &#39;my name is&#39; + str</code></pre>\n\n<h2 id=\"空值\"><a href=\"#空值\" class=\"headerlink\" title=\"空值\"></a>空值</h2><p>JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function alertName(): void &#123;\n    alert(&#39;My name is Tom&#39;);\n&#125;</code></pre>\n\n<p>声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null（只在 –strictNullChecks 未指定时）：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let unusable: void &#x3D; undefined;</code></pre>\n\n<h2 id=\"Null-和-Undefined\"><a href=\"#Null-和-Undefined\" class=\"headerlink\" title=\"Null 和 Undefined\"></a>Null 和 Undefined</h2><p>在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let u: undefined &#x3D; undefined;\nlet n: null &#x3D; null;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：</p></blockquote>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">&#x2F;&#x2F; 这样不会报错\nlet num: number &#x3D; undefined;</code></pre>\n\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">&#x2F;&#x2F; 这样也不会报错\nlet u: undefined;\nlet num: number &#x3D; u;</code></pre>\n\n<p>而 void 类型的变量不能赋值给 number 类型的变量：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let u: void;\nlet num: number &#x3D; u;\n\n&#x2F;&#x2F; Type &#39;void&#39; is not assignable to type &#39;number&#39;.</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.typescriptlang.org/zh/docs/handbook/2/everyday-types.html\">Basic Types（中文版）</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive\">Primitive data types</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">ES6 中的新类型 Symbol</a></li>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95\">ES6 中的二进制和八进制表示法</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/string#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2\">ES6 中的模板字符串</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基础-原始数据类型\"><a href=\"#基础-原始数据类型\" class=\"headerlink\" title=\"基础 - 原始数据类型\"></a>基础 - 原始数据类型</h1><p>JavaScript的数据类型分为两种: 原始数据类型(<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive\">Primitive Data types</a>)和对象类型(Object types)</p>\n<p>原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。</p>\n<h2 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h2><p>布尔值是最基础的数据类型, 在TypeScript中, 使用 <code>boolean</code>布尔值类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let isMan: boolean &#x3D; true\n\n&#x2F;&#x2F; 编译通过</code></pre>\n\n<p>:::tip<br>注意，使用构造函数 Boolean 创造的对象不是布尔值：<br>:::</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let createByNewBoolean: boolean &#x3D; new Boolean(1)\n\n&#x2F;&#x2F; 此时会编译报错\n&#x2F;&#x2F; Type &#39;Boolean&#39; is not assignable to type &#39;boolean&#39;.\n&#x2F;&#x2F;   &#39;boolean&#39; is a primitive, but &#39;Boolean&#39; is a wrapper object. Prefer using &#39;boolean&#39; when possible.</code></pre>\n\n<p>事实上 <code>new Boolean()</code> 返回的是一个<code>Boolean</code>对象:</p>\n<p>:::tip<br>直接调用<code>Boolean</code>也可以返回一个boolean类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let createdByBoolean: boolean &#x3D; Boolean(1);</code></pre>\n\n<p>:::</p>\n<p>在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。</p>\n<h2 id=\"数值\"><a href=\"#数值\" class=\"headerlink\" title=\"数值\"></a>数值</h2><p>使用 <code>number</code>定义数值类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let decLiteral: number &#x3D; 6;\nlet hexLiteral: number &#x3D; 0xf00d;\n&#x2F;&#x2F; ES6 中的二进制表示法\nlet binaryLiteral: number &#x3D; 0b1010;\n&#x2F;&#x2F; ES6 中的八进制表示法\nlet octalLiteral: number &#x3D; 0o744;\nlet notANumber: number &#x3D; NaN;\nlet infinityNumber: number &#x3D; Infinity;</code></pre>\n\n<p>tsc的编译结果</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">var decLiteral &#x3D; 6;\nvar hexLiteral &#x3D; 0xf00d;\n&#x2F;&#x2F; ES6 中的二进制表示法\nvar binaryLiteral &#x3D; 10;\n&#x2F;&#x2F; ES6 中的八进制表示法\nvar octalLiteral &#x3D; 484;\nvar notANumber &#x3D; NaN;\nvar infinityNumber &#x3D; Infinity;</code></pre>\n\n<p>其中 0b1010 和 0o744 是 <a href=\"https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95\">ES6 中的二进制和八进制表示法</a>，它们会被编译为十进制数字。</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>使用 <code>string</code>定义字符串类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let str: string &#x3D; &#39;jeck&#39;\n\n&#x2F;&#x2F; 模板字符串\nlet str_o: string &#x3D; &#96;my name is $&#123;str&#125;&#96;</code></pre>\n\n<p>编译结果:</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">var str &#x3D; jeck\n\n&#x2F;&#x2F; 模板字符串\nvar str_o &#x3D; &#39;my name is&#39; + str</code></pre>\n\n<h2 id=\"空值\"><a href=\"#空值\" class=\"headerlink\" title=\"空值\"></a>空值</h2><p>JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function alertName(): void &#123;\n    alert(&#39;My name is Tom&#39;);\n&#125;</code></pre>\n\n<p>声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null（只在 –strictNullChecks 未指定时）：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let unusable: void &#x3D; undefined;</code></pre>\n\n<h2 id=\"Null-和-Undefined\"><a href=\"#Null-和-Undefined\" class=\"headerlink\" title=\"Null 和 Undefined\"></a>Null 和 Undefined</h2><p>在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let u: undefined &#x3D; undefined;\nlet n: null &#x3D; null;</code></pre>\n\n<blockquote>\n<p>与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：</p>\n</blockquote>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">&#x2F;&#x2F; 这样不会报错\nlet num: number &#x3D; undefined;</code></pre>\n\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">&#x2F;&#x2F; 这样也不会报错\nlet u: undefined;\nlet num: number &#x3D; u;</code></pre>\n\n<p>而 void 类型的变量不能赋值给 number 类型的变量：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let u: void;\nlet num: number &#x3D; u;\n\n&#x2F;&#x2F; Type &#39;void&#39; is not assignable to type &#39;number&#39;.</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.typescriptlang.org/zh/docs/handbook/2/everyday-types.html\">Basic Types（中文版）</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive\">Primitive data types</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">ES6 中的新类型 Symbol</a></li>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95\">ES6 中的二进制和八进制表示法</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/string#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2\">ES6 中的模板字符串</a></li>\n</ul>\n"},{"title":"基础 - 对象的类型——接口","cover":"https://whitelabelcoders.com/app/uploads/18.jpg","_content":"\n# 对象的类型——接口\n\n在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。\n\n## 什么是接口\n\n在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。\n\nTypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。\n\n## 简单的例子\n\n```TypeScript\ninterface Person {\n    name: string;\n    age: number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25\n};\n```\n\n上面的例子中，我们定义了一个接口 `Person`，接着定义了一个变量 `tom`，它的类型是 `Person`。这样，我们就约束了 `tom` 的形状必须和接口 `Person` 一致。\n\n接口一般首字母大写。[有的编程语言中会建议接口的名称加上 I 前缀](https://msdn.microsoft.com/en-us/library/8bc1fexb%28v=vs.71%29.aspx)。\n\n定义的变量比接口少了一些属性是不允许的：\n\n```TypeScript\ninterface Person {\n    name: string;\n    age: number;\n}\n\nlet tom: Person = {\n    name: 'Tom'\n};\n\n// index.ts(6,5): error TS2322: Type '{ name: string; }' is not assignable to type 'Person'.\n//   Property 'age' is missing in type '{ name: string; }'.\n```\n\n多一些属性也是不允许的：\n\n```TypeScript\ninterface Person {\n    name: string;\n    age: number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n\n// index.ts(9,5): error TS2322: Type '{ name: string; age: number; gender: string; }' is not assignable to type 'Person'.\n//   Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.\n```\n\n可见，**赋值的时候，变量的形状必须和接口的形状保持一致**。\n\n## 可选属性\n\n有时我们希望不要完全匹配一个形状，那么可以用可选属性：\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n}\n\nlet tom: Person = {\n    name: 'Tom'\n};\n```\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25\n};\n```\n\n可选属性的含义是该属性可以不存在。\n\n这时**仍然不允许添加未定义的属性：**\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n\n// examples/playground/index.ts(9,5): error TS2322: Type '{ name: string; age: number; gender: string; }' is not assignable to type 'Person'.\n//   Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.\n```\n\n## 任意属性\n\n有时候我们希望一个接口允许有任意的属性，可以使用如下方式：\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    gender: 'male'\n};\n```\n\n使用 `[propName: string]` 定义了任意属性取 `string` 类型的值。\n\n需要注意的是，**一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的同类型或者子集：**\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: string;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n\n// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.\n// index.ts(7,5): error TS2322: Type '{ [x: string]: string | number; name: string; age: number; gender: string; }' is not assignable to type 'Person'.\n//   Index signatures are incompatible.\n//     Type 'string | number' is not assignable to type 'string'.\n//       Type 'number' is not assignable to type 'string'.\n```\n\n上例中，任意属性的值允许是 `string`，但是可选属性 `age` 的值却是 `number`，`number` 不是 `string` 的子属性，所以报错了。\n\n另外，在报错信息中可以看出，此时 `{ name: 'Tom', age: 25, gender: 'male' }` 的类型被推断成了 `{ [x: string]: string | number; name: string; age: number; gender: string; }`，这是联合类型和接口的结合。\n\n一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: string | number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n```\n\n## 只读属性\n\n有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 `readonly` 定义只读属性：\n\n```TypeScript\ninterface Person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    id: 89757,\n    name: 'Tom',\n    gender: 'male'\n};\n\ntom.id = 9527;\n\n// index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.\n```\n\n上例中，使用 `readonly` 定义的属性 `id` 初始化后，又被赋值了，所以报错了。\n\n**注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：**\n\n```TypeScript\ninterface Person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    gender: 'male'\n};\n\ntom.id = 89757;\n\n// index.ts(8,5): error TS2322: Type '{ name: string; gender: string; }' is not assignable to type 'Person'.\n//   Property 'id' is missing in type '{ name: string; gender: string; }'.\n// index.ts(13,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.\n```\n\n上例中，报错信息有两处，第一处是在对 `tom` 进行赋值的时候，没有给 `id` 赋值。\n\n第二处是在给 `tom.id` 赋值的时候，由于它是只读属性，所以报错了。\n\n## 参考\n\n- [Interfaces](http://www.typescriptlang.org/docs/handbook/interfaces.html)","source":"_posts/typescript/基础/对象的类型——接口.md","raw":"---\ntitle: 基础 - 对象的类型——接口\ncover: https://whitelabelcoders.com/app/uploads/18.jpg\ncategories:\n  - TypeScript入门\ntags:\n  - TypeScript\n  - 类型\n---\n\n# 对象的类型——接口\n\n在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。\n\n## 什么是接口\n\n在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。\n\nTypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。\n\n## 简单的例子\n\n```TypeScript\ninterface Person {\n    name: string;\n    age: number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25\n};\n```\n\n上面的例子中，我们定义了一个接口 `Person`，接着定义了一个变量 `tom`，它的类型是 `Person`。这样，我们就约束了 `tom` 的形状必须和接口 `Person` 一致。\n\n接口一般首字母大写。[有的编程语言中会建议接口的名称加上 I 前缀](https://msdn.microsoft.com/en-us/library/8bc1fexb%28v=vs.71%29.aspx)。\n\n定义的变量比接口少了一些属性是不允许的：\n\n```TypeScript\ninterface Person {\n    name: string;\n    age: number;\n}\n\nlet tom: Person = {\n    name: 'Tom'\n};\n\n// index.ts(6,5): error TS2322: Type '{ name: string; }' is not assignable to type 'Person'.\n//   Property 'age' is missing in type '{ name: string; }'.\n```\n\n多一些属性也是不允许的：\n\n```TypeScript\ninterface Person {\n    name: string;\n    age: number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n\n// index.ts(9,5): error TS2322: Type '{ name: string; age: number; gender: string; }' is not assignable to type 'Person'.\n//   Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.\n```\n\n可见，**赋值的时候，变量的形状必须和接口的形状保持一致**。\n\n## 可选属性\n\n有时我们希望不要完全匹配一个形状，那么可以用可选属性：\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n}\n\nlet tom: Person = {\n    name: 'Tom'\n};\n```\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25\n};\n```\n\n可选属性的含义是该属性可以不存在。\n\n这时**仍然不允许添加未定义的属性：**\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n\n// examples/playground/index.ts(9,5): error TS2322: Type '{ name: string; age: number; gender: string; }' is not assignable to type 'Person'.\n//   Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.\n```\n\n## 任意属性\n\n有时候我们希望一个接口允许有任意的属性，可以使用如下方式：\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    gender: 'male'\n};\n```\n\n使用 `[propName: string]` 定义了任意属性取 `string` 类型的值。\n\n需要注意的是，**一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的同类型或者子集：**\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: string;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n\n// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.\n// index.ts(7,5): error TS2322: Type '{ [x: string]: string | number; name: string; age: number; gender: string; }' is not assignable to type 'Person'.\n//   Index signatures are incompatible.\n//     Type 'string | number' is not assignable to type 'string'.\n//       Type 'number' is not assignable to type 'string'.\n```\n\n上例中，任意属性的值允许是 `string`，但是可选属性 `age` 的值却是 `number`，`number` 不是 `string` 的子属性，所以报错了。\n\n另外，在报错信息中可以看出，此时 `{ name: 'Tom', age: 25, gender: 'male' }` 的类型被推断成了 `{ [x: string]: string | number; name: string; age: number; gender: string; }`，这是联合类型和接口的结合。\n\n一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：\n\n```TypeScript\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: string | number;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n```\n\n## 只读属性\n\n有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 `readonly` 定义只读属性：\n\n```TypeScript\ninterface Person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    id: 89757,\n    name: 'Tom',\n    gender: 'male'\n};\n\ntom.id = 9527;\n\n// index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.\n```\n\n上例中，使用 `readonly` 定义的属性 `id` 初始化后，又被赋值了，所以报错了。\n\n**注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：**\n\n```TypeScript\ninterface Person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    gender: 'male'\n};\n\ntom.id = 89757;\n\n// index.ts(8,5): error TS2322: Type '{ name: string; gender: string; }' is not assignable to type 'Person'.\n//   Property 'id' is missing in type '{ name: string; gender: string; }'.\n// index.ts(13,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.\n```\n\n上例中，报错信息有两处，第一处是在对 `tom` 进行赋值的时候，没有给 `id` 赋值。\n\n第二处是在给 `tom.id` 赋值的时候，由于它是只读属性，所以报错了。\n\n## 参考\n\n- [Interfaces](http://www.typescriptlang.org/docs/handbook/interfaces.html)","slug":"typescript/基础/对象的类型——接口","published":1,"date":"2023-01-05T08:16:54.245Z","updated":"2023-01-05T09:44:34.672Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clck4pkzf000m2ovn32r48yn6","content":"<h1 id=\"对象的类型——接口\"><a href=\"#对象的类型——接口\" class=\"headerlink\" title=\"对象的类型——接口\"></a>对象的类型——接口</h1><p>在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。</p>\n<h2 id=\"什么是接口\"><a href=\"#什么是接口\" class=\"headerlink\" title=\"什么是接口\"></a>什么是接口</h2><p>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。</p>\n<p>TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。</p>\n<h2 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h2><pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25\n&#125;;</code></pre>\n\n<p>上面的例子中，我们定义了一个接口 <code>Person</code>，接着定义了一个变量 <code>tom</code>，它的类型是 <code>Person</code>。这样，我们就约束了 <code>tom</code> 的形状必须和接口 <code>Person</code> 一致。</p>\n<p>接口一般首字母大写。<a href=\"https://msdn.microsoft.com/en-us/library/8bc1fexb%28v=vs.71%29.aspx\">有的编程语言中会建议接口的名称加上 I 前缀</a>。</p>\n<p>定义的变量比接口少了一些属性是不允许的：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;\n&#125;;\n\n&#x2F;&#x2F; index.ts(6,5): error TS2322: Type &#39;&#123; name: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Property &#39;age&#39; is missing in type &#39;&#123; name: string; &#125;&#39;.</code></pre>\n\n<p>多一些属性也是不允许的：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n&#x2F;&#x2F; index.ts(9,5): error TS2322: Type &#39;&#123; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Object literal may only specify known properties, and &#39;gender&#39; does not exist in type &#39;Person&#39;.</code></pre>\n\n<p>可见，<strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong>。</p>\n<h2 id=\"可选属性\"><a href=\"#可选属性\" class=\"headerlink\" title=\"可选属性\"></a>可选属性</h2><p>有时我们希望不要完全匹配一个形状，那么可以用可选属性：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;\n&#125;;</code></pre>\n\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25\n&#125;;</code></pre>\n\n<p>可选属性的含义是该属性可以不存在。</p>\n<p>这时<strong>仍然不允许添加未定义的属性：</strong></p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n&#x2F;&#x2F; examples&#x2F;playground&#x2F;index.ts(9,5): error TS2322: Type &#39;&#123; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Object literal may only specify known properties, and &#39;gender&#39; does not exist in type &#39;Person&#39;.</code></pre>\n\n<h2 id=\"任意属性\"><a href=\"#任意属性\" class=\"headerlink\" title=\"任意属性\"></a>任意属性</h2><p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;</code></pre>\n\n<p>使用 <code>[propName: string]</code> 定义了任意属性取 <code>string</code> 类型的值。</p>\n<p>需要注意的是，<strong>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的同类型或者子集：</strong></p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n    [propName: string]: string;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n&#x2F;&#x2F; index.ts(3,5): error TS2411: Property &#39;age&#39; of type &#39;number&#39; is not assignable to string index type &#39;string&#39;.\n&#x2F;&#x2F; index.ts(7,5): error TS2322: Type &#39;&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Index signatures are incompatible.\n&#x2F;&#x2F;     Type &#39;string | number&#39; is not assignable to type &#39;string&#39;.\n&#x2F;&#x2F;       Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre>\n\n<p>上例中，任意属性的值允许是 <code>string</code>，但是可选属性 <code>age</code> 的值却是 <code>number</code>，<code>number</code> 不是 <code>string</code> 的子属性，所以报错了。</p>\n<p>另外，在报错信息中可以看出，此时 <code>&#123; name: &#39;Tom&#39;, age: 25, gender: &#39;male&#39; &#125;</code> 的类型被推断成了 <code>&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;</code>，这是联合类型和接口的结合。</p>\n<p>一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n    [propName: string]: string | number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;</code></pre>\n\n<h2 id=\"只读属性\"><a href=\"#只读属性\" class=\"headerlink\" title=\"只读属性\"></a>只读属性</h2><p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 <code>readonly</code> 定义只读属性：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    id: 89757,\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;\n\ntom.id &#x3D; 9527;\n\n&#x2F;&#x2F; index.ts(14,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-only property.</code></pre>\n\n<p>上例中，使用 <code>readonly</code> 定义的属性 <code>id</code> 初始化后，又被赋值了，所以报错了。</p>\n<p><strong>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：</strong></p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;\n\ntom.id &#x3D; 89757;\n\n&#x2F;&#x2F; index.ts(8,5): error TS2322: Type &#39;&#123; name: string; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Property &#39;id&#39; is missing in type &#39;&#123; name: string; gender: string; &#125;&#39;.\n&#x2F;&#x2F; index.ts(13,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-only property.</code></pre>\n\n<p>上例中，报错信息有两处，第一处是在对 <code>tom</code> 进行赋值的时候，没有给 <code>id</code> 赋值。</p>\n<p>第二处是在给 <code>tom.id</code> 赋值的时候，由于它是只读属性，所以报错了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/interfaces.html\">Interfaces</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"对象的类型——接口\"><a href=\"#对象的类型——接口\" class=\"headerlink\" title=\"对象的类型——接口\"></a>对象的类型——接口</h1><p>在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。</p>\n<h2 id=\"什么是接口\"><a href=\"#什么是接口\" class=\"headerlink\" title=\"什么是接口\"></a>什么是接口</h2><p>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。</p>\n<p>TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。</p>\n<h2 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h2><pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25\n&#125;;</code></pre>\n\n<p>上面的例子中，我们定义了一个接口 <code>Person</code>，接着定义了一个变量 <code>tom</code>，它的类型是 <code>Person</code>。这样，我们就约束了 <code>tom</code> 的形状必须和接口 <code>Person</code> 一致。</p>\n<p>接口一般首字母大写。<a href=\"https://msdn.microsoft.com/en-us/library/8bc1fexb%28v=vs.71%29.aspx\">有的编程语言中会建议接口的名称加上 I 前缀</a>。</p>\n<p>定义的变量比接口少了一些属性是不允许的：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;\n&#125;;\n\n&#x2F;&#x2F; index.ts(6,5): error TS2322: Type &#39;&#123; name: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Property &#39;age&#39; is missing in type &#39;&#123; name: string; &#125;&#39;.</code></pre>\n\n<p>多一些属性也是不允许的：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n&#x2F;&#x2F; index.ts(9,5): error TS2322: Type &#39;&#123; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Object literal may only specify known properties, and &#39;gender&#39; does not exist in type &#39;Person&#39;.</code></pre>\n\n<p>可见，<strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong>。</p>\n<h2 id=\"可选属性\"><a href=\"#可选属性\" class=\"headerlink\" title=\"可选属性\"></a>可选属性</h2><p>有时我们希望不要完全匹配一个形状，那么可以用可选属性：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;\n&#125;;</code></pre>\n\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25\n&#125;;</code></pre>\n\n<p>可选属性的含义是该属性可以不存在。</p>\n<p>这时<strong>仍然不允许添加未定义的属性：</strong></p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n&#x2F;&#x2F; examples&#x2F;playground&#x2F;index.ts(9,5): error TS2322: Type &#39;&#123; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Object literal may only specify known properties, and &#39;gender&#39; does not exist in type &#39;Person&#39;.</code></pre>\n\n<h2 id=\"任意属性\"><a href=\"#任意属性\" class=\"headerlink\" title=\"任意属性\"></a>任意属性</h2><p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;</code></pre>\n\n<p>使用 <code>[propName: string]</code> 定义了任意属性取 <code>string</code> 类型的值。</p>\n<p>需要注意的是，<strong>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的同类型或者子集：</strong></p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n    [propName: string]: string;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n&#x2F;&#x2F; index.ts(3,5): error TS2411: Property &#39;age&#39; of type &#39;number&#39; is not assignable to string index type &#39;string&#39;.\n&#x2F;&#x2F; index.ts(7,5): error TS2322: Type &#39;&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Index signatures are incompatible.\n&#x2F;&#x2F;     Type &#39;string | number&#39; is not assignable to type &#39;string&#39;.\n&#x2F;&#x2F;       Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre>\n\n<p>上例中，任意属性的值允许是 <code>string</code>，但是可选属性 <code>age</code> 的值却是 <code>number</code>，<code>number</code> 不是 <code>string</code> 的子属性，所以报错了。</p>\n<p>另外，在报错信息中可以看出，此时 <code>&#123; name: &#39;Tom&#39;, age: 25, gender: &#39;male&#39; &#125;</code> 的类型被推断成了 <code>&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;</code>，这是联合类型和接口的结合。</p>\n<p>一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    name: string;\n    age?: number;\n    [propName: string]: string | number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;</code></pre>\n\n<h2 id=\"只读属性\"><a href=\"#只读属性\" class=\"headerlink\" title=\"只读属性\"></a>只读属性</h2><p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 <code>readonly</code> 定义只读属性：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    id: 89757,\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;\n\ntom.id &#x3D; 9527;\n\n&#x2F;&#x2F; index.ts(14,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-only property.</code></pre>\n\n<p>上例中，使用 <code>readonly</code> 定义的属性 <code>id</code> 初始化后，又被赋值了，所以报错了。</p>\n<p><strong>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：</strong></p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface Person &#123;\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;\n\ntom.id &#x3D; 89757;\n\n&#x2F;&#x2F; index.ts(8,5): error TS2322: Type &#39;&#123; name: string; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Property &#39;id&#39; is missing in type &#39;&#123; name: string; gender: string; &#125;&#39;.\n&#x2F;&#x2F; index.ts(13,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-only property.</code></pre>\n\n<p>上例中，报错信息有两处，第一处是在对 <code>tom</code> 进行赋值的时候，没有给 <code>id</code> 赋值。</p>\n<p>第二处是在给 <code>tom.id</code> 赋值的时候，由于它是只读属性，所以报错了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/interfaces.html\">Interfaces</a></li>\n</ul>\n"},{"title":"基础","cover":"https://whitelabelcoders.com/app/uploads/18.jpg","_content":"\n# 基础\n\n> 本部分介绍了 TypeScript 中的常用类型和一些基本概念，旨在让大家对 TypeScript 有个初步的理解。具体内容包括：\n\n- [原始数据类型](/post/typescript/基础/原始数据类型)\n-\n- [任意值](/post/typescript/基础/任意值)\n-\n- [类型推论](/post/typescript/基础/类型推论)\n-\n- [联合类型](/post/typescript/基础/联合类型)\n-\n- [对象的类型——接口](/post/typescript/基础/对象的类型——接口)\n-\n- [数组的类型](/post/typescript/基础/数组的类型)\n-\n- [函数的类型](/post/typescript/基础/函数的类型)\n-\n- [类型断言](/post/typescript/基础/类型断言)\n-\n- [声明文件](/post/typescript/基础/声明文件)\n-\n- [内置对象](/post/typescript/基础/内置对象)","source":"_posts/typescript/基础/基础.md","raw":"---\ntitle: 基础\ncover: https://whitelabelcoders.com/app/uploads/18.jpg\ncategories:\n  - TypeScript入门\ntags:\n  - TypeScript\n  - 基础\n---\n\n# 基础\n\n> 本部分介绍了 TypeScript 中的常用类型和一些基本概念，旨在让大家对 TypeScript 有个初步的理解。具体内容包括：\n\n- [原始数据类型](/post/typescript/基础/原始数据类型)\n-\n- [任意值](/post/typescript/基础/任意值)\n-\n- [类型推论](/post/typescript/基础/类型推论)\n-\n- [联合类型](/post/typescript/基础/联合类型)\n-\n- [对象的类型——接口](/post/typescript/基础/对象的类型——接口)\n-\n- [数组的类型](/post/typescript/基础/数组的类型)\n-\n- [函数的类型](/post/typescript/基础/函数的类型)\n-\n- [类型断言](/post/typescript/基础/类型断言)\n-\n- [声明文件](/post/typescript/基础/声明文件)\n-\n- [内置对象](/post/typescript/基础/内置对象)","slug":"typescript/基础/基础","published":1,"date":"2023-01-05T02:27:24.372Z","updated":"2023-01-05T07:54:06.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clck4pkzh000n2ovn4i8ah2k2","content":"<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>本部分介绍了 TypeScript 中的常用类型和一些基本概念，旨在让大家对 TypeScript 有个初步的理解。具体内容包括：</p></blockquote>\n<ul>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\">原始数据类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E4%BB%BB%E6%84%8F%E5%80%BC\">任意值</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA\">类型推论</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B\">联合类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3\">对象的类型——接口</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84%E7%9A%84%E7%B1%BB%E5%9E%8B\">数组的类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B\">函数的类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80\">类型断言</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">声明文件</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1\">内置对象</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><blockquote>\n<p>本部分介绍了 TypeScript 中的常用类型和一些基本概念，旨在让大家对 TypeScript 有个初步的理解。具体内容包括：</p>\n</blockquote>\n<ul>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\">原始数据类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E4%BB%BB%E6%84%8F%E5%80%BC\">任意值</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA\">类型推论</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B\">联合类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3\">对象的类型——接口</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84%E7%9A%84%E7%B1%BB%E5%9E%8B\">数组的类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B\">函数的类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80\">类型断言</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">声明文件</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1\">内置对象</a></li>\n</ul>\n"},{"title":"基础 - 数组的类型","cover":"https://whitelabelcoders.com/app/uploads/18.jpg","_content":"\n# 数组的类型\n\n在 TypeScript 中，数组类型有多种定义方式，比较灵活。\n\n## 「类型 + 方括号」表示法\n\n最简单的方法是使用「类型 + 方括号」来表示数组：\n\n```TypeScript\nlet fibonacci: number[] = [1, 1, 2, 3, 5];\n```\n\n数组的项中**不允许**出现其他的类型：\n\n```TypeScript\nlet fibonacci: number[] = [1, '1', 2, 3, 5];\n\n// Type 'string' is not assignable to type 'number'.\n```\n\n数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：\n\n```TypeScript\nlet fibonacci: number[] = [1, 1, 2, 3, 5];\nfibonacci.push('8');\n\n// Argument of type '\"8\"' is not assignable to parameter of type 'number'.\n```\n\n上例中，`push` 方法只允许传入 `number` 类型的参数，但是却传了一个 `\"8\"` 类型的参数，所以报错了。这里 `\"8\"` 是一个字符串字面量类型，会在后续章节中详细介绍。\n\n## 数组泛型\n\n我们也可以使用数组泛型（Array Generic） Array<elemType> 来表示数组：\n\n```TypeScript\nlet fibonacci: Array<number> = [1, 1, 2, 3, 5];\n```\n\n关于泛型，可以参考[泛型]()一章。\n\n## 用接口表示数组\n\n接口也可以用来描述数组：\n\n```TypeScript\ninterface NumberArray {\n    [index: number]: number;\n}\nlet fibonacci: NumberArray = [1, 1, 2, 3, 5];\n```\n\n`NumberArray` 表示：只要索引的类型是数字时，那么值的类型必须是数字。\n\n虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。\n\n不过有一种情况例外，那就是它常用来表示类数组。\n\n## 类数组\n\n类数组（Array-like Object）不是数组类型，比如 arguments：\n\n```TypeScript\nfunction sum() {\n    let args: number[] = arguments;\n}\n\n// Type 'IArguments' is missing the following properties from type 'number[]': pop, push, concat, join, and 24 more.\n```\n\n上例中，arguments 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：\n\n```TypeScript\nfunction sum() {\n    let args: {\n        [index: number]: number;\n        length: number;\n        callee: Function;\n    } = arguments;\n}\n```\n\n在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 `length` 和 `callee` 两个属性。\n\n事实上常用的类数组都有自己的接口定义，如 `IArguments`, `NodeList`, `HTMLCollection` 等：\n\n```TypeScript\nfunction sum() {\n    let args: IArguments = arguments;\n}\n```\n\n其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是：\n\n```TypeScript\ninterface IArguments {\n    [index: number]: any;\n    length: number;\n    callee: Function;\n}\n```\n\n关于内置对象，可以参考[内置对象]()一章。\n\n## any 在数组中的应用\n\n一个比较常见的做法是，用 any 表示数组中允许出现任意类型：\n\n```TypeScript\ninterface IArguments {\n    [index: number]: any;\n    length: number;\n    callee: Function;\n}\n```\n\n## 参考\n- [Basic Types # Array](http://www.typescriptlang.org/docs/handbook/basic-types.html#array)\n- [Interfaces # Indexable Types](http://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types)","source":"_posts/typescript/基础/数组的类型.md","raw":"---\ntitle: 基础 - 数组的类型\ncover: https://whitelabelcoders.com/app/uploads/18.jpg\ncategories:\n  - TypeScript入门\ntags:\n  - TypeScript\n  - 类型\n  - 数组\n---\n\n# 数组的类型\n\n在 TypeScript 中，数组类型有多种定义方式，比较灵活。\n\n## 「类型 + 方括号」表示法\n\n最简单的方法是使用「类型 + 方括号」来表示数组：\n\n```TypeScript\nlet fibonacci: number[] = [1, 1, 2, 3, 5];\n```\n\n数组的项中**不允许**出现其他的类型：\n\n```TypeScript\nlet fibonacci: number[] = [1, '1', 2, 3, 5];\n\n// Type 'string' is not assignable to type 'number'.\n```\n\n数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：\n\n```TypeScript\nlet fibonacci: number[] = [1, 1, 2, 3, 5];\nfibonacci.push('8');\n\n// Argument of type '\"8\"' is not assignable to parameter of type 'number'.\n```\n\n上例中，`push` 方法只允许传入 `number` 类型的参数，但是却传了一个 `\"8\"` 类型的参数，所以报错了。这里 `\"8\"` 是一个字符串字面量类型，会在后续章节中详细介绍。\n\n## 数组泛型\n\n我们也可以使用数组泛型（Array Generic） Array<elemType> 来表示数组：\n\n```TypeScript\nlet fibonacci: Array<number> = [1, 1, 2, 3, 5];\n```\n\n关于泛型，可以参考[泛型]()一章。\n\n## 用接口表示数组\n\n接口也可以用来描述数组：\n\n```TypeScript\ninterface NumberArray {\n    [index: number]: number;\n}\nlet fibonacci: NumberArray = [1, 1, 2, 3, 5];\n```\n\n`NumberArray` 表示：只要索引的类型是数字时，那么值的类型必须是数字。\n\n虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。\n\n不过有一种情况例外，那就是它常用来表示类数组。\n\n## 类数组\n\n类数组（Array-like Object）不是数组类型，比如 arguments：\n\n```TypeScript\nfunction sum() {\n    let args: number[] = arguments;\n}\n\n// Type 'IArguments' is missing the following properties from type 'number[]': pop, push, concat, join, and 24 more.\n```\n\n上例中，arguments 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：\n\n```TypeScript\nfunction sum() {\n    let args: {\n        [index: number]: number;\n        length: number;\n        callee: Function;\n    } = arguments;\n}\n```\n\n在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 `length` 和 `callee` 两个属性。\n\n事实上常用的类数组都有自己的接口定义，如 `IArguments`, `NodeList`, `HTMLCollection` 等：\n\n```TypeScript\nfunction sum() {\n    let args: IArguments = arguments;\n}\n```\n\n其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是：\n\n```TypeScript\ninterface IArguments {\n    [index: number]: any;\n    length: number;\n    callee: Function;\n}\n```\n\n关于内置对象，可以参考[内置对象]()一章。\n\n## any 在数组中的应用\n\n一个比较常见的做法是，用 any 表示数组中允许出现任意类型：\n\n```TypeScript\ninterface IArguments {\n    [index: number]: any;\n    length: number;\n    callee: Function;\n}\n```\n\n## 参考\n- [Basic Types # Array](http://www.typescriptlang.org/docs/handbook/basic-types.html#array)\n- [Interfaces # Indexable Types](http://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types)","slug":"typescript/基础/数组的类型","published":1,"date":"2023-01-05T09:45:01.484Z","updated":"2023-01-05T10:01:04.290Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clck4pkzj000r2ovn3t777cv4","content":"<h1 id=\"数组的类型\"><a href=\"#数组的类型\" class=\"headerlink\" title=\"数组的类型\"></a>数组的类型</h1><p>在 TypeScript 中，数组类型有多种定义方式，比较灵活。</p>\n<h2 id=\"「类型-方括号」表示法\"><a href=\"#「类型-方括号」表示法\" class=\"headerlink\" title=\"「类型 + 方括号」表示法\"></a>「类型 + 方括号」表示法</h2><p>最简单的方法是使用「类型 + 方括号」来表示数组：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let fibonacci: number[] &#x3D; [1, 1, 2, 3, 5];</code></pre>\n\n<p>数组的项中<strong>不允许</strong>出现其他的类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let fibonacci: number[] &#x3D; [1, &#39;1&#39;, 2, 3, 5];\n\n&#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;number&#39;.</code></pre>\n\n<p>数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let fibonacci: number[] &#x3D; [1, 1, 2, 3, 5];\nfibonacci.push(&#39;8&#39;);\n\n&#x2F;&#x2F; Argument of type &#39;&quot;8&quot;&#39; is not assignable to parameter of type &#39;number&#39;.</code></pre>\n\n<p>上例中，<code>push</code> 方法只允许传入 <code>number</code> 类型的参数，但是却传了一个 <code>&quot;8&quot;</code> 类型的参数，所以报错了。这里 <code>&quot;8&quot;</code> 是一个字符串字面量类型，会在后续章节中详细介绍。</p>\n<h2 id=\"数组泛型\"><a href=\"#数组泛型\" class=\"headerlink\" title=\"数组泛型\"></a>数组泛型</h2><p>我们也可以使用数组泛型（Array Generic） Array<elemType> 来表示数组：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let fibonacci: Array&lt;number&gt; &#x3D; [1, 1, 2, 3, 5];</code></pre>\n\n<p>关于泛型，可以参考<a href=\"\">泛型</a>一章。</p>\n<h2 id=\"用接口表示数组\"><a href=\"#用接口表示数组\" class=\"headerlink\" title=\"用接口表示数组\"></a>用接口表示数组</h2><p>接口也可以用来描述数组：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface NumberArray &#123;\n    [index: number]: number;\n&#125;\nlet fibonacci: NumberArray &#x3D; [1, 1, 2, 3, 5];</code></pre>\n\n<p><code>NumberArray</code> 表示：只要索引的类型是数字时，那么值的类型必须是数字。</p>\n<p>虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。</p>\n<p>不过有一种情况例外，那就是它常用来表示类数组。</p>\n<h2 id=\"类数组\"><a href=\"#类数组\" class=\"headerlink\" title=\"类数组\"></a>类数组</h2><p>类数组（Array-like Object）不是数组类型，比如 arguments：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function sum() &#123;\n    let args: number[] &#x3D; arguments;\n&#125;\n\n&#x2F;&#x2F; Type &#39;IArguments&#39; is missing the following properties from type &#39;number[]&#39;: pop, push, concat, join, and 24 more.</code></pre>\n\n<p>上例中，arguments 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function sum() &#123;\n    let args: &#123;\n        [index: number]: number;\n        length: number;\n        callee: Function;\n    &#125; &#x3D; arguments;\n&#125;</code></pre>\n\n<p>在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 <code>length</code> 和 <code>callee</code> 两个属性。</p>\n<p>事实上常用的类数组都有自己的接口定义，如 <code>IArguments</code>, <code>NodeList</code>, <code>HTMLCollection</code> 等：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function sum() &#123;\n    let args: IArguments &#x3D; arguments;\n&#125;</code></pre>\n\n<p>其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface IArguments &#123;\n    [index: number]: any;\n    length: number;\n    callee: Function;\n&#125;</code></pre>\n\n<p>关于内置对象，可以参考<a href=\"\">内置对象</a>一章。</p>\n<h2 id=\"any-在数组中的应用\"><a href=\"#any-在数组中的应用\" class=\"headerlink\" title=\"any 在数组中的应用\"></a>any 在数组中的应用</h2><p>一个比较常见的做法是，用 any 表示数组中允许出现任意类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface IArguments &#123;\n    [index: number]: any;\n    length: number;\n    callee: Function;\n&#125;</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/basic-types.html#array\">Basic Types # Array</a></li>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types\">Interfaces # Indexable Types</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数组的类型\"><a href=\"#数组的类型\" class=\"headerlink\" title=\"数组的类型\"></a>数组的类型</h1><p>在 TypeScript 中，数组类型有多种定义方式，比较灵活。</p>\n<h2 id=\"「类型-方括号」表示法\"><a href=\"#「类型-方括号」表示法\" class=\"headerlink\" title=\"「类型 + 方括号」表示法\"></a>「类型 + 方括号」表示法</h2><p>最简单的方法是使用「类型 + 方括号」来表示数组：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let fibonacci: number[] &#x3D; [1, 1, 2, 3, 5];</code></pre>\n\n<p>数组的项中<strong>不允许</strong>出现其他的类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let fibonacci: number[] &#x3D; [1, &#39;1&#39;, 2, 3, 5];\n\n&#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;number&#39;.</code></pre>\n\n<p>数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let fibonacci: number[] &#x3D; [1, 1, 2, 3, 5];\nfibonacci.push(&#39;8&#39;);\n\n&#x2F;&#x2F; Argument of type &#39;&quot;8&quot;&#39; is not assignable to parameter of type &#39;number&#39;.</code></pre>\n\n<p>上例中，<code>push</code> 方法只允许传入 <code>number</code> 类型的参数，但是却传了一个 <code>&quot;8&quot;</code> 类型的参数，所以报错了。这里 <code>&quot;8&quot;</code> 是一个字符串字面量类型，会在后续章节中详细介绍。</p>\n<h2 id=\"数组泛型\"><a href=\"#数组泛型\" class=\"headerlink\" title=\"数组泛型\"></a>数组泛型</h2><p>我们也可以使用数组泛型（Array Generic） Array<elemType> 来表示数组：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let fibonacci: Array&lt;number&gt; &#x3D; [1, 1, 2, 3, 5];</code></pre>\n\n<p>关于泛型，可以参考<a href=\"\">泛型</a>一章。</p>\n<h2 id=\"用接口表示数组\"><a href=\"#用接口表示数组\" class=\"headerlink\" title=\"用接口表示数组\"></a>用接口表示数组</h2><p>接口也可以用来描述数组：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface NumberArray &#123;\n    [index: number]: number;\n&#125;\nlet fibonacci: NumberArray &#x3D; [1, 1, 2, 3, 5];</code></pre>\n\n<p><code>NumberArray</code> 表示：只要索引的类型是数字时，那么值的类型必须是数字。</p>\n<p>虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。</p>\n<p>不过有一种情况例外，那就是它常用来表示类数组。</p>\n<h2 id=\"类数组\"><a href=\"#类数组\" class=\"headerlink\" title=\"类数组\"></a>类数组</h2><p>类数组（Array-like Object）不是数组类型，比如 arguments：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function sum() &#123;\n    let args: number[] &#x3D; arguments;\n&#125;\n\n&#x2F;&#x2F; Type &#39;IArguments&#39; is missing the following properties from type &#39;number[]&#39;: pop, push, concat, join, and 24 more.</code></pre>\n\n<p>上例中，arguments 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function sum() &#123;\n    let args: &#123;\n        [index: number]: number;\n        length: number;\n        callee: Function;\n    &#125; &#x3D; arguments;\n&#125;</code></pre>\n\n<p>在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 <code>length</code> 和 <code>callee</code> 两个属性。</p>\n<p>事实上常用的类数组都有自己的接口定义，如 <code>IArguments</code>, <code>NodeList</code>, <code>HTMLCollection</code> 等：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function sum() &#123;\n    let args: IArguments &#x3D; arguments;\n&#125;</code></pre>\n\n<p>其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface IArguments &#123;\n    [index: number]: any;\n    length: number;\n    callee: Function;\n&#125;</code></pre>\n\n<p>关于内置对象，可以参考<a href=\"\">内置对象</a>一章。</p>\n<h2 id=\"any-在数组中的应用\"><a href=\"#any-在数组中的应用\" class=\"headerlink\" title=\"any 在数组中的应用\"></a>any 在数组中的应用</h2><p>一个比较常见的做法是，用 any 表示数组中允许出现任意类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">interface IArguments &#123;\n    [index: number]: any;\n    length: number;\n    callee: Function;\n&#125;</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/basic-types.html#array\">Basic Types # Array</a></li>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types\">Interfaces # Indexable Types</a></li>\n</ul>\n"},{"title":"基础 - 类型推论","cover":"https://whitelabelcoders.com/app/uploads/18.jpg","_content":"\n# 类型推论\n\n如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。\n\n## 什么是类型推论\n\n以下代码虽然没有指定类型，但是会在编译的时候报错:\n\n```TypeScript\nlet myFavoriteNumber = 'seven';\nmyFavoriteNumber = 7;\n\n// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'\n```\n\n事实上，它等价于：\n\n```TypeScript\nlet myFavoriteNumber: string = 'seven';\nmyFavoriteNumber = 7;\n\n// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.\n```\n\nTypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。\n\n**如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：**\n\n```TypeScript\nlet myFavoriteNumber;\nmyFavoriteNumber = 'seven';\nmyFavoriteNumber = 7;\n```\n\n## 参考\n\n- [Type Interface](https://www.typescriptlang.org/docs/handbook/type-inference.html)","source":"_posts/typescript/基础/类型推论.md","raw":"---\ntitle: 基础 - 类型推论\ncover: https://whitelabelcoders.com/app/uploads/18.jpg\ncategories:\n  - TypeScript入门\ntags:\n  - TypeScript\n  - 基础\n---\n\n# 类型推论\n\n如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。\n\n## 什么是类型推论\n\n以下代码虽然没有指定类型，但是会在编译的时候报错:\n\n```TypeScript\nlet myFavoriteNumber = 'seven';\nmyFavoriteNumber = 7;\n\n// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'\n```\n\n事实上，它等价于：\n\n```TypeScript\nlet myFavoriteNumber: string = 'seven';\nmyFavoriteNumber = 7;\n\n// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.\n```\n\nTypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。\n\n**如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：**\n\n```TypeScript\nlet myFavoriteNumber;\nmyFavoriteNumber = 'seven';\nmyFavoriteNumber = 7;\n```\n\n## 参考\n\n- [Type Interface](https://www.typescriptlang.org/docs/handbook/type-inference.html)","slug":"typescript/基础/类型推论","published":1,"date":"2023-01-05T07:51:40.501Z","updated":"2023-01-05T08:04:38.377Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clck4pkzk000s2ovndc41cs6b","content":"<h1 id=\"类型推论\"><a href=\"#类型推论\" class=\"headerlink\" title=\"类型推论\"></a>类型推论</h1><p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</p>\n<h2 id=\"什么是类型推论\"><a href=\"#什么是类型推论\" class=\"headerlink\" title=\"什么是类型推论\"></a>什么是类型推论</h2><p>以下代码虽然没有指定类型，但是会在编译的时候报错:</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;</code></pre>\n\n<p>事实上，它等价于：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: string &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre>\n\n<p>TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。</p>\n<p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：</strong></p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber;\nmyFavoriteNumber &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/type-inference.html\">Type Interface</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"类型推论\"><a href=\"#类型推论\" class=\"headerlink\" title=\"类型推论\"></a>类型推论</h1><p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</p>\n<h2 id=\"什么是类型推论\"><a href=\"#什么是类型推论\" class=\"headerlink\" title=\"什么是类型推论\"></a>什么是类型推论</h2><p>以下代码虽然没有指定类型，但是会在编译的时候报错:</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;</code></pre>\n\n<p>事实上，它等价于：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: string &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre>\n\n<p>TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。</p>\n<p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：</strong></p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber;\nmyFavoriteNumber &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/type-inference.html\">Type Interface</a></li>\n</ul>\n"},{"title":"基础 - 联合类型","cover":"https://whitelabelcoders.com/app/uploads/18.jpg","_content":"\n# 联合类型\n\n联合类型（Union Types）表示取值可以为多种类型中的一种。\n\n```TypeScript\nlet myFavoriteNumber: string | number;\nmyFavoriteNumber = 'seven';\nmyFavoriteNumber = 7;\n```\n\n```TypeScript\nlet myFavoriteNumber: string | number;\nmyFavoriteNumber = true;\n\n// index.ts(2,1): error TS2322: Type 'boolean' is not assignable to type 'string | number'.\n//   Type 'boolean' is not assignable to type 'number'.\n```\n\n:::tip\n联合类型使用 `|` 分隔每个类型。\n\n这里的 `let myFavoriteNumber: string | number` 的含义是，允许 `myFavoriteNumber` 的类型是 `string` 或者 `number`，但是不能是其他类型。\n:::\n\n## 访问联合类型的属性或方法\n\n当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们**只能访问此联合类型的所有类型里共有的属性或方法：**\n\n```TypeScript\nfunction getLength(something: string | number): number {\n    return something.length;\n}\n\n// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.\n//   Property 'length' does not exist on type 'number'.\n```\n\n上例中，`length` 不是 `string` 和 `number` 的共有属性，所以会报错。\n\n访问 `string` 和 `number` 的共有属性是没问题的：\n\n```TypeScript\nfunction getString(something: string | number): string {\n    return something.toString();\n}\n```\n\n联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：\n\n```TypeScript\nlet myFavoriteNumber: string | number;\nmyFavoriteNumber = 'seven';\nconsole.log(myFavoriteNumber.length); // 5\nmyFavoriteNumber = 7;\nconsole.log(myFavoriteNumber.length); // 编译时报错\n\n// index.ts(5,30): error TS2339: Property 'length' does not exist on type 'number'.\n```\n\n## 参考\n\n- [Advanced Types # Union Types](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html)","source":"_posts/typescript/基础/联合类型.md","raw":"---\ntitle: 基础 - 联合类型\ncover: https://whitelabelcoders.com/app/uploads/18.jpg\ncategories:\n  - TypeScript入门\ntags:\n  - TypeScript\n  - 类型\n---\n\n# 联合类型\n\n联合类型（Union Types）表示取值可以为多种类型中的一种。\n\n```TypeScript\nlet myFavoriteNumber: string | number;\nmyFavoriteNumber = 'seven';\nmyFavoriteNumber = 7;\n```\n\n```TypeScript\nlet myFavoriteNumber: string | number;\nmyFavoriteNumber = true;\n\n// index.ts(2,1): error TS2322: Type 'boolean' is not assignable to type 'string | number'.\n//   Type 'boolean' is not assignable to type 'number'.\n```\n\n:::tip\n联合类型使用 `|` 分隔每个类型。\n\n这里的 `let myFavoriteNumber: string | number` 的含义是，允许 `myFavoriteNumber` 的类型是 `string` 或者 `number`，但是不能是其他类型。\n:::\n\n## 访问联合类型的属性或方法\n\n当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们**只能访问此联合类型的所有类型里共有的属性或方法：**\n\n```TypeScript\nfunction getLength(something: string | number): number {\n    return something.length;\n}\n\n// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.\n//   Property 'length' does not exist on type 'number'.\n```\n\n上例中，`length` 不是 `string` 和 `number` 的共有属性，所以会报错。\n\n访问 `string` 和 `number` 的共有属性是没问题的：\n\n```TypeScript\nfunction getString(something: string | number): string {\n    return something.toString();\n}\n```\n\n联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：\n\n```TypeScript\nlet myFavoriteNumber: string | number;\nmyFavoriteNumber = 'seven';\nconsole.log(myFavoriteNumber.length); // 5\nmyFavoriteNumber = 7;\nconsole.log(myFavoriteNumber.length); // 编译时报错\n\n// index.ts(5,30): error TS2339: Property 'length' does not exist on type 'number'.\n```\n\n## 参考\n\n- [Advanced Types # Union Types](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html)","slug":"typescript/基础/联合类型","published":1,"date":"2023-01-05T08:05:08.103Z","updated":"2023-01-05T08:12:00.078Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clck4pkzm000w2ovn2ep6ft69","content":"<h1 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h1><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: string | number;\nmyFavoriteNumber &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;</code></pre>\n\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: string | number;\nmyFavoriteNumber &#x3D; true;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;boolean&#39; is not assignable to type &#39;string | number&#39;.\n&#x2F;&#x2F;   Type &#39;boolean&#39; is not assignable to type &#39;number&#39;.</code></pre>\n\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>联合类型使用 <code>|</code> 分隔每个类型。</p>\n<p>这里的 <code>let myFavoriteNumber: string | number</code> 的含义是，允许 <code>myFavoriteNumber</code> 的类型是 <code>string</code> 或者 <code>number</code>，但是不能是其他类型。</p>\n</div>\n<h2 id=\"访问联合类型的属性或方法\"><a href=\"#访问联合类型的属性或方法\" class=\"headerlink\" title=\"访问联合类型的属性或方法\"></a>访问联合类型的属性或方法</h2><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法：</strong></p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function getLength(something: string | number): number &#123;\n    return something.length;\n&#125;\n\n&#x2F;&#x2F; index.ts(2,22): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.\n&#x2F;&#x2F;   Property &#39;length&#39; does not exist on type &#39;number&#39;.</code></pre>\n\n<p>上例中，<code>length</code> 不是 <code>string</code> 和 <code>number</code> 的共有属性，所以会报错。</p>\n<p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function getString(something: string | number): string &#123;\n    return something.toString();\n&#125;</code></pre>\n\n<p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: string | number;\nmyFavoriteNumber &#x3D; &#39;seven&#39;;\nconsole.log(myFavoriteNumber.length); &#x2F;&#x2F; 5\nmyFavoriteNumber &#x3D; 7;\nconsole.log(myFavoriteNumber.length); &#x2F;&#x2F; 编译时报错\n\n&#x2F;&#x2F; index.ts(5,30): error TS2339: Property &#39;length&#39; does not exist on type &#39;number&#39;.</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/2/types-from-types.html\">Advanced Types # Union Types</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h1><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: string | number;\nmyFavoriteNumber &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;</code></pre>\n\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: string | number;\nmyFavoriteNumber &#x3D; true;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;boolean&#39; is not assignable to type &#39;string | number&#39;.\n&#x2F;&#x2F;   Type &#39;boolean&#39; is not assignable to type &#39;number&#39;.</code></pre>\n\n<p>:::tip<br>联合类型使用 <code>|</code> 分隔每个类型。</p>\n<p>这里的 <code>let myFavoriteNumber: string | number</code> 的含义是，允许 <code>myFavoriteNumber</code> 的类型是 <code>string</code> 或者 <code>number</code>，但是不能是其他类型。<br>:::</p>\n<h2 id=\"访问联合类型的属性或方法\"><a href=\"#访问联合类型的属性或方法\" class=\"headerlink\" title=\"访问联合类型的属性或方法\"></a>访问联合类型的属性或方法</h2><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法：</strong></p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function getLength(something: string | number): number &#123;\n    return something.length;\n&#125;\n\n&#x2F;&#x2F; index.ts(2,22): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.\n&#x2F;&#x2F;   Property &#39;length&#39; does not exist on type &#39;number&#39;.</code></pre>\n\n<p>上例中，<code>length</code> 不是 <code>string</code> 和 <code>number</code> 的共有属性，所以会报错。</p>\n<p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function getString(something: string | number): string &#123;\n    return something.toString();\n&#125;</code></pre>\n\n<p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let myFavoriteNumber: string | number;\nmyFavoriteNumber &#x3D; &#39;seven&#39;;\nconsole.log(myFavoriteNumber.length); &#x2F;&#x2F; 5\nmyFavoriteNumber &#x3D; 7;\nconsole.log(myFavoriteNumber.length); &#x2F;&#x2F; 编译时报错\n\n&#x2F;&#x2F; index.ts(5,30): error TS2339: Property &#39;length&#39; does not exist on type &#39;number&#39;.</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/2/types-from-types.html\">Advanced Types # Union Types</a></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clck4pkyv00002ovnf8ey8xgr","category_id":"clck4pkz300032ovn05ib16cn","_id":"clck4pkzb000d2ovneox50bea"},{"post_id":"clck4pkz100022ovnenjv6jnx","category_id":"clck4pkz300032ovn05ib16cn","_id":"clck4pkze000j2ovngsdg9gcn"},{"post_id":"clck4pkz500052ovn41cf7diy","category_id":"clck4pkz300032ovn05ib16cn","_id":"clck4pkzi000o2ovn9d8t4adr"},{"post_id":"clck4pkz600062ovn5hlrbmy4","category_id":"clck4pkze000i2ovn2ov87gfy","_id":"clck4pkzl000u2ovnevtra9wf"},{"post_id":"clck4pkz700072ovnftbr2k4k","category_id":"clck4pkze000i2ovn2ov87gfy","_id":"clck4pkzo000z2ovn1k82d1h7"},{"post_id":"clck4pkz9000a2ovndlhk45vr","category_id":"clck4pkze000i2ovn2ov87gfy","_id":"clck4pkzp00132ovngt3ubbce"},{"post_id":"clck4pkza000b2ovn7khv8rcb","category_id":"clck4pkzo000y2ovn6k3b0pq8","_id":"clck4pkzq00182ovn1v0f89o4"},{"post_id":"clck4pkzc000f2ovncnrl5ffy","category_id":"clck4pkzo000y2ovn6k3b0pq8","_id":"clck4pkzs001c2ovngt19dhyl"},{"post_id":"clck4pkzd000h2ovn7x576jke","category_id":"clck4pkzo000y2ovn6k3b0pq8","_id":"clck4pkzt001f2ovn1p6jg7bi"},{"post_id":"clck4pkzf000m2ovn32r48yn6","category_id":"clck4pkzo000y2ovn6k3b0pq8","_id":"clck4pkzt001i2ovn3zim7xpd"},{"post_id":"clck4pkzh000n2ovn4i8ah2k2","category_id":"clck4pkzo000y2ovn6k3b0pq8","_id":"clck4pkzu001n2ovn29gr2h0m"},{"post_id":"clck4pkzj000r2ovn3t777cv4","category_id":"clck4pkzo000y2ovn6k3b0pq8","_id":"clck4pkzv001r2ovnf50n4sdj"},{"post_id":"clck4pkzk000s2ovndc41cs6b","category_id":"clck4pkzo000y2ovn6k3b0pq8","_id":"clck4pkzv001t2ovn0lcj3mpg"},{"post_id":"clck4pkzm000w2ovn2ep6ft69","category_id":"clck4pkzo000y2ovn6k3b0pq8","_id":"clck4pkzw001x2ovn87qfaisj"}],"PostTag":[{"post_id":"clck4pkyv00002ovnf8ey8xgr","tag_id":"clck4pkz400042ovnhjka5voj","_id":"clck4pkzd000g2ovn31ntcpgm"},{"post_id":"clck4pkyv00002ovnf8ey8xgr","tag_id":"clck4pkz800092ovnhvf08q15","_id":"clck4pkze000k2ovn6s1t58uq"},{"post_id":"clck4pkz100022ovnenjv6jnx","tag_id":"clck4pkz400042ovnhjka5voj","_id":"clck4pkzn000x2ovnfzuqeu7q"},{"post_id":"clck4pkz100022ovnenjv6jnx","tag_id":"clck4pkzf000l2ovnhr7pbene","_id":"clck4pkzo00102ovn806r3zhw"},{"post_id":"clck4pkz100022ovnenjv6jnx","tag_id":"clck4pkzi000q2ovn9fj1drb6","_id":"clck4pkzp00122ovn312e2t92"},{"post_id":"clck4pkz500052ovn41cf7diy","tag_id":"clck4pkz400042ovnhjka5voj","_id":"clck4pkzq00162ovn4k24d6h9"},{"post_id":"clck4pkz500052ovn41cf7diy","tag_id":"clck4pkzo00112ovn68kw7ura","_id":"clck4pkzr00192ovn6mn0en75"},{"post_id":"clck4pkz600062ovn5hlrbmy4","tag_id":"clck4pkzq00152ovn396l6kum","_id":"clck4pkzu001j2ovn3e9sbxym"},{"post_id":"clck4pkz600062ovn5hlrbmy4","tag_id":"clck4pkzr001a2ovnhj9k86vq","_id":"clck4pkzu001k2ovnhhsc2itq"},{"post_id":"clck4pkz600062ovn5hlrbmy4","tag_id":"clck4pkzs001d2ovncyw3c6mg","_id":"clck4pkzu001o2ovn207j2oli"},{"post_id":"clck4pkz700072ovnftbr2k4k","tag_id":"clck4pkzq00152ovn396l6kum","_id":"clck4pkzw001u2ovneha6gkd4"},{"post_id":"clck4pkz700072ovnftbr2k4k","tag_id":"clck4pkzu001l2ovn9i2s17ct","_id":"clck4pkzw001v2ovn1n562wxl"},{"post_id":"clck4pkz700072ovnftbr2k4k","tag_id":"clck4pkzv001p2ovnegrgbj17","_id":"clck4pkzw001y2ovn2ubv7fai"},{"post_id":"clck4pkz9000a2ovndlhk45vr","tag_id":"clck4pkzq00152ovn396l6kum","_id":"clck4pkzx00212ovn6yel2c8x"},{"post_id":"clck4pkz9000a2ovndlhk45vr","tag_id":"clck4pkzr001a2ovnhj9k86vq","_id":"clck4pkzx00222ovn3lml2uqq"},{"post_id":"clck4pkz9000a2ovndlhk45vr","tag_id":"clck4pkzs001d2ovncyw3c6mg","_id":"clck4pkzx00242ovncjbkd28w"},{"post_id":"clck4pkza000b2ovn7khv8rcb","tag_id":"clck4pkz400042ovnhjka5voj","_id":"clck4pkzx00252ovn5v712b5j"},{"post_id":"clck4pkza000b2ovn7khv8rcb","tag_id":"clck4pkzw00202ovn4p7ud3qu","_id":"clck4pkzy00272ovn9yi5arl3"},{"post_id":"clck4pkzc000f2ovncnrl5ffy","tag_id":"clck4pkz400042ovnhjka5voj","_id":"clck4pkzy00292ovndbqv3fr5"},{"post_id":"clck4pkzc000f2ovncnrl5ffy","tag_id":"clck4pkzx00232ovn0usf4gl0","_id":"clck4pkzy002a2ovn3fs5ethe"},{"post_id":"clck4pkzc000f2ovncnrl5ffy","tag_id":"clck4pkzx00262ovnab66cx8e","_id":"clck4pkzz002c2ovn2ibh9vno"},{"post_id":"clck4pkzd000h2ovn7x576jke","tag_id":"clck4pkz400042ovnhjka5voj","_id":"clck4pkzz002d2ovn8ejg5bph"},{"post_id":"clck4pkzd000h2ovn7x576jke","tag_id":"clck4pkzw00202ovn4p7ud3qu","_id":"clck4pkzz002f2ovncsl00yaa"},{"post_id":"clck4pkzf000m2ovn32r48yn6","tag_id":"clck4pkz400042ovnhjka5voj","_id":"clck4pkzz002g2ovnfslcepla"},{"post_id":"clck4pkzf000m2ovn32r48yn6","tag_id":"clck4pkzx00232ovn0usf4gl0","_id":"clck4pl00002i2ovn4oe93rlr"},{"post_id":"clck4pkzh000n2ovn4i8ah2k2","tag_id":"clck4pkz400042ovnhjka5voj","_id":"clck4pl00002j2ovnf7yz5jzv"},{"post_id":"clck4pkzh000n2ovn4i8ah2k2","tag_id":"clck4pkzw00202ovn4p7ud3qu","_id":"clck4pl00002l2ovnd21w8k2v"},{"post_id":"clck4pkzj000r2ovn3t777cv4","tag_id":"clck4pkz400042ovnhjka5voj","_id":"clck4pl00002n2ovn6ckqa2he"},{"post_id":"clck4pkzj000r2ovn3t777cv4","tag_id":"clck4pkzx00232ovn0usf4gl0","_id":"clck4pl01002o2ovn9i086orl"},{"post_id":"clck4pkzj000r2ovn3t777cv4","tag_id":"clck4pl00002k2ovnckuh2x9k","_id":"clck4pl01002q2ovn524y1msg"},{"post_id":"clck4pkzk000s2ovndc41cs6b","tag_id":"clck4pkz400042ovnhjka5voj","_id":"clck4pl01002r2ovn0ah4f0xu"},{"post_id":"clck4pkzk000s2ovndc41cs6b","tag_id":"clck4pkzw00202ovn4p7ud3qu","_id":"clck4pl01002s2ovn64xc103f"},{"post_id":"clck4pkzm000w2ovn2ep6ft69","tag_id":"clck4pkz400042ovnhjka5voj","_id":"clck4pl01002t2ovn9g8cft8o"},{"post_id":"clck4pkzm000w2ovn2ep6ft69","tag_id":"clck4pkzx00232ovn0usf4gl0","_id":"clck4pl01002u2ovncio494vs"}],"Tag":[{"name":"TypeScript","_id":"clck4pkz400042ovnhjka5voj"},{"name":"数据类型","_id":"clck4pkz800092ovnhvf08q15"},{"name":"环境搭建","_id":"clck4pkzf000l2ovnhr7pbene"},{"name":"webpack","_id":"clck4pkzi000q2ovn9fj1drb6"},{"name":"tsconfig","_id":"clck4pkzo00112ovn68kw7ura"},{"name":"Docker","_id":"clck4pkzq00152ovn396l6kum"},{"name":"容器","_id":"clck4pkzr001a2ovnhj9k86vq"},{"name":"container","_id":"clck4pkzs001d2ovncyw3c6mg"},{"name":"镜像","_id":"clck4pkzu001l2ovn9i2s17ct"},{"name":"images","_id":"clck4pkzv001p2ovnegrgbj17"},{"name":"基础","_id":"clck4pkzw00202ovn4p7ud3qu"},{"name":"类型","_id":"clck4pkzx00232ovn0usf4gl0"},{"name":"函数","_id":"clck4pkzx00262ovnab66cx8e"},{"name":"数组","_id":"clck4pl00002k2ovnckuh2x9k"}]}}