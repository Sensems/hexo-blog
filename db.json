{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-Aurora/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/icons/favicon-16x16.png","path":"icons/favicon-16x16.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/404.1a6cd5bd.css","path":"static/css/404.1a6cd5bd.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/about.32dfa3b0.css","path":"static/css/about.32dfa3b0.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/app.0d31776f.css","path":"static/css/app.0d31776f.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/archives.c0d49bd5.css","path":"static/css/archives.c0d49bd5.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/categories.10e2be12.css","path":"static/css/categories.10e2be12.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/chunk-libs.eebac533.css","path":"static/css/chunk-libs.eebac533.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/page.749ad047.css","path":"static/css/page.749ad047.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/post.9f951a60.css","path":"static/css/post.9f951a60.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/result.10e2be12.css","path":"static/css/result.10e2be12.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/tags.10e2be12.css","path":"static/css/tags.10e2be12.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/about.024aacd1.js","path":"static/js/about.024aacd1.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/404.00d640a8.js","path":"static/js/404.00d640a8.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/app.6d2c358d.js","path":"static/js/app.6d2c358d.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/categories.90aa5475.js","path":"static/js/categories.90aa5475.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/chunk-libs.dc6146cd.js","path":"static/js/chunk-libs.dc6146cd.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/page.a02618ad.js","path":"static/js/page.a02618ad.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/archives.574ac664.js","path":"static/js/archives.574ac664.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/icons/favicon-32x32.png","path":"icons/favicon-32x32.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/img/default-cover.df7c128c.jpg","path":"static/img/default-cover.df7c128c.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/result.39470350.js","path":"static/js/result.39470350.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/tags.2ad613f5.js","path":"static/js/tags.2ad613f5.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/post.cebfbaa4.js","path":"static/js/post.cebfbaa4.js","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/docker/Docker 镜像的使用.md","hash":"4ce77fa74aaab20d6748cfe98652414d856434a9","modified":1672736543278},{"_id":"source/about/index.md","hash":"b2ea07876b524191ee963194c9da39f89dc270f6","modified":1672736543279},{"_id":"source/_posts/docker/Docker 容器连接.md","hash":"e0df5090709c17423e02f16289001d55a625d064","modified":1672736543277},{"_id":"source/_posts/docker/Docker 容器的使用.md","hash":"31e8f72b69f8421e75ae0bae207433d68fb2426a","modified":1672736543277},{"_id":"source/_posts/typescript/TypeScript的数据类型.md","hash":"dbc0804fed31313b245c7fa52af3c37d7e3ec188","modified":1672736543278},{"_id":"source/_posts/typescript/webpack 搭建 ts 开发环境.md","hash":"22afc784be731b9373410a7819c30dcb4c87f29e","modified":1672736543279},{"_id":"node_modules/hexo-theme-Aurora/.browserslistrc","hash":"db215b841182d2af3259a1c1d6e1957bca333970","modified":1672726126472},{"_id":"source/_posts/typescript/tsconfig.json 编译配置.md","hash":"18b84b5c1ec9b429773306d2a7adf3b5bfcc1d26","modified":1672736543279},{"_id":"node_modules/hexo-theme-Aurora/LICENSE","hash":"21cf269018b0cf04e1126b6b9b1a5e6af7c5e61f","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/CHANGELOG.md","hash":"e68f3af8af17d326a48e1b317e01d7429193217e","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/package.json","hash":"1b312a6a2de107ba9dc952614f1078c78664a4e4","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/data/cn.yml","hash":"4f5dcc1e2953df7a8e4e683c1a9115f6e0041f5e","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/CHANGELOG_CN.md","hash":"5d13c251e8b77fd86870da50f3be98f8822edc66","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/_config.yml","hash":"e6b2335cb393444b8a1fc1ad65331f4a30bc8915","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/README.md","hash":"c50f58b08b75780990c18ab85761e3e24aac0d90","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/index.js","hash":"2a3c62a860581ee6813ca4bcaa7c952f614e818c","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/jest.config.js","hash":"425f08cb718a56630ce61ae0686f35c55ef565df","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/data/en.yml","hash":"7bbd6c0da0ae2f93f8a786a3be77fbe4e95a787e","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/.circleci/config.yml","hash":"534051be311581f69aa8287120275a04539290e4","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/filters/index.js","hash":"5eacff9446dd6c9a7eb0a0c84be9187055440454","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/category.js","hash":"0ae21ffcf6e471ebfb72ac62a833991fae86ec8a","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/index.js","hash":"dfbb0fdbf990bd67684ed891a4aaa1fd8dcd23f2","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/page.js","hash":"1be54ea9cdf8e293e67bf457075fcdd8a72b8779","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/post.js","hash":"76c3268e8b6887fb1fd11c4d71004aad9dc215fc","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/search.js","hash":"a2a636e1df76efdcaca37226b490afa539ce766b","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/site.js","hash":"b5f5ce813b4b0b322eceb11b036dc65201604256","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/statistic.js","hash":"1c641956e15cec96490de16a88ccc7bec0c9d5c4","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/generators/tag.js","hash":"975e79e73d2503a33dbc63655b948100cc46d44f","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/helpers/mapper.js","hash":"7a99508d910321b90b4afa0df02ad90f62336901","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/helpers/symbols-count-time.js","hash":"d1a81e31b2988edcdf4b4761cec7326a980f097a","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/helpers/toc.js","hash":"5c7348c550ef7f164d492847801a360cdefc60a2","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/helpers/truncate-html.js","hash":"49d4832af027eabe5b8383a24e66dceae761533e","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/helpers/utils.js","hash":"93ff75f0e35a1dc40d5406cc097f5988dd820600","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/scripts/lib/injector/index.js","hash":"7ca562ea3af3068ee925b5a8afdce0eaa1e15e64","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/404.1a6cd5bd.css","hash":"a7a4d83756520d8f6c410ac0ffe9a45d63868113","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/about.32dfa3b0.css","hash":"614ef7c4e52877c76ffddb26192bf8fffddcb8d8","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/archives.c0d49bd5.css","hash":"c56213315c57254d0a6e6301ef24c2186fef4d2b","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/categories.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/page.749ad047.css","hash":"6fcf0e6f3c628954c5f8105791e0e7f3e6512da6","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/chunk-libs.eebac533.css","hash":"41226b6c29aadcc6190fe7c2c4c37464855b8453","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/post.9f951a60.css","hash":"8e360582d745d6483fdfc18c46f75897b44721a6","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/icons/favicon-16x16.png","hash":"849cad2a5ae49fa54c20372f7a21ae95192bafcf","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/result.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/tags.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/favicon.ico","hash":"c39d3ad80489cffed0d3df82c8cb05a049ab39a3","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/404.00d640a8.js","hash":"74f1da9e0f953e73e4fe1a6554433f56fdcdf54d","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/about.024aacd1.js","hash":"7ce2b3f7d232dd3b3930ac993bb841452e2cde89","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/layout/index.ejs","hash":"94732830a65b718d2fa506b8598df44f14399fd8","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/categories.90aa5475.js","hash":"0dde3d731fc665962a4c330338a2c663c330be26","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/icons/favicon-32x32.png","hash":"9dbabf6f4d825da99dcb2e91583755ae8d3b3ff4","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/img/default-cover.df7c128c.jpg","hash":"1934ace0c6f2397d15729f9b08cc4d42e45bf437","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/page.a02618ad.js","hash":"db775fbfbaa1cf8bbf4cc4f2b0a869519d508e3a","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/archives.574ac664.js","hash":"fbb094fb4f7a01bffd6975aca27142935bfdca73","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/tags.2ad613f5.js","hash":"4f49139e435788710115fc884dc26a5b1e0d4833","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/result.39470350.js","hash":"f6f5ab2ca7274dad169ec600a419d1a2aeb2347c","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/css/app.0d31776f.css","hash":"43b43acd76bd8dc22f34cc49c7e026c45c3a5004","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/post.cebfbaa4.js","hash":"53586f9dab5886a366e9397eb17088e74af5cde1","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/app.6d2c358d.js","hash":"e176c20c22ce36e38935f463977e9b89b281c715","modified":1672726126472},{"_id":"node_modules/hexo-theme-Aurora/source/static/js/chunk-libs.dc6146cd.js","hash":"534266637d09abf39278f4d3a21bd36728740105","modified":1672726126472},{"_id":"public/api/posts/1.json","hash":"bf57212bba99bda6fab55292300112e6f3bd275a","modified":1672898614957},{"_id":"public/api/articles/docker/Docker 镜像的使用.json","hash":"36eee2d3080b95c710c5de68e2e7f0e61bc26470","modified":1672898614957},{"_id":"public/api/articles/docker/Docker 容器连接.json","hash":"fbb868db79864a9c9a738ebe8c9eede5fc2a10ca","modified":1672898614957},{"_id":"public/api/articles/docker/Docker 容器的使用.json","hash":"12ab95d544d1379266909a4416ba3f6c2f50c176","modified":1672898614957},{"_id":"public/api/articles/typescript/webpack 搭建 ts 开发环境.json","hash":"e278f289f3300d03aa204ca66ebbae81815e1028","modified":1672898614957},{"_id":"public/api/articles/typescript/TypeScript的数据类型.json","hash":"edc2e5e29827f0e905c4798afc386633d295ee8b","modified":1672898614957},{"_id":"public/api/articles/typescript/tsconfig.json 编译配置.json","hash":"b9ae6229b1ab7cf0bfc96d897a435fd5fb93b3e3","modified":1672898614957},{"_id":"public/api/features.json","hash":"53fad296b2a8b2ed291b89abfec295048c7972fd","modified":1672898614957},{"_id":"public/api/authors/blog-author.json","hash":"e3fdf11363e6e612ecb10136e7382453593da1cc","modified":1672898614957},{"_id":"public/api/site.json","hash":"4eccc24559afd93dcc2194799482c92a89d92184","modified":1672898614957},{"_id":"public/api/categories.json","hash":"a7ee89370f2237182b52f31b9786aa91a2a9e6e1","modified":1672898614957},{"_id":"public/api/categories/Docker.json","hash":"c4a55cb89802f859d3d94f5afc8f71a6ff483218","modified":1672898614957},{"_id":"public/api/categories/TypeScript.json","hash":"786e34d34932ac0b64626e6e5c4a55bb93b12fda","modified":1672898614957},{"_id":"public/api/tags.json","hash":"75e431c2249138ca739813dd5ceb21e930254c8d","modified":1672898614957},{"_id":"public/api/tags/Docker.json","hash":"c4a55cb89802f859d3d94f5afc8f71a6ff483218","modified":1672898614957},{"_id":"public/api/tags/容器.json","hash":"c7f947a3a5e92326dd05d2ae0c473e49ff885889","modified":1672898614957},{"_id":"public/api/tags/container.json","hash":"848ebe23d317d59cff7e684ea69e755dfa0d7349","modified":1672898614957},{"_id":"public/api/tags/镜像.json","hash":"3894b3cd80f6e3dad273afd504f83ddb71fae571","modified":1672898614957},{"_id":"public/api/tags/images.json","hash":"f3081b2ac84227e0df61d75a38793c90c6f78abc","modified":1672898614957},{"_id":"public/api/tags/TypeScript.json","hash":"f2f619bdfab383cff380a6f3bb495dae2b5deaa3","modified":1672898614957},{"_id":"public/api/tags/数据类型.json","hash":"951ca13394a2f4ec8f1460542ea7f5ef6fcad4c0","modified":1672898614957},{"_id":"public/api/tags/tsconfig.json","hash":"d824daf67712b3159aee7ab32d2be7f13ef6c672","modified":1672898614957},{"_id":"public/api/tags/环境搭建.json","hash":"e016d2a25bc7124a5a7ccb93d5e7f98de1f02ba5","modified":1672898614957},{"_id":"public/api/tags/webpack.json","hash":"71cfc3775f21c36ea97c00a2853c566df22f0502","modified":1672898614957},{"_id":"public/api/pages/about/index.json","hash":"30874f92cc0dbd6d6a02f1d5f33c3fb8bf0889db","modified":1672898614957},{"_id":"public/api/statistic.json","hash":"bec341be1375bfbf9c00a115709123da004ae693","modified":1672898614957},{"_id":"public/api/search.json","hash":"152fa619824e2860d6433132d436ceace763185f","modified":1672898614957},{"_id":"public/post/docker/Docker 镜像的使用.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672898614957},{"_id":"public/post/docker/Docker 容器连接.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672898614957},{"_id":"public/post/docker/Docker 容器的使用.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672898614957},{"_id":"public/post/typescript/webpack 搭建 ts 开发环境.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672898614957},{"_id":"public/post/typescript/TypeScript的数据类型.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672898614957},{"_id":"public/post/typescript/tsconfig.json 编译配置.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672898614957},{"_id":"public/index.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672898614957},{"_id":"public/tags/index.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672898614957},{"_id":"public/archives/index.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672898614957},{"_id":"public/page/about/index.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672898614957},{"_id":"public/tags/search/index.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672898614957},{"_id":"public/favicon.ico","hash":"c39d3ad80489cffed0d3df82c8cb05a049ab39a3","modified":1672898614957},{"_id":"public/icons/favicon-16x16.png","hash":"849cad2a5ae49fa54c20372f7a21ae95192bafcf","modified":1672898614957},{"_id":"public/static/img/default-cover.df7c128c.jpg","hash":"1934ace0c6f2397d15729f9b08cc4d42e45bf437","modified":1672898614957},{"_id":"public/icons/favicon-32x32.png","hash":"9dbabf6f4d825da99dcb2e91583755ae8d3b3ff4","modified":1672898614957},{"_id":"public/static/css/archives.c0d49bd5.css","hash":"c56213315c57254d0a6e6301ef24c2186fef4d2b","modified":1672898614957},{"_id":"public/static/css/about.32dfa3b0.css","hash":"614ef7c4e52877c76ffddb26192bf8fffddcb8d8","modified":1672898614957},{"_id":"public/static/css/404.1a6cd5bd.css","hash":"a7a4d83756520d8f6c410ac0ffe9a45d63868113","modified":1672898614957},{"_id":"public/static/css/categories.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1672898614957},{"_id":"public/static/css/chunk-libs.eebac533.css","hash":"41226b6c29aadcc6190fe7c2c4c37464855b8453","modified":1672898614957},{"_id":"public/static/css/page.749ad047.css","hash":"6fcf0e6f3c628954c5f8105791e0e7f3e6512da6","modified":1672898614957},{"_id":"public/static/css/post.9f951a60.css","hash":"8e360582d745d6483fdfc18c46f75897b44721a6","modified":1672898614957},{"_id":"public/static/css/result.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1672898614957},{"_id":"public/static/js/404.00d640a8.js","hash":"74f1da9e0f953e73e4fe1a6554433f56fdcdf54d","modified":1672898614957},{"_id":"public/static/js/about.024aacd1.js","hash":"7ce2b3f7d232dd3b3930ac993bb841452e2cde89","modified":1672898614957},{"_id":"public/static/css/tags.10e2be12.css","hash":"e0f686c442936311dd85f11a06f3937007758b90","modified":1672898614957},{"_id":"public/static/js/page.a02618ad.js","hash":"db775fbfbaa1cf8bbf4cc4f2b0a869519d508e3a","modified":1672898614957},{"_id":"public/static/js/categories.90aa5475.js","hash":"0dde3d731fc665962a4c330338a2c663c330be26","modified":1672898614957},{"_id":"public/static/js/archives.574ac664.js","hash":"fbb094fb4f7a01bffd6975aca27142935bfdca73","modified":1672898614957},{"_id":"public/static/js/tags.2ad613f5.js","hash":"4f49139e435788710115fc884dc26a5b1e0d4833","modified":1672898614957},{"_id":"public/static/js/post.cebfbaa4.js","hash":"53586f9dab5886a366e9397eb17088e74af5cde1","modified":1672898614957},{"_id":"public/static/js/result.39470350.js","hash":"f6f5ab2ca7274dad169ec600a419d1a2aeb2347c","modified":1672898614957},{"_id":"public/static/css/app.0d31776f.css","hash":"43b43acd76bd8dc22f34cc49c7e026c45c3a5004","modified":1672898614957},{"_id":"public/static/js/app.6d2c358d.js","hash":"e176c20c22ce36e38935f463977e9b89b281c715","modified":1672898614957},{"_id":"public/static/js/chunk-libs.dc6146cd.js","hash":"534266637d09abf39278f4d3a21bd36728740105","modified":1672898614957},{"_id":"source/_posts/typescript/基础/原始数据类型.md","hash":"2cadb0abcd169ea8a325aedb2f29680be2087398","modified":1672891247370},{"_id":"source/_posts/typescript/基础/基础.md","hash":"fdd878442a17cfb9b80b0485b69051e838c7d5fc","modified":1672886261498},{"_id":"public/api/articles/typescript/基础/基础.json","hash":"2fdfa495b6b6a7e67a3220314a3c2876b4bc3593","modified":1672898614957},{"_id":"public/api/articles/typescript/基础/原始数据类型.json","hash":"f76a6bafa5274ab14dc5248b4e07c5b7e741c17f","modified":1672898614957},{"_id":"public/api/categories/TypeScript入门.json","hash":"bb3f76b427c645870a3439029f776127a64fb119","modified":1672898614957},{"_id":"public/post/typescript/基础/基础.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672898614957},{"_id":"public/post/typescript/基础/原始数据类型.html","hash":"e42984e19ae5fcc0ccdb10d5404fb749e92a8d42","modified":1672898614957},{"_id":"source/CNAME","hash":"83c679868a95497228d71a2df4ebbfdabdd1b61c","modified":1672898573616},{"_id":"public/CNAME","hash":"83c679868a95497228d71a2df4ebbfdabdd1b61c","modified":1672898614957}],"Category":[{"name":"Docker","_id":"clcigr1t90003nkvnf0wi994y"},{"name":"TypeScript","_id":"clcigr1tg000cnkvnf38pb39f"},{"name":"TypeScript入门","_id":"clcikoslp0003asvn9q3k3qq7"}],"Data":[],"Page":[{"_content":"### 哈哈哈","source":"about/index.md","raw":"### 哈哈哈","date":"2023-01-03T09:02:23.279Z","updated":"2023-01-03T09:02:23.279Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"clcigr1t00000nkvngdym1366","content":"<h3 id=\"哈哈哈\"><a href=\"#哈哈哈\" class=\"headerlink\" title=\"哈哈哈\"></a>哈哈哈</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"哈哈哈\"><a href=\"#哈哈哈\" class=\"headerlink\" title=\"哈哈哈\"></a>哈哈哈</h3>"}],"Post":[{"title":"Docker 容器的使用","date":"2023-01-03T07:13:50.000Z","cover":"https://www.helloimg.com/images/2023/01/03/oCD5cE.png","_content":"\n# 网络端口映射\n有以下两种端口映射方式\n```shell\ndocker run -itd -P --name centos8 dokken/centos-8 /bin/bash\n```\n```shell\ndocker run -itd -p 1000:22 --name centos8 dokken/centos-8 /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- -d: 后台运行\n- -p 1000:22 :以指定的1000端口映射容器的22端口\n- -P: 容器内部端口随机映射到主机端口\n- --name: 容器别名\n- dokken/centos-8: 容器源名称\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n## 区别\n\n- -P :是容器内部端口随机映射到主机的端口。\n- -p : 是容器内部端口绑定到指定的主机端口。\n\n另外, 我们可以指定容器绑定的网络地址, 比如绑定 127.0.0.1\n```shell\ndocker run -itd -p 127.0.0.1:1000:22 --name centos8 dokken/centos-8 /bin/bash\n```\n这样我们就可以通过` 127.0.0.1:1000 `来访问容器的22端口了\n","source":"_posts/docker/Docker 容器连接.md","raw":"---\ntitle: Docker 容器的使用\ndate: 2023/1/3 15:13:50\ncover: https://www.helloimg.com/images/2023/01/03/oCD5cE.png\ncategories:\n  - Docker\ntags:\n  - Docker\n  - 容器\n  - container\n---\n\n# 网络端口映射\n有以下两种端口映射方式\n```shell\ndocker run -itd -P --name centos8 dokken/centos-8 /bin/bash\n```\n```shell\ndocker run -itd -p 1000:22 --name centos8 dokken/centos-8 /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- -d: 后台运行\n- -p 1000:22 :以指定的1000端口映射容器的22端口\n- -P: 容器内部端口随机映射到主机端口\n- --name: 容器别名\n- dokken/centos-8: 容器源名称\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n## 区别\n\n- -P :是容器内部端口随机映射到主机的端口。\n- -p : 是容器内部端口绑定到指定的主机端口。\n\n另外, 我们可以指定容器绑定的网络地址, 比如绑定 127.0.0.1\n```shell\ndocker run -itd -p 127.0.0.1:1000:22 --name centos8 dokken/centos-8 /bin/bash\n```\n这样我们就可以通过` 127.0.0.1:1000 `来访问容器的22端口了\n","slug":"docker/Docker 容器连接","published":1,"updated":"2023-01-03T09:02:23.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcigr1t40001nkvndf6uefcy","content":"<h1 id=\"网络端口映射\"><a href=\"#网络端口映射\" class=\"headerlink\" title=\"网络端口映射\"></a>网络端口映射</h1><p>有以下两种端口映射方式</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -itd -P --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash</code></pre>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -itd -p 1000:22 --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><ul>\n<li><p>-i：交互式操作</p>\n</li>\n<li><p>-t: 终端</p>\n</li>\n<li><p>-d: 后台运行</p>\n</li>\n<li><p>-p 1000:22 :以指定的1000端口映射容器的22端口</p>\n</li>\n<li><p>-P: 容器内部端口随机映射到主机端口</p>\n</li>\n<li><p>–name: 容器别名</p>\n</li>\n<li><p>dokken/centos-8: 容器源名称</p>\n</li>\n<li><p>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</p>\n<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2></li>\n<li><p>-P :是容器内部端口随机映射到主机的端口。</p>\n</li>\n<li><p>-p : 是容器内部端口绑定到指定的主机端口。</p>\n</li>\n</ul>\n<p>另外, 我们可以指定容器绑定的网络地址, 比如绑定 127.0.0.1</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -itd -p 127.0.0.1:1000:22 --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash</code></pre>\n<p>这样我们就可以通过<code>127.0.0.1:1000</code>来访问容器的22端口了</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"网络端口映射\"><a href=\"#网络端口映射\" class=\"headerlink\" title=\"网络端口映射\"></a>网络端口映射</h1><p>有以下两种端口映射方式</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -itd -P --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash</code></pre>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -itd -p 1000:22 --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><ul>\n<li><p>-i：交互式操作</p>\n</li>\n<li><p>-t: 终端</p>\n</li>\n<li><p>-d: 后台运行</p>\n</li>\n<li><p>-p 1000:22 :以指定的1000端口映射容器的22端口</p>\n</li>\n<li><p>-P: 容器内部端口随机映射到主机端口</p>\n</li>\n<li><p>–name: 容器别名</p>\n</li>\n<li><p>dokken/centos-8: 容器源名称</p>\n</li>\n<li><p>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</p>\n<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2></li>\n<li><p>-P :是容器内部端口随机映射到主机的端口。</p>\n</li>\n<li><p>-p : 是容器内部端口绑定到指定的主机端口。</p>\n</li>\n</ul>\n<p>另外, 我们可以指定容器绑定的网络地址, 比如绑定 127.0.0.1</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -itd -p 127.0.0.1:1000:22 --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash</code></pre>\n<p>这样我们就可以通过<code>127.0.0.1:1000</code>来访问容器的22端口了</p>\n"},{"title":"Docker 容器的使用","date":"2022-12-06T08:00:12.000Z","cover":"https://www.helloimg.com/images/2023/01/03/oCD5cE.png","_content":"\n# 获取容器\n我们可以使用docker pull 命令来下载 centos镜像\n```shell\n$ docker pull centos8\n```\n# 启动容器\n```shell\n$ docker run -it centos8 /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- centos8：centos8镜像\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n\n如果要退出终端那就使用\n```shell\n$ exit\n```\n# 查看所有容器\n```shell\n$ docker ps -a\n```\n# 启动一个已经停止的容器\n```shell\n$ docker start b750bbbcfd88(容器id)\n```\n# 停止一个已经启动的容器\n```shell\n$ docker stop b750bbbcfd88(容器id)\n```\n# 后台运行容器(不想进入容器的时候)\n```shell\n$ docker -itd --name content_8 centos8 /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- -d: 后台运行\n- --name: 运行时指定容器的名称\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n# 进入容器\n在使用参数 `-d` 时, 容器会进入后台, 这个时候如果想要进入容器内部可以使用以下命令\n```shell\n$ docker exec -it [容器ID] /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n# 导入和导出容器\n## 导出容器\n如果要导出到本地的某个容器, 可以使用 `docker export` 命令\n```shell\n$ docker export [容器ID] > centos8.tar\n```\n> 导出容器ID到本地文件的 centos8.tar\n\n## 导入容器\n```shell\n$ cat docker/ubuntu.tar | docker import - test/ubuntu:v1\n```\n此外, 还可以通过指定URL或某个目录来导入\n```shell\n$ docker import http://example.com/exampleimage.tgz example/imagerepo\n```\n## 删除容器\n```shell\n$ docker rm -f [容器ID]\n```\n清除所有处于终止状态下的容器\n```shell\n$ docker container prune\n```\n\n","source":"_posts/docker/Docker 容器的使用.md","raw":"---\ntitle: Docker 容器的使用\ndate: 2022/12/06 16:00:12\ncover: https://www.helloimg.com/images/2023/01/03/oCD5cE.png\ncategories:\n  - Docker\ntags:\n  - Docker\n  - 容器\n  - container\n---\n\n# 获取容器\n我们可以使用docker pull 命令来下载 centos镜像\n```shell\n$ docker pull centos8\n```\n# 启动容器\n```shell\n$ docker run -it centos8 /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- centos8：centos8镜像\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n\n如果要退出终端那就使用\n```shell\n$ exit\n```\n# 查看所有容器\n```shell\n$ docker ps -a\n```\n# 启动一个已经停止的容器\n```shell\n$ docker start b750bbbcfd88(容器id)\n```\n# 停止一个已经启动的容器\n```shell\n$ docker stop b750bbbcfd88(容器id)\n```\n# 后台运行容器(不想进入容器的时候)\n```shell\n$ docker -itd --name content_8 centos8 /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- -d: 后台运行\n- --name: 运行时指定容器的名称\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n# 进入容器\n在使用参数 `-d` 时, 容器会进入后台, 这个时候如果想要进入容器内部可以使用以下命令\n```shell\n$ docker exec -it [容器ID] /bin/bash\n```\n## 参数说明\n\n- -i：交互式操作\n- -t: 终端\n- /bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n# 导入和导出容器\n## 导出容器\n如果要导出到本地的某个容器, 可以使用 `docker export` 命令\n```shell\n$ docker export [容器ID] > centos8.tar\n```\n> 导出容器ID到本地文件的 centos8.tar\n\n## 导入容器\n```shell\n$ cat docker/ubuntu.tar | docker import - test/ubuntu:v1\n```\n此外, 还可以通过指定URL或某个目录来导入\n```shell\n$ docker import http://example.com/exampleimage.tgz example/imagerepo\n```\n## 删除容器\n```shell\n$ docker rm -f [容器ID]\n```\n清除所有处于终止状态下的容器\n```shell\n$ docker container prune\n```\n\n","slug":"docker/Docker 容器的使用","published":1,"updated":"2023-01-03T09:02:23.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcigr1t80002nkvn96s9a7g8","content":"<h1 id=\"获取容器\"><a href=\"#获取容器\" class=\"headerlink\" title=\"获取容器\"></a>获取容器</h1><p>我们可以使用docker pull 命令来下载 centos镜像</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker pull centos8</code></pre>\n<h1 id=\"启动容器\"><a href=\"#启动容器\" class=\"headerlink\" title=\"启动容器\"></a>启动容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker run -it centos8 &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><ul>\n<li>-i：交互式操作</li>\n<li>-t: 终端</li>\n<li>centos8：centos8镜像</li>\n<li>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</li>\n</ul>\n<p>如果要退出终端那就使用</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ exit</code></pre>\n<h1 id=\"查看所有容器\"><a href=\"#查看所有容器\" class=\"headerlink\" title=\"查看所有容器\"></a>查看所有容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker ps -a</code></pre>\n<h1 id=\"启动一个已经停止的容器\"><a href=\"#启动一个已经停止的容器\" class=\"headerlink\" title=\"启动一个已经停止的容器\"></a>启动一个已经停止的容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker start b750bbbcfd88(容器id)</code></pre>\n<h1 id=\"停止一个已经启动的容器\"><a href=\"#停止一个已经启动的容器\" class=\"headerlink\" title=\"停止一个已经启动的容器\"></a>停止一个已经启动的容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker stop b750bbbcfd88(容器id)</code></pre>\n<h1 id=\"后台运行容器-不想进入容器的时候\"><a href=\"#后台运行容器-不想进入容器的时候\" class=\"headerlink\" title=\"后台运行容器(不想进入容器的时候)\"></a>后台运行容器(不想进入容器的时候)</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker -itd --name content_8 centos8 &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明-1\"><a href=\"#参数说明-1\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><ul>\n<li><p>-i：交互式操作</p>\n</li>\n<li><p>-t: 终端</p>\n</li>\n<li><p>-d: 后台运行</p>\n</li>\n<li><p>–name: 运行时指定容器的名称</p>\n</li>\n<li><p>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</p>\n<h1 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h1><p>在使用参数 <code>-d</code> 时, 容器会进入后台, 这个时候如果想要进入容器内部可以使用以下命令</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker exec -it [容器ID] &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明-2\"><a href=\"#参数说明-2\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2></li>\n<li><p>-i：交互式操作</p>\n</li>\n<li><p>-t: 终端</p>\n</li>\n<li><p>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</p>\n<h1 id=\"导入和导出容器\"><a href=\"#导入和导出容器\" class=\"headerlink\" title=\"导入和导出容器\"></a>导入和导出容器</h1><h2 id=\"导出容器\"><a href=\"#导出容器\" class=\"headerlink\" title=\"导出容器\"></a>导出容器</h2><p>如果要导出到本地的某个容器, 可以使用 <code>docker export</code> 命令</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker export [容器ID] &gt; centos8.tar</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>导出容器ID到本地文件的 centos8.tar</p></blockquote>\n</li>\n</ul>\n<h2 id=\"导入容器\"><a href=\"#导入容器\" class=\"headerlink\" title=\"导入容器\"></a>导入容器</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ cat docker&#x2F;ubuntu.tar | docker import - test&#x2F;ubuntu:v1</code></pre>\n<p>此外, 还可以通过指定URL或某个目录来导入</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker import http:&#x2F;&#x2F;example.com&#x2F;exampleimage.tgz example&#x2F;imagerepo</code></pre>\n<h2 id=\"删除容器\"><a href=\"#删除容器\" class=\"headerlink\" title=\"删除容器\"></a>删除容器</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker rm -f [容器ID]</code></pre>\n<p>清除所有处于终止状态下的容器</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker container prune</code></pre>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"获取容器\"><a href=\"#获取容器\" class=\"headerlink\" title=\"获取容器\"></a>获取容器</h1><p>我们可以使用docker pull 命令来下载 centos镜像</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker pull centos8</code></pre>\n<h1 id=\"启动容器\"><a href=\"#启动容器\" class=\"headerlink\" title=\"启动容器\"></a>启动容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker run -it centos8 &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><ul>\n<li>-i：交互式操作</li>\n<li>-t: 终端</li>\n<li>centos8：centos8镜像</li>\n<li>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</li>\n</ul>\n<p>如果要退出终端那就使用</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ exit</code></pre>\n<h1 id=\"查看所有容器\"><a href=\"#查看所有容器\" class=\"headerlink\" title=\"查看所有容器\"></a>查看所有容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker ps -a</code></pre>\n<h1 id=\"启动一个已经停止的容器\"><a href=\"#启动一个已经停止的容器\" class=\"headerlink\" title=\"启动一个已经停止的容器\"></a>启动一个已经停止的容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker start b750bbbcfd88(容器id)</code></pre>\n<h1 id=\"停止一个已经启动的容器\"><a href=\"#停止一个已经启动的容器\" class=\"headerlink\" title=\"停止一个已经启动的容器\"></a>停止一个已经启动的容器</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker stop b750bbbcfd88(容器id)</code></pre>\n<h1 id=\"后台运行容器-不想进入容器的时候\"><a href=\"#后台运行容器-不想进入容器的时候\" class=\"headerlink\" title=\"后台运行容器(不想进入容器的时候)\"></a>后台运行容器(不想进入容器的时候)</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker -itd --name content_8 centos8 &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明-1\"><a href=\"#参数说明-1\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><ul>\n<li><p>-i：交互式操作</p>\n</li>\n<li><p>-t: 终端</p>\n</li>\n<li><p>-d: 后台运行</p>\n</li>\n<li><p>–name: 运行时指定容器的名称</p>\n</li>\n<li><p>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</p>\n<h1 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h1><p>在使用参数 <code>-d</code> 时, 容器会进入后台, 这个时候如果想要进入容器内部可以使用以下命令</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker exec -it [容器ID] &#x2F;bin&#x2F;bash</code></pre>\n<h2 id=\"参数说明-2\"><a href=\"#参数说明-2\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2></li>\n<li><p>-i：交互式操作</p>\n</li>\n<li><p>-t: 终端</p>\n</li>\n<li><p>/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash</p>\n<h1 id=\"导入和导出容器\"><a href=\"#导入和导出容器\" class=\"headerlink\" title=\"导入和导出容器\"></a>导入和导出容器</h1><h2 id=\"导出容器\"><a href=\"#导出容器\" class=\"headerlink\" title=\"导出容器\"></a>导出容器</h2><p>如果要导出到本地的某个容器, 可以使用 <code>docker export</code> 命令</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker export [容器ID] &gt; centos8.tar</code></pre>\n<blockquote>\n<p>导出容器ID到本地文件的 centos8.tar</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"导入容器\"><a href=\"#导入容器\" class=\"headerlink\" title=\"导入容器\"></a>导入容器</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ cat docker&#x2F;ubuntu.tar | docker import - test&#x2F;ubuntu:v1</code></pre>\n<p>此外, 还可以通过指定URL或某个目录来导入</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker import http:&#x2F;&#x2F;example.com&#x2F;exampleimage.tgz example&#x2F;imagerepo</code></pre>\n<h2 id=\"删除容器\"><a href=\"#删除容器\" class=\"headerlink\" title=\"删除容器\"></a>删除容器</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker rm -f [容器ID]</code></pre>\n<p>清除所有处于终止状态下的容器</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker container prune</code></pre>\n\n"},{"title":"Docker 镜像的使用","date":"2023-01-03T07:15:43.000Z","cover":"https://www.helloimg.com/images/2023/01/03/oCD5cE.png","_content":"\n# 列出镜像列表\n我们可以使用 `docker images` 来列出本地主机上的镜像\n```shell\n$ docker images\n```\n![image.png](https://s2.loli.net/2023/01/03/jYuRFcMDSm1Orlx.png)\n## 选项说明\n\n- REPOSITORY: 表示镜像的仓库源\n- TAG:　镜像的标签\n- IMAGE ID: 镜像ID\n- CREATED: 镜像的创建时间\n- SIZE: 镜像大小\n> 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。\n\n# 获取一个新的镜像\n当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。\n```shell\ndocker pull centos:8\n```\n当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。\n# 查找镜像\n我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： [https://hub.docker.com/](https://hub.docker.com/)\n我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。\n```shell\n$ docker search httpd\n```\n![image.png](https://s2.loli.net/2023/01/03/zlKVAxekZowgcYq.png)\n## 选项说明\n\n- NAME: 镜像仓库源名称\n- DESCRIPTION: 镜像的描述\n- OFFICIAL: 是否 docker 官方发布\n- STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。\n- AUTOMATED: 自动构建。\n# 拖取镜像\n```shell\n$ docker pull httpd\n```\n下载完后我们就可以使用这个镜像了\n```shell\n$ docker run httpd\n```\n# 删除镜像\n```shell\n$ docker rmi httpd\n```\n","source":"_posts/docker/Docker 镜像的使用.md","raw":"---\ntitle: Docker 镜像的使用\ndate: 2023/1/3 15:15:43\ncover: https://www.helloimg.com/images/2023/01/03/oCD5cE.png\ncategories:\n  - Docker\ntags:\n  - Docker\n  - 镜像\n  - images\n---\n\n# 列出镜像列表\n我们可以使用 `docker images` 来列出本地主机上的镜像\n```shell\n$ docker images\n```\n![image.png](https://s2.loli.net/2023/01/03/jYuRFcMDSm1Orlx.png)\n## 选项说明\n\n- REPOSITORY: 表示镜像的仓库源\n- TAG:　镜像的标签\n- IMAGE ID: 镜像ID\n- CREATED: 镜像的创建时间\n- SIZE: 镜像大小\n> 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。\n\n# 获取一个新的镜像\n当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。\n```shell\ndocker pull centos:8\n```\n当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。\n# 查找镜像\n我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： [https://hub.docker.com/](https://hub.docker.com/)\n我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。\n```shell\n$ docker search httpd\n```\n![image.png](https://s2.loli.net/2023/01/03/zlKVAxekZowgcYq.png)\n## 选项说明\n\n- NAME: 镜像仓库源名称\n- DESCRIPTION: 镜像的描述\n- OFFICIAL: 是否 docker 官方发布\n- STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。\n- AUTOMATED: 自动构建。\n# 拖取镜像\n```shell\n$ docker pull httpd\n```\n下载完后我们就可以使用这个镜像了\n```shell\n$ docker run httpd\n```\n# 删除镜像\n```shell\n$ docker rmi httpd\n```\n","slug":"docker/Docker 镜像的使用","published":1,"updated":"2023-01-03T09:02:23.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcigr1tb0005nkvn2l9ag8h9","content":"<h1 id=\"列出镜像列表\"><a href=\"#列出镜像列表\" class=\"headerlink\" title=\"列出镜像列表\"></a>列出镜像列表</h1><p>我们可以使用 <code>docker images</code> 来列出本地主机上的镜像</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker images</code></pre>\n<p><img src=\"https://s2.loli.net/2023/01/03/jYuRFcMDSm1Orlx.png\" alt=\"image.png\"></p>\n<h2 id=\"选项说明\"><a href=\"#选项说明\" class=\"headerlink\" title=\"选项说明\"></a>选项说明</h2><ul>\n<li>REPOSITORY: 表示镜像的仓库源</li>\n<li>TAG:　镜像的标签</li>\n<li>IMAGE ID: 镜像ID</li>\n<li>CREATED: 镜像的创建时间</li>\n<li>SIZE: 镜像大小<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p></blockquote>\n</li>\n</ul>\n<h1 id=\"获取一个新的镜像\"><a href=\"#获取一个新的镜像\" class=\"headerlink\" title=\"获取一个新的镜像\"></a>获取一个新的镜像</h1><p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker pull centos:8</code></pre>\n<p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p>\n<h1 id=\"查找镜像\"><a href=\"#查找镜像\" class=\"headerlink\" title=\"查找镜像\"></a>查找镜像</h1><p>我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <a href=\"https://hub.docker.com/\">https://hub.docker.com/</a><br>我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker search httpd</code></pre>\n<p><img src=\"https://s2.loli.net/2023/01/03/zlKVAxekZowgcYq.png\" alt=\"image.png\"></p>\n<h2 id=\"选项说明-1\"><a href=\"#选项说明-1\" class=\"headerlink\" title=\"选项说明\"></a>选项说明</h2><ul>\n<li>NAME: 镜像仓库源名称</li>\n<li>DESCRIPTION: 镜像的描述</li>\n<li>OFFICIAL: 是否 docker 官方发布</li>\n<li>STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。</li>\n<li>AUTOMATED: 自动构建。<h1 id=\"拖取镜像\"><a href=\"#拖取镜像\" class=\"headerlink\" title=\"拖取镜像\"></a>拖取镜像</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker pull httpd</code></pre>\n下载完后我们就可以使用这个镜像了<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker run httpd</code></pre>\n<h1 id=\"删除镜像\"><a href=\"#删除镜像\" class=\"headerlink\" title=\"删除镜像\"></a>删除镜像</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker rmi httpd</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"列出镜像列表\"><a href=\"#列出镜像列表\" class=\"headerlink\" title=\"列出镜像列表\"></a>列出镜像列表</h1><p>我们可以使用 <code>docker images</code> 来列出本地主机上的镜像</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker images</code></pre>\n<p><img src=\"https://s2.loli.net/2023/01/03/jYuRFcMDSm1Orlx.png\" alt=\"image.png\"></p>\n<h2 id=\"选项说明\"><a href=\"#选项说明\" class=\"headerlink\" title=\"选项说明\"></a>选项说明</h2><ul>\n<li>REPOSITORY: 表示镜像的仓库源</li>\n<li>TAG:　镜像的标签</li>\n<li>IMAGE ID: 镜像ID</li>\n<li>CREATED: 镜像的创建时间</li>\n<li>SIZE: 镜像大小<blockquote>\n<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"获取一个新的镜像\"><a href=\"#获取一个新的镜像\" class=\"headerlink\" title=\"获取一个新的镜像\"></a>获取一个新的镜像</h1><p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker pull centos:8</code></pre>\n<p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p>\n<h1 id=\"查找镜像\"><a href=\"#查找镜像\" class=\"headerlink\" title=\"查找镜像\"></a>查找镜像</h1><p>我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <a href=\"https://hub.docker.com/\">https://hub.docker.com/</a><br>我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker search httpd</code></pre>\n<p><img src=\"https://s2.loli.net/2023/01/03/zlKVAxekZowgcYq.png\" alt=\"image.png\"></p>\n<h2 id=\"选项说明-1\"><a href=\"#选项说明-1\" class=\"headerlink\" title=\"选项说明\"></a>选项说明</h2><ul>\n<li>NAME: 镜像仓库源名称</li>\n<li>DESCRIPTION: 镜像的描述</li>\n<li>OFFICIAL: 是否 docker 官方发布</li>\n<li>STARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。</li>\n<li>AUTOMATED: 自动构建。<h1 id=\"拖取镜像\"><a href=\"#拖取镜像\" class=\"headerlink\" title=\"拖取镜像\"></a>拖取镜像</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker pull httpd</code></pre>\n下载完后我们就可以使用这个镜像了<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker run httpd</code></pre>\n<h1 id=\"删除镜像\"><a href=\"#删除镜像\" class=\"headerlink\" title=\"删除镜像\"></a>删除镜像</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker rmi httpd</code></pre></li>\n</ul>\n"},{"title":"TypeScript的数据类型","date":"2022-03-05T08:47:36.000Z","cover":"https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png","_content":"\n# TypeScript的数据类型\n\n> 变量一但定义了某个数据类型后就不允许赋值其他数据类型的数值了\n\n\n## 基础数据类型\n\n### number\n\n### string\n\n### boolean\n\n### void\n\n### null\n\n### undefinded\n\n### any (使用 TS 时不建议使用 any 类型)\n\n```typescript\n// 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet d; <=> let d: any;\n\n// any 类型还可以赋值给任意类型的变量\nlet s: string;\ns = d // 这时候是成立的\n```\n\n### unknown\n\n```typescript\n// 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet un: unknown;\n\n// any 类型还可以赋值给任意类型的变量\nlet s: string;\ns = un // 这时候是不成立的\n// 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n// unknown 实际上就是一个类型安全的 any\n// unknown 类型的变量不能直接赋值给其他类型的变量,可以间接实现\nif (typeof un === 'string') {\n  s = un; // 由于先进行了类型判断, 所以这时候赋值是成立的\n}\n```\n\n### enum(枚举类型)\n\n```typescript\n// 使用场景\nenum Gender {\n  male,\n  female\n}\n\nlet p: { name: string, gender: Gender }\np = {\n  name: '林丹',\n  gnder: Gender.male\n}\n```\n\n## 引用数据类型\n\n### array\n\n### object\n\n```typescript\n// 基础的定义方式\n// 由于在 js 中几乎万物皆是对象,所以不推荐这样使用\nlet o: object\no = {}\no = function\n\n// 可以用字面量的方式\nlet o1: { name: string, age: number }\no1 = { name: 'hanler', age: 12 }\n\n// 如果要可选常数则在常数后面加个问号\nlet o2: { name: string, age?: number }\no2 = { name: 'hehe' }\n\n// 当你需要一个固定值, 但是又需要其他值且不清楚数量的时候可以像以下定义\n/**\n * @param {string} propsName 这个是属性名, 后面的 string 代表的是 string 格式的属性名\n * 中括号后面的 string 代表的是属性(propsName)的值的格式\n * */\nlet o3: { name: string, [propsName: string]: string }\no3 = { name: 'str', age: '12' }\n```\n\n## 类型断言\n\n> 可以用来告诉 ts 解析器变量的实际数据类型\n\n\n```typescript\nlet un: nuknown;\nun = 'string'\n\nlet s: string;\n\ns = un; // 此时是不成立的\n// 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n// 由于此时的 un 确实是 string 类型,我们可以使用类型断言来告诉解析器 un 就是 string 类型的来解决解析器报错问题\n\n// 两种写法\ns = un as string;\ns = <string>un;\n```\n","source":"_posts/typescript/TypeScript的数据类型.md","raw":"---\ntitle: TypeScript的数据类型\ndate: 2022/3/5 16:47:36\ncover: https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png\ncategories:\n  - TypeScript\ntags:\n  - TypeScript\n  - 数据类型\n---\n\n# TypeScript的数据类型\n\n> 变量一但定义了某个数据类型后就不允许赋值其他数据类型的数值了\n\n\n## 基础数据类型\n\n### number\n\n### string\n\n### boolean\n\n### void\n\n### null\n\n### undefinded\n\n### any (使用 TS 时不建议使用 any 类型)\n\n```typescript\n// 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet d; <=> let d: any;\n\n// any 类型还可以赋值给任意类型的变量\nlet s: string;\ns = d // 这时候是成立的\n```\n\n### unknown\n\n```typescript\n// 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet un: unknown;\n\n// any 类型还可以赋值给任意类型的变量\nlet s: string;\ns = un // 这时候是不成立的\n// 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n// unknown 实际上就是一个类型安全的 any\n// unknown 类型的变量不能直接赋值给其他类型的变量,可以间接实现\nif (typeof un === 'string') {\n  s = un; // 由于先进行了类型判断, 所以这时候赋值是成立的\n}\n```\n\n### enum(枚举类型)\n\n```typescript\n// 使用场景\nenum Gender {\n  male,\n  female\n}\n\nlet p: { name: string, gender: Gender }\np = {\n  name: '林丹',\n  gnder: Gender.male\n}\n```\n\n## 引用数据类型\n\n### array\n\n### object\n\n```typescript\n// 基础的定义方式\n// 由于在 js 中几乎万物皆是对象,所以不推荐这样使用\nlet o: object\no = {}\no = function\n\n// 可以用字面量的方式\nlet o1: { name: string, age: number }\no1 = { name: 'hanler', age: 12 }\n\n// 如果要可选常数则在常数后面加个问号\nlet o2: { name: string, age?: number }\no2 = { name: 'hehe' }\n\n// 当你需要一个固定值, 但是又需要其他值且不清楚数量的时候可以像以下定义\n/**\n * @param {string} propsName 这个是属性名, 后面的 string 代表的是 string 格式的属性名\n * 中括号后面的 string 代表的是属性(propsName)的值的格式\n * */\nlet o3: { name: string, [propsName: string]: string }\no3 = { name: 'str', age: '12' }\n```\n\n## 类型断言\n\n> 可以用来告诉 ts 解析器变量的实际数据类型\n\n\n```typescript\nlet un: nuknown;\nun = 'string'\n\nlet s: string;\n\ns = un; // 此时是不成立的\n// 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n// 由于此时的 un 确实是 string 类型,我们可以使用类型断言来告诉解析器 un 就是 string 类型的来解决解析器报错问题\n\n// 两种写法\ns = un as string;\ns = <string>un;\n```\n","slug":"typescript/TypeScript的数据类型","published":1,"updated":"2023-01-03T09:02:23.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcigr1td0006nkvn7c1x3xga","content":"<h1 id=\"TypeScript的数据类型\"><a href=\"#TypeScript的数据类型\" class=\"headerlink\" title=\"TypeScript的数据类型\"></a>TypeScript的数据类型</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>变量一但定义了某个数据类型后就不允许赋值其他数据类型的数值了</p></blockquote>\n<h2 id=\"基础数据类型\"><a href=\"#基础数据类型\" class=\"headerlink\" title=\"基础数据类型\"></a>基础数据类型</h2><h3 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\"number\"></a>number</h3><h3 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h3><h3 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h3><h3 id=\"void\"><a href=\"#void\" class=\"headerlink\" title=\"void\"></a>void</h3><h3 id=\"null\"><a href=\"#null\" class=\"headerlink\" title=\"null\"></a>null</h3><h3 id=\"undefinded\"><a href=\"#undefinded\" class=\"headerlink\" title=\"undefinded\"></a>undefinded</h3><h3 id=\"any-使用-TS-时不建议使用-any-类型\"><a href=\"#any-使用-TS-时不建议使用-any-类型\" class=\"headerlink\" title=\"any (使用 TS 时不建议使用 any 类型)\"></a>any (使用 TS 时不建议使用 any 类型)</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet d; &lt;&#x3D;&gt; let d: any;\n\n&#x2F;&#x2F; any 类型还可以赋值给任意类型的变量\nlet s: string;\ns &#x3D; d &#x2F;&#x2F; 这时候是成立的</code></pre>\n\n<h3 id=\"unknown\"><a href=\"#unknown\" class=\"headerlink\" title=\"unknown\"></a>unknown</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet un: unknown;\n\n&#x2F;&#x2F; any 类型还可以赋值给任意类型的变量\nlet s: string;\ns &#x3D; un &#x2F;&#x2F; 这时候是不成立的\n&#x2F;&#x2F; 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n&#x2F;&#x2F; unknown 实际上就是一个类型安全的 any\n&#x2F;&#x2F; unknown 类型的变量不能直接赋值给其他类型的变量,可以间接实现\nif (typeof un &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;\n  s &#x3D; un; &#x2F;&#x2F; 由于先进行了类型判断, 所以这时候赋值是成立的\n&#125;</code></pre>\n\n<h3 id=\"enum-枚举类型\"><a href=\"#enum-枚举类型\" class=\"headerlink\" title=\"enum(枚举类型)\"></a>enum(枚举类型)</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 使用场景\nenum Gender &#123;\n  male,\n  female\n&#125;\n\nlet p: &#123; name: string, gender: Gender &#125;\np &#x3D; &#123;\n  name: &#39;林丹&#39;,\n  gnder: Gender.male\n&#125;</code></pre>\n\n<h2 id=\"引用数据类型\"><a href=\"#引用数据类型\" class=\"headerlink\" title=\"引用数据类型\"></a>引用数据类型</h2><h3 id=\"array\"><a href=\"#array\" class=\"headerlink\" title=\"array\"></a>array</h3><h3 id=\"object\"><a href=\"#object\" class=\"headerlink\" title=\"object\"></a>object</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 基础的定义方式\n&#x2F;&#x2F; 由于在 js 中几乎万物皆是对象,所以不推荐这样使用\nlet o: object\no &#x3D; &#123;&#125;\no &#x3D; function\n\n&#x2F;&#x2F; 可以用字面量的方式\nlet o1: &#123; name: string, age: number &#125;\no1 &#x3D; &#123; name: &#39;hanler&#39;, age: 12 &#125;\n\n&#x2F;&#x2F; 如果要可选常数则在常数后面加个问号\nlet o2: &#123; name: string, age?: number &#125;\no2 &#x3D; &#123; name: &#39;hehe&#39; &#125;\n\n&#x2F;&#x2F; 当你需要一个固定值, 但是又需要其他值且不清楚数量的时候可以像以下定义\n&#x2F;**\n * @param &#123;string&#125; propsName 这个是属性名, 后面的 string 代表的是 string 格式的属性名\n * 中括号后面的 string 代表的是属性(propsName)的值的格式\n * *&#x2F;\nlet o3: &#123; name: string, [propsName: string]: string &#125;\no3 &#x3D; &#123; name: &#39;str&#39;, age: &#39;12&#39; &#125;</code></pre>\n\n<h2 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>可以用来告诉 ts 解析器变量的实际数据类型</p></blockquote>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let un: nuknown;\nun &#x3D; &#39;string&#39;\n\nlet s: string;\n\ns &#x3D; un; &#x2F;&#x2F; 此时是不成立的\n&#x2F;&#x2F; 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n&#x2F;&#x2F; 由于此时的 un 确实是 string 类型,我们可以使用类型断言来告诉解析器 un 就是 string 类型的来解决解析器报错问题\n\n&#x2F;&#x2F; 两种写法\ns &#x3D; un as string;\ns &#x3D; &lt;string&gt;un;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"TypeScript的数据类型\"><a href=\"#TypeScript的数据类型\" class=\"headerlink\" title=\"TypeScript的数据类型\"></a>TypeScript的数据类型</h1><blockquote>\n<p>变量一但定义了某个数据类型后就不允许赋值其他数据类型的数值了</p>\n</blockquote>\n<h2 id=\"基础数据类型\"><a href=\"#基础数据类型\" class=\"headerlink\" title=\"基础数据类型\"></a>基础数据类型</h2><h3 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\"number\"></a>number</h3><h3 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h3><h3 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h3><h3 id=\"void\"><a href=\"#void\" class=\"headerlink\" title=\"void\"></a>void</h3><h3 id=\"null\"><a href=\"#null\" class=\"headerlink\" title=\"null\"></a>null</h3><h3 id=\"undefinded\"><a href=\"#undefinded\" class=\"headerlink\" title=\"undefinded\"></a>undefinded</h3><h3 id=\"any-使用-TS-时不建议使用-any-类型\"><a href=\"#any-使用-TS-时不建议使用-any-类型\" class=\"headerlink\" title=\"any (使用 TS 时不建议使用 any 类型)\"></a>any (使用 TS 时不建议使用 any 类型)</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet d; &lt;&#x3D;&gt; let d: any;\n\n&#x2F;&#x2F; any 类型还可以赋值给任意类型的变量\nlet s: string;\ns &#x3D; d &#x2F;&#x2F; 这时候是成立的</code></pre>\n\n<h3 id=\"unknown\"><a href=\"#unknown\" class=\"headerlink\" title=\"unknown\"></a>unknown</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet un: unknown;\n\n&#x2F;&#x2F; any 类型还可以赋值给任意类型的变量\nlet s: string;\ns &#x3D; un &#x2F;&#x2F; 这时候是不成立的\n&#x2F;&#x2F; 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n&#x2F;&#x2F; unknown 实际上就是一个类型安全的 any\n&#x2F;&#x2F; unknown 类型的变量不能直接赋值给其他类型的变量,可以间接实现\nif (typeof un &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;\n  s &#x3D; un; &#x2F;&#x2F; 由于先进行了类型判断, 所以这时候赋值是成立的\n&#125;</code></pre>\n\n<h3 id=\"enum-枚举类型\"><a href=\"#enum-枚举类型\" class=\"headerlink\" title=\"enum(枚举类型)\"></a>enum(枚举类型)</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 使用场景\nenum Gender &#123;\n  male,\n  female\n&#125;\n\nlet p: &#123; name: string, gender: Gender &#125;\np &#x3D; &#123;\n  name: &#39;林丹&#39;,\n  gnder: Gender.male\n&#125;</code></pre>\n\n<h2 id=\"引用数据类型\"><a href=\"#引用数据类型\" class=\"headerlink\" title=\"引用数据类型\"></a>引用数据类型</h2><h3 id=\"array\"><a href=\"#array\" class=\"headerlink\" title=\"array\"></a>array</h3><h3 id=\"object\"><a href=\"#object\" class=\"headerlink\" title=\"object\"></a>object</h3><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;&#x2F; 基础的定义方式\n&#x2F;&#x2F; 由于在 js 中几乎万物皆是对象,所以不推荐这样使用\nlet o: object\no &#x3D; &#123;&#125;\no &#x3D; function\n\n&#x2F;&#x2F; 可以用字面量的方式\nlet o1: &#123; name: string, age: number &#125;\no1 &#x3D; &#123; name: &#39;hanler&#39;, age: 12 &#125;\n\n&#x2F;&#x2F; 如果要可选常数则在常数后面加个问号\nlet o2: &#123; name: string, age?: number &#125;\no2 &#x3D; &#123; name: &#39;hehe&#39; &#125;\n\n&#x2F;&#x2F; 当你需要一个固定值, 但是又需要其他值且不清楚数量的时候可以像以下定义\n&#x2F;**\n * @param &#123;string&#125; propsName 这个是属性名, 后面的 string 代表的是 string 格式的属性名\n * 中括号后面的 string 代表的是属性(propsName)的值的格式\n * *&#x2F;\nlet o3: &#123; name: string, [propsName: string]: string &#125;\no3 &#x3D; &#123; name: &#39;str&#39;, age: &#39;12&#39; &#125;</code></pre>\n\n<h2 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h2><blockquote>\n<p>可以用来告诉 ts 解析器变量的实际数据类型</p>\n</blockquote>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">let un: nuknown;\nun &#x3D; &#39;string&#39;\n\nlet s: string;\n\ns &#x3D; un; &#x2F;&#x2F; 此时是不成立的\n&#x2F;&#x2F; 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n&#x2F;&#x2F; 由于此时的 un 确实是 string 类型,我们可以使用类型断言来告诉解析器 un 就是 string 类型的来解决解析器报错问题\n\n&#x2F;&#x2F; 两种写法\ns &#x3D; un as string;\ns &#x3D; &lt;string&gt;un;</code></pre>\n"},{"title":"tsconfig.json 编译配置","date":"2022-03-05T08:40:02.000Z","cover":"https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png","_content":"\n# tsconfig.json 编译配置\n\n```json\n  {\n    // 设置保存文件的时候自动编译，但需要编译器支持。\n    \"compileOnSave\": false,\n\n    // 编译选项配置\n    \"compilerOptions\": {\n      \"incremental\": true, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n\n      \"tsBuildInfoFile\": \"./buildFile\", // 增量编译文件的存储位置\n\n      \"diagnostics\": true, // 打印诊断信息\n\n      \"target\": \"ES5\", // 目标语言的版本\n\n      \"module\": \"CommonJS\", // 生成代码的模板标准\n\n      \"outFile\": \"./app.js\", // 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置\"module\": \"AMD\",\n\n      \"lib\": [\"DOM\", \"ES2015\", \"ScriptHost\", \"ES2019.Array\"], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入\"ES2019.Array\",\n\n      \"allowJS\": true, // 允许编译器编译JS，JSX文件\n\n      \"checkJs\": true, // 允许在JS文件中报错，通常与allowJS一起使用\n\n      \"outDir\": \"./dist\", // 指定输出目录\n\n      \"rootDir\": \"./\", // 指定输出文件目录(用于输出)，用于控制输出目录结构\n\n      \"declaration\": true, // 生成声明文件，开启后会自动生成声明文件\n\n      \"declarationDir\": \"./file\", // 指定生成声明文件存放目录\n\n      \"emitDeclarationOnly\": true, // 只生成声明文件，而不会生成js文件\n\n      \"sourceMap\": true, // 生成目标文件的sourceMap文件\n\n      \"inlineSourceMap\": true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n\n      \"declarationMap\": true, // 为声明文件生成sourceMap\n\n      \"typeRoots\": [], // 声明文件目录，默认时node_modules/@types\n\n      \"types\": [], // 加载的声明文件包\n\n      \"removeComments\":true, // 删除注释\n\n      \"noEmit\": true, // 不输出文件,即编译后不会生成任何js文件\n\n      \"noEmitOnError\": true, // 发送错误时不输出任何文件\n\n      \"noEmitHelpers\": true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n\n      \"importHelpers\": true, // 通过tslib引入helper函数，文件必须是模块\n\n      \"downlevelIteration\": true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现\n\n      \"strict\": true, // 开启所有严格的类型检查\n\n      \"alwaysStrict\": true, // 在代码中注入'use strict'\n\n      \"noImplicitAny\": true, // 不允许隐式的any类型\n\n      \"strictNullChecks\": true, // 不允许把null、undefined赋值给其他类型的变量\n\n      \"strictFunctionTypes\": true, // 不允许函数参数双向协变\n\n      \"strictPropertyInitialization\": true, // 类的实例属性必须初始化\n\n      \"strictBindCallApply\": true, // 严格的bind/call/apply检查\n\n      \"noImplicitThis\": true, // 不允许this有隐式的any类型\n\n      \"noUnusedLocals\": true, // 检查只声明、未使用的局部变量(只提示不报错)\n\n      \"noUnusedParameters\": true, // 检查未使用的函数参数(只提示不报错)\n\n      \"noFallthroughCasesInSwitch\": true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)\n\n      \"noImplicitReturns\": true, //每个分支都会有返回值\n\n      \"esModuleInterop\": true, // 允许export=导出，由import from 导入\n\n      \"allowUmdGlobalAccess\": true, // 允许在模块中全局变量的方式访问umd模块\n\n      \"moduleResolution\": \"node\", // 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n\n      \"baseUrl\": \"./\", // 解析非相对模块的基地址，默认是当前目录\n\n      \"paths\": { // 路径映射，相对于baseUrl\n        // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n        \"jquery\": [\"node_modules/jquery/dist/jquery.min.js\"]\n      },\n\n      \"rootDirs\": [\"src\",\"out\"], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n\n      \"listEmittedFiles\": true, // 打印输出文件\n\n      \"listFiles\": true// 打印编译的文件(包括引用的声明文件)\n    },\n\n    // include 属性作用是指定编译需要编译的文件或目录。\n    \"include\": [\"./src/**/*\"],\n\n    // exclude 属性作用是指定编译器需要排除的文件或文件夹。默认排除 node_modules 文件夹下文件。\n    \"exclude\": [\"./utils/**/*\"],\n\n    // extends 属性作用是引入其他配置文件，继承配置。\n    \"extends\": \"./tsconfig.base.json\",\n\n    // files 属性作用是指定需要编译的单个文件列表。 默认包含当前目录和子目录下所有 TypeScript 文件。\n    \"files\": [\n      // 指定编译文件是src目录下的leo.ts文件\n      \"scr/leo.ts\"\n    ],\n\n    // references 属性作用是指定工程引用依赖。\n    // 在项目开发中，有时候我们为了方便将前端项目和后端node项目放在同一个目录下开发，两个项目依赖同一个配置文件和通用文件，但我们希望前后端项目进行灵活的分别打包，那么我们可以进行如下配置：\n    \"references\": [ // 指定依赖的工程\n      {\"path\": \"./common\"}\n    ],\n\n    // typeAcquisition 属性作用是设置自动引入库类型定义文件(.d.ts)相关。\n    // enable  : 布尔类型，是否开启自动引入库类型定义文件(.d.ts)，默认为 false；\n    // include  : 数组类型，允许自动引入的库名，如：[\"jquery\", \"lodash\"]；\n    // exculde  : 数组类型，排除的库名。\n    \"typeAcquisition\": {\n      \"enable\": false,\n      \"exclude\": [\"jquery\"],\n      \"include\": [\"jest\"]\n    }\n  }\n```\n","source":"_posts/typescript/tsconfig.json 编译配置.md","raw":"---\ntitle: tsconfig.json 编译配置\ndate: 2022/3/5 16:40:02\ncover: https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png\ncategories:\n  - TypeScript\ntags:\n  - TypeScript\n  - tsconfig\n---\n\n# tsconfig.json 编译配置\n\n```json\n  {\n    // 设置保存文件的时候自动编译，但需要编译器支持。\n    \"compileOnSave\": false,\n\n    // 编译选项配置\n    \"compilerOptions\": {\n      \"incremental\": true, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n\n      \"tsBuildInfoFile\": \"./buildFile\", // 增量编译文件的存储位置\n\n      \"diagnostics\": true, // 打印诊断信息\n\n      \"target\": \"ES5\", // 目标语言的版本\n\n      \"module\": \"CommonJS\", // 生成代码的模板标准\n\n      \"outFile\": \"./app.js\", // 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置\"module\": \"AMD\",\n\n      \"lib\": [\"DOM\", \"ES2015\", \"ScriptHost\", \"ES2019.Array\"], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入\"ES2019.Array\",\n\n      \"allowJS\": true, // 允许编译器编译JS，JSX文件\n\n      \"checkJs\": true, // 允许在JS文件中报错，通常与allowJS一起使用\n\n      \"outDir\": \"./dist\", // 指定输出目录\n\n      \"rootDir\": \"./\", // 指定输出文件目录(用于输出)，用于控制输出目录结构\n\n      \"declaration\": true, // 生成声明文件，开启后会自动生成声明文件\n\n      \"declarationDir\": \"./file\", // 指定生成声明文件存放目录\n\n      \"emitDeclarationOnly\": true, // 只生成声明文件，而不会生成js文件\n\n      \"sourceMap\": true, // 生成目标文件的sourceMap文件\n\n      \"inlineSourceMap\": true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n\n      \"declarationMap\": true, // 为声明文件生成sourceMap\n\n      \"typeRoots\": [], // 声明文件目录，默认时node_modules/@types\n\n      \"types\": [], // 加载的声明文件包\n\n      \"removeComments\":true, // 删除注释\n\n      \"noEmit\": true, // 不输出文件,即编译后不会生成任何js文件\n\n      \"noEmitOnError\": true, // 发送错误时不输出任何文件\n\n      \"noEmitHelpers\": true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n\n      \"importHelpers\": true, // 通过tslib引入helper函数，文件必须是模块\n\n      \"downlevelIteration\": true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现\n\n      \"strict\": true, // 开启所有严格的类型检查\n\n      \"alwaysStrict\": true, // 在代码中注入'use strict'\n\n      \"noImplicitAny\": true, // 不允许隐式的any类型\n\n      \"strictNullChecks\": true, // 不允许把null、undefined赋值给其他类型的变量\n\n      \"strictFunctionTypes\": true, // 不允许函数参数双向协变\n\n      \"strictPropertyInitialization\": true, // 类的实例属性必须初始化\n\n      \"strictBindCallApply\": true, // 严格的bind/call/apply检查\n\n      \"noImplicitThis\": true, // 不允许this有隐式的any类型\n\n      \"noUnusedLocals\": true, // 检查只声明、未使用的局部变量(只提示不报错)\n\n      \"noUnusedParameters\": true, // 检查未使用的函数参数(只提示不报错)\n\n      \"noFallthroughCasesInSwitch\": true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)\n\n      \"noImplicitReturns\": true, //每个分支都会有返回值\n\n      \"esModuleInterop\": true, // 允许export=导出，由import from 导入\n\n      \"allowUmdGlobalAccess\": true, // 允许在模块中全局变量的方式访问umd模块\n\n      \"moduleResolution\": \"node\", // 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n\n      \"baseUrl\": \"./\", // 解析非相对模块的基地址，默认是当前目录\n\n      \"paths\": { // 路径映射，相对于baseUrl\n        // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n        \"jquery\": [\"node_modules/jquery/dist/jquery.min.js\"]\n      },\n\n      \"rootDirs\": [\"src\",\"out\"], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n\n      \"listEmittedFiles\": true, // 打印输出文件\n\n      \"listFiles\": true// 打印编译的文件(包括引用的声明文件)\n    },\n\n    // include 属性作用是指定编译需要编译的文件或目录。\n    \"include\": [\"./src/**/*\"],\n\n    // exclude 属性作用是指定编译器需要排除的文件或文件夹。默认排除 node_modules 文件夹下文件。\n    \"exclude\": [\"./utils/**/*\"],\n\n    // extends 属性作用是引入其他配置文件，继承配置。\n    \"extends\": \"./tsconfig.base.json\",\n\n    // files 属性作用是指定需要编译的单个文件列表。 默认包含当前目录和子目录下所有 TypeScript 文件。\n    \"files\": [\n      // 指定编译文件是src目录下的leo.ts文件\n      \"scr/leo.ts\"\n    ],\n\n    // references 属性作用是指定工程引用依赖。\n    // 在项目开发中，有时候我们为了方便将前端项目和后端node项目放在同一个目录下开发，两个项目依赖同一个配置文件和通用文件，但我们希望前后端项目进行灵活的分别打包，那么我们可以进行如下配置：\n    \"references\": [ // 指定依赖的工程\n      {\"path\": \"./common\"}\n    ],\n\n    // typeAcquisition 属性作用是设置自动引入库类型定义文件(.d.ts)相关。\n    // enable  : 布尔类型，是否开启自动引入库类型定义文件(.d.ts)，默认为 false；\n    // include  : 数组类型，允许自动引入的库名，如：[\"jquery\", \"lodash\"]；\n    // exculde  : 数组类型，排除的库名。\n    \"typeAcquisition\": {\n      \"enable\": false,\n      \"exclude\": [\"jquery\"],\n      \"include\": [\"jest\"]\n    }\n  }\n```\n","slug":"typescript/tsconfig.json 编译配置","published":1,"updated":"2023-01-03T09:02:23.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcigr1tl000znkvn4fl0eku8","content":"<h1 id=\"tsconfig-json-编译配置\"><a href=\"#tsconfig-json-编译配置\" class=\"headerlink\" title=\"tsconfig.json 编译配置\"></a>tsconfig.json 编译配置</h1><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &#x2F;&#x2F; 设置保存文件的时候自动编译，但需要编译器支持。\n  &quot;compileOnSave&quot;: false,\n\n  &#x2F;&#x2F; 编译选项配置\n  &quot;compilerOptions&quot;: &#123;\n    &quot;incremental&quot;: true, &#x2F;&#x2F; TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n\n    &quot;tsBuildInfoFile&quot;: &quot;.&#x2F;buildFile&quot;, &#x2F;&#x2F; 增量编译文件的存储位置\n\n    &quot;diagnostics&quot;: true, &#x2F;&#x2F; 打印诊断信息\n\n    &quot;target&quot;: &quot;ES5&quot;, &#x2F;&#x2F; 目标语言的版本\n\n    &quot;module&quot;: &quot;CommonJS&quot;, &#x2F;&#x2F; 生成代码的模板标准\n\n    &quot;outFile&quot;: &quot;.&#x2F;app.js&quot;, &#x2F;&#x2F; 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置&quot;module&quot;: &quot;AMD&quot;,\n\n    &quot;lib&quot;: [&quot;DOM&quot;, &quot;ES2015&quot;, &quot;ScriptHost&quot;, &quot;ES2019.Array&quot;], &#x2F;&#x2F; TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入&quot;ES2019.Array&quot;,\n\n    &quot;allowJS&quot;: true, &#x2F;&#x2F; 允许编译器编译JS，JSX文件\n\n    &quot;checkJs&quot;: true, &#x2F;&#x2F; 允许在JS文件中报错，通常与allowJS一起使用\n\n    &quot;outDir&quot;: &quot;.&#x2F;dist&quot;, &#x2F;&#x2F; 指定输出目录\n\n    &quot;rootDir&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 指定输出文件目录(用于输出)，用于控制输出目录结构\n\n    &quot;declaration&quot;: true, &#x2F;&#x2F; 生成声明文件，开启后会自动生成声明文件\n\n    &quot;declarationDir&quot;: &quot;.&#x2F;file&quot;, &#x2F;&#x2F; 指定生成声明文件存放目录\n\n    &quot;emitDeclarationOnly&quot;: true, &#x2F;&#x2F; 只生成声明文件，而不会生成js文件\n\n    &quot;sourceMap&quot;: true, &#x2F;&#x2F; 生成目标文件的sourceMap文件\n\n    &quot;inlineSourceMap&quot;: true, &#x2F;&#x2F; 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n\n    &quot;declarationMap&quot;: true, &#x2F;&#x2F; 为声明文件生成sourceMap\n\n    &quot;typeRoots&quot;: [], &#x2F;&#x2F; 声明文件目录，默认时node_modules&#x2F;@types\n\n    &quot;types&quot;: [], &#x2F;&#x2F; 加载的声明文件包\n\n    &quot;removeComments&quot;:true, &#x2F;&#x2F; 删除注释\n\n    &quot;noEmit&quot;: true, &#x2F;&#x2F; 不输出文件,即编译后不会生成任何js文件\n\n    &quot;noEmitOnError&quot;: true, &#x2F;&#x2F; 发送错误时不输出任何文件\n\n    &quot;noEmitHelpers&quot;: true, &#x2F;&#x2F; 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n\n    &quot;importHelpers&quot;: true, &#x2F;&#x2F; 通过tslib引入helper函数，文件必须是模块\n\n    &quot;downlevelIteration&quot;: true, &#x2F;&#x2F; 降级遍历器实现，如果目标源是es3&#x2F;5，那么遍历器会有降级的实现\n\n    &quot;strict&quot;: true, &#x2F;&#x2F; 开启所有严格的类型检查\n\n    &quot;alwaysStrict&quot;: true, &#x2F;&#x2F; 在代码中注入&#39;use strict&#39;\n\n    &quot;noImplicitAny&quot;: true, &#x2F;&#x2F; 不允许隐式的any类型\n\n    &quot;strictNullChecks&quot;: true, &#x2F;&#x2F; 不允许把null、undefined赋值给其他类型的变量\n\n    &quot;strictFunctionTypes&quot;: true, &#x2F;&#x2F; 不允许函数参数双向协变\n\n    &quot;strictPropertyInitialization&quot;: true, &#x2F;&#x2F; 类的实例属性必须初始化\n\n    &quot;strictBindCallApply&quot;: true, &#x2F;&#x2F; 严格的bind&#x2F;call&#x2F;apply检查\n\n    &quot;noImplicitThis&quot;: true, &#x2F;&#x2F; 不允许this有隐式的any类型\n\n    &quot;noUnusedLocals&quot;: true, &#x2F;&#x2F; 检查只声明、未使用的局部变量(只提示不报错)\n\n    &quot;noUnusedParameters&quot;: true, &#x2F;&#x2F; 检查未使用的函数参数(只提示不报错)\n\n    &quot;noFallthroughCasesInSwitch&quot;: true, &#x2F;&#x2F; 防止switch语句贯穿(即如果没有break语句后面不会执行)\n\n    &quot;noImplicitReturns&quot;: true, &#x2F;&#x2F;每个分支都会有返回值\n\n    &quot;esModuleInterop&quot;: true, &#x2F;&#x2F; 允许export&#x3D;导出，由import from 导入\n\n    &quot;allowUmdGlobalAccess&quot;: true, &#x2F;&#x2F; 允许在模块中全局变量的方式访问umd模块\n\n    &quot;moduleResolution&quot;: &quot;node&quot;, &#x2F;&#x2F; 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n\n    &quot;baseUrl&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 解析非相对模块的基地址，默认是当前目录\n\n    &quot;paths&quot;: &#123; &#x2F;&#x2F; 路径映射，相对于baseUrl\n      &#x2F;&#x2F; 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n      &quot;jquery&quot;: [&quot;node_modules&#x2F;jquery&#x2F;dist&#x2F;jquery.min.js&quot;]\n    &#125;,\n\n    &quot;rootDirs&quot;: [&quot;src&quot;,&quot;out&quot;], &#x2F;&#x2F; 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n\n    &quot;listEmittedFiles&quot;: true, &#x2F;&#x2F; 打印输出文件\n\n    &quot;listFiles&quot;: true&#x2F;&#x2F; 打印编译的文件(包括引用的声明文件)\n  &#125;,\n\n  &#x2F;&#x2F; include 属性作用是指定编译需要编译的文件或目录。\n  &quot;include&quot;: [&quot;.&#x2F;src&#x2F;**&#x2F;*&quot;],\n\n  &#x2F;&#x2F; exclude 属性作用是指定编译器需要排除的文件或文件夹。默认排除 node_modules 文件夹下文件。\n  &quot;exclude&quot;: [&quot;.&#x2F;utils&#x2F;**&#x2F;*&quot;],\n\n  &#x2F;&#x2F; extends 属性作用是引入其他配置文件，继承配置。\n  &quot;extends&quot;: &quot;.&#x2F;tsconfig.base.json&quot;,\n\n  &#x2F;&#x2F; files 属性作用是指定需要编译的单个文件列表。 默认包含当前目录和子目录下所有 TypeScript 文件。\n  &quot;files&quot;: [\n    &#x2F;&#x2F; 指定编译文件是src目录下的leo.ts文件\n    &quot;scr&#x2F;leo.ts&quot;\n  ],\n\n  &#x2F;&#x2F; references 属性作用是指定工程引用依赖。\n  &#x2F;&#x2F; 在项目开发中，有时候我们为了方便将前端项目和后端node项目放在同一个目录下开发，两个项目依赖同一个配置文件和通用文件，但我们希望前后端项目进行灵活的分别打包，那么我们可以进行如下配置：\n  &quot;references&quot;: [ &#x2F;&#x2F; 指定依赖的工程\n    &#123;&quot;path&quot;: &quot;.&#x2F;common&quot;&#125;\n  ],\n\n  &#x2F;&#x2F; typeAcquisition 属性作用是设置自动引入库类型定义文件(.d.ts)相关。\n  &#x2F;&#x2F; enable  : 布尔类型，是否开启自动引入库类型定义文件(.d.ts)，默认为 false；\n  &#x2F;&#x2F; include  : 数组类型，允许自动引入的库名，如：[&quot;jquery&quot;, &quot;lodash&quot;]；\n  &#x2F;&#x2F; exculde  : 数组类型，排除的库名。\n  &quot;typeAcquisition&quot;: &#123;\n    &quot;enable&quot;: false,\n    &quot;exclude&quot;: [&quot;jquery&quot;],\n    &quot;include&quot;: [&quot;jest&quot;]\n  &#125;\n&#125;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"tsconfig-json-编译配置\"><a href=\"#tsconfig-json-编译配置\" class=\"headerlink\" title=\"tsconfig.json 编译配置\"></a>tsconfig.json 编译配置</h1><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &#x2F;&#x2F; 设置保存文件的时候自动编译，但需要编译器支持。\n  &quot;compileOnSave&quot;: false,\n\n  &#x2F;&#x2F; 编译选项配置\n  &quot;compilerOptions&quot;: &#123;\n    &quot;incremental&quot;: true, &#x2F;&#x2F; TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n\n    &quot;tsBuildInfoFile&quot;: &quot;.&#x2F;buildFile&quot;, &#x2F;&#x2F; 增量编译文件的存储位置\n\n    &quot;diagnostics&quot;: true, &#x2F;&#x2F; 打印诊断信息\n\n    &quot;target&quot;: &quot;ES5&quot;, &#x2F;&#x2F; 目标语言的版本\n\n    &quot;module&quot;: &quot;CommonJS&quot;, &#x2F;&#x2F; 生成代码的模板标准\n\n    &quot;outFile&quot;: &quot;.&#x2F;app.js&quot;, &#x2F;&#x2F; 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置&quot;module&quot;: &quot;AMD&quot;,\n\n    &quot;lib&quot;: [&quot;DOM&quot;, &quot;ES2015&quot;, &quot;ScriptHost&quot;, &quot;ES2019.Array&quot;], &#x2F;&#x2F; TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入&quot;ES2019.Array&quot;,\n\n    &quot;allowJS&quot;: true, &#x2F;&#x2F; 允许编译器编译JS，JSX文件\n\n    &quot;checkJs&quot;: true, &#x2F;&#x2F; 允许在JS文件中报错，通常与allowJS一起使用\n\n    &quot;outDir&quot;: &quot;.&#x2F;dist&quot;, &#x2F;&#x2F; 指定输出目录\n\n    &quot;rootDir&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 指定输出文件目录(用于输出)，用于控制输出目录结构\n\n    &quot;declaration&quot;: true, &#x2F;&#x2F; 生成声明文件，开启后会自动生成声明文件\n\n    &quot;declarationDir&quot;: &quot;.&#x2F;file&quot;, &#x2F;&#x2F; 指定生成声明文件存放目录\n\n    &quot;emitDeclarationOnly&quot;: true, &#x2F;&#x2F; 只生成声明文件，而不会生成js文件\n\n    &quot;sourceMap&quot;: true, &#x2F;&#x2F; 生成目标文件的sourceMap文件\n\n    &quot;inlineSourceMap&quot;: true, &#x2F;&#x2F; 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n\n    &quot;declarationMap&quot;: true, &#x2F;&#x2F; 为声明文件生成sourceMap\n\n    &quot;typeRoots&quot;: [], &#x2F;&#x2F; 声明文件目录，默认时node_modules&#x2F;@types\n\n    &quot;types&quot;: [], &#x2F;&#x2F; 加载的声明文件包\n\n    &quot;removeComments&quot;:true, &#x2F;&#x2F; 删除注释\n\n    &quot;noEmit&quot;: true, &#x2F;&#x2F; 不输出文件,即编译后不会生成任何js文件\n\n    &quot;noEmitOnError&quot;: true, &#x2F;&#x2F; 发送错误时不输出任何文件\n\n    &quot;noEmitHelpers&quot;: true, &#x2F;&#x2F; 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n\n    &quot;importHelpers&quot;: true, &#x2F;&#x2F; 通过tslib引入helper函数，文件必须是模块\n\n    &quot;downlevelIteration&quot;: true, &#x2F;&#x2F; 降级遍历器实现，如果目标源是es3&#x2F;5，那么遍历器会有降级的实现\n\n    &quot;strict&quot;: true, &#x2F;&#x2F; 开启所有严格的类型检查\n\n    &quot;alwaysStrict&quot;: true, &#x2F;&#x2F; 在代码中注入&#39;use strict&#39;\n\n    &quot;noImplicitAny&quot;: true, &#x2F;&#x2F; 不允许隐式的any类型\n\n    &quot;strictNullChecks&quot;: true, &#x2F;&#x2F; 不允许把null、undefined赋值给其他类型的变量\n\n    &quot;strictFunctionTypes&quot;: true, &#x2F;&#x2F; 不允许函数参数双向协变\n\n    &quot;strictPropertyInitialization&quot;: true, &#x2F;&#x2F; 类的实例属性必须初始化\n\n    &quot;strictBindCallApply&quot;: true, &#x2F;&#x2F; 严格的bind&#x2F;call&#x2F;apply检查\n\n    &quot;noImplicitThis&quot;: true, &#x2F;&#x2F; 不允许this有隐式的any类型\n\n    &quot;noUnusedLocals&quot;: true, &#x2F;&#x2F; 检查只声明、未使用的局部变量(只提示不报错)\n\n    &quot;noUnusedParameters&quot;: true, &#x2F;&#x2F; 检查未使用的函数参数(只提示不报错)\n\n    &quot;noFallthroughCasesInSwitch&quot;: true, &#x2F;&#x2F; 防止switch语句贯穿(即如果没有break语句后面不会执行)\n\n    &quot;noImplicitReturns&quot;: true, &#x2F;&#x2F;每个分支都会有返回值\n\n    &quot;esModuleInterop&quot;: true, &#x2F;&#x2F; 允许export&#x3D;导出，由import from 导入\n\n    &quot;allowUmdGlobalAccess&quot;: true, &#x2F;&#x2F; 允许在模块中全局变量的方式访问umd模块\n\n    &quot;moduleResolution&quot;: &quot;node&quot;, &#x2F;&#x2F; 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n\n    &quot;baseUrl&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 解析非相对模块的基地址，默认是当前目录\n\n    &quot;paths&quot;: &#123; &#x2F;&#x2F; 路径映射，相对于baseUrl\n      &#x2F;&#x2F; 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n      &quot;jquery&quot;: [&quot;node_modules&#x2F;jquery&#x2F;dist&#x2F;jquery.min.js&quot;]\n    &#125;,\n\n    &quot;rootDirs&quot;: [&quot;src&quot;,&quot;out&quot;], &#x2F;&#x2F; 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n\n    &quot;listEmittedFiles&quot;: true, &#x2F;&#x2F; 打印输出文件\n\n    &quot;listFiles&quot;: true&#x2F;&#x2F; 打印编译的文件(包括引用的声明文件)\n  &#125;,\n\n  &#x2F;&#x2F; include 属性作用是指定编译需要编译的文件或目录。\n  &quot;include&quot;: [&quot;.&#x2F;src&#x2F;**&#x2F;*&quot;],\n\n  &#x2F;&#x2F; exclude 属性作用是指定编译器需要排除的文件或文件夹。默认排除 node_modules 文件夹下文件。\n  &quot;exclude&quot;: [&quot;.&#x2F;utils&#x2F;**&#x2F;*&quot;],\n\n  &#x2F;&#x2F; extends 属性作用是引入其他配置文件，继承配置。\n  &quot;extends&quot;: &quot;.&#x2F;tsconfig.base.json&quot;,\n\n  &#x2F;&#x2F; files 属性作用是指定需要编译的单个文件列表。 默认包含当前目录和子目录下所有 TypeScript 文件。\n  &quot;files&quot;: [\n    &#x2F;&#x2F; 指定编译文件是src目录下的leo.ts文件\n    &quot;scr&#x2F;leo.ts&quot;\n  ],\n\n  &#x2F;&#x2F; references 属性作用是指定工程引用依赖。\n  &#x2F;&#x2F; 在项目开发中，有时候我们为了方便将前端项目和后端node项目放在同一个目录下开发，两个项目依赖同一个配置文件和通用文件，但我们希望前后端项目进行灵活的分别打包，那么我们可以进行如下配置：\n  &quot;references&quot;: [ &#x2F;&#x2F; 指定依赖的工程\n    &#123;&quot;path&quot;: &quot;.&#x2F;common&quot;&#125;\n  ],\n\n  &#x2F;&#x2F; typeAcquisition 属性作用是设置自动引入库类型定义文件(.d.ts)相关。\n  &#x2F;&#x2F; enable  : 布尔类型，是否开启自动引入库类型定义文件(.d.ts)，默认为 false；\n  &#x2F;&#x2F; include  : 数组类型，允许自动引入的库名，如：[&quot;jquery&quot;, &quot;lodash&quot;]；\n  &#x2F;&#x2F; exculde  : 数组类型，排除的库名。\n  &quot;typeAcquisition&quot;: &#123;\n    &quot;enable&quot;: false,\n    &quot;exclude&quot;: [&quot;jquery&quot;],\n    &quot;include&quot;: [&quot;jest&quot;]\n  &#125;\n&#125;</code></pre>\n"},{"title":"webpack 创建简单的 ts 开发环境","date":"2022-03-05T08:55:46.000Z","cover":"https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png","_content":"\n# webpack 创建简单的 ts 开发环境\n\n## 前置要求\n\n需要的的 `npm` 插件\n\n>\n> 1. webpack ( webpack 本体 )\n> 2. webpack-cli ( webpack 的命令行工具 )\n> 3. typescript ( typescript 核心代码 )\n> 4. ts-loader (typescript 的 webpck 编译模块)\n> 5. clean-webpack-plugin ( 打包前清除之前打包的文件夹 )\n>\n\n\n\n## ts 开发环境目录\n![Snipaste_2022-03-05_15-32-16.png](https://s2.loli.net/2023/01/03/XS1lVDEMyifWocg.png)\n\n## tsconfig.json 配置\n\n```json\n  {\n    \"compilerOptions\": {\n\n      \"module\": \"ES6\",             // 使用的模块规则\n\n      \"target\": \"ES6\",             // 编译生成 js 的版本\n\n      \"noImplicitAny\": true,       // 不允许隐式的 any 类型\n\n      \"removeComments\": true,      // 删除注释\n\n      \"preserveConstEnums\": true,  // 保留 const 和 enum 声明\n\n      \"strict\": true               // 使用严格模式\n    },\n\n    // 需要编译的 ts 文件\n    \"include\": [\n      \"./src/**/*\"\n    ]\n  }\n```\n\n## webpack.config.js 配置\n\n### 基本配置\n\n```javascript\n  const path = require(\"path\")\n  const { CleanWebpackPlugin } = require(\"clean-webpack-plugin\")\n\n  module.exports = {\n    // 入口文件\n    entry: \"./src/index.ts\",\n\n    // 打包后的出口文件\n    output: {\n      // 文件路径\n      path: path.resolve(__dirname, \"dist\"),\n\n      // 文件名\n      filename: \"bundle.js\",\n    },\n    // 使用的编译模块\n    module: {\n\n      // 指定要加载的规则\n      rules: [\n        {\n          // test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n          test: /\\.ts$/,\n\n          // 要使用的 loader\n          use: ['ts-loader'],\n\n          // 排除要编译的文件夹\n          exclude: /node_modules/\n        }\n      ]\n    },\n\n    // 用来设置需要引用的模块文件 (这里包括了 ts 和 js) 不设置的话, 引用其他 ts/js 文件会编译报错\n    resolve: {\n      extensions: ['.ts', '.js']\n    },\n\n    // 配置 webpack 插件\n    plugins: [\n      new CleanWebpackPlugin()\n    ],\n  }\n```\n\n### 使用 html 文件配置\n\n> 前端项目中我们编译完的 js 文件最终会用到 html 文件中. 我们手动创建并引入 js 的话也不是不行, 但是很麻烦, 如果以后要增加一些其他的 js 或者 css 都得重新去手动引入. 这时候就可以用 `webpack` 给我们提供的一个自动引入经过 loader 编译后的文件 html 的插件 `html-webpack-plugin`\n>\n> `**_npm install -D html-webpack-plugin_**`\n\n\n在最外层的 `plugins` 中配置\n\n[更多 html-webpack-plugin 的配置信息看这里](https://github.com/jantimon/html-webpack-plugin#configuration)\n\n```javascript\n  // 引入插件\n  const HtmlWebpackPlugin = require(\"html-webpack-plugin\")\n\n  module.exprots = {\n    // 配置 webpack 插件\n    plugins: [\n      new HtmlWebpackPlugin({\n        // 配置 html 模板文件的目录\n        template: path.resolve(__dirname, 'public/index.html')\n      })\n    ],\n  }\n```\n\n### 使用 webpack-server 实时编译\n\n> 弄好 `html` 自动引入后我们需要打开网页去调试我们的 ts 程序, 按照普通方式来修改一次又要打包一遍, 又要重新刷新一遍网页的话就很麻烦, 这时我们可以用 `webpack-server` 来进行开发服务器部署\n>\n> `**_npm install -D webpack-server_**`\n>\n> 安装完后直接在 `package.json` 中进行配置运行命令运行就行了\n\n\n```json\n  {\n    \"scripts\": {\n      \"dev\": \"webpack server --mode development\"\n    }\n  }\n```\n\n### 配置 babel 来进行浏览器兼容\n\n在日常的开发中我们会经常遇到要兼容低版本浏览器的需要, 这时候为了增加开发效率我们可以用 `**_babel_**` 来将一些 `**_ES6_**` 中的高级属性来转换为低版本浏览器中的兼容属性\n\n需要的开发依赖\n\n>\n> 1. @babel/core ( babel 的核心代码 )\n> 2. @babel/preset-env ( babel 的兼容库 )\n> 3. core-js ( 高级属性的兼容性替代方案 )\n>\n\n> `**_npm install -D @babel/core @babel/preset-env core-js_**`\n\n\nwebpack 配置\n\n```javascript\n\n  module.exports = {\n\n    // 使用的编译模块\n    module: {\n      // 指定要加载的规则\n      rules: [\n        {\n          // test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n          test: /\\.ts$/,\n\n          // 要使用的 loader\n          use: [\n\n            // 配置 babel\n            {\n              // 指定要用的加载器\n              loader: 'babel-loader',\n\n              options: {\n                // 设置预定义的环境\n                presets: [\n                  [\n                    \"@babel-preset-env\",\n\n                    {\n                      // 需要兼容的目标浏览器, 根据项目需求填写\n                      targets: {\n                        \"chrome\": 95\n                      },\n\n                      // 指定的 core 版本\n                      \"corejs\": '3',\n\n                      // 使用 corejs 的方式 \"usage\" 按需加载\n                      \"useBuiltIns\": \"usage\"\n                    }\n                  ]\n                ]\n              }\n            },\n\n            // 由于 webpack 中 rules 是从数组从后往前执行的, 所以 ts-loader 放在后面, 让 ts 先编译为 js 在通过 babel 进行兼容性转换\n            'ts-loader'\n          ],\n        }\n      ]\n    }\n  }\n```\n","source":"_posts/typescript/webpack 搭建 ts 开发环境.md","raw":"---\ntitle: webpack 创建简单的 ts 开发环境\ndate: 2022/3/5 16:55:46\ncover: https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png\ncategories:\n  - TypeScript\ntags:\n  - TypeScript\n  - 环境搭建\n  - webpack\n---\n\n# webpack 创建简单的 ts 开发环境\n\n## 前置要求\n\n需要的的 `npm` 插件\n\n>\n> 1. webpack ( webpack 本体 )\n> 2. webpack-cli ( webpack 的命令行工具 )\n> 3. typescript ( typescript 核心代码 )\n> 4. ts-loader (typescript 的 webpck 编译模块)\n> 5. clean-webpack-plugin ( 打包前清除之前打包的文件夹 )\n>\n\n\n\n## ts 开发环境目录\n![Snipaste_2022-03-05_15-32-16.png](https://s2.loli.net/2023/01/03/XS1lVDEMyifWocg.png)\n\n## tsconfig.json 配置\n\n```json\n  {\n    \"compilerOptions\": {\n\n      \"module\": \"ES6\",             // 使用的模块规则\n\n      \"target\": \"ES6\",             // 编译生成 js 的版本\n\n      \"noImplicitAny\": true,       // 不允许隐式的 any 类型\n\n      \"removeComments\": true,      // 删除注释\n\n      \"preserveConstEnums\": true,  // 保留 const 和 enum 声明\n\n      \"strict\": true               // 使用严格模式\n    },\n\n    // 需要编译的 ts 文件\n    \"include\": [\n      \"./src/**/*\"\n    ]\n  }\n```\n\n## webpack.config.js 配置\n\n### 基本配置\n\n```javascript\n  const path = require(\"path\")\n  const { CleanWebpackPlugin } = require(\"clean-webpack-plugin\")\n\n  module.exports = {\n    // 入口文件\n    entry: \"./src/index.ts\",\n\n    // 打包后的出口文件\n    output: {\n      // 文件路径\n      path: path.resolve(__dirname, \"dist\"),\n\n      // 文件名\n      filename: \"bundle.js\",\n    },\n    // 使用的编译模块\n    module: {\n\n      // 指定要加载的规则\n      rules: [\n        {\n          // test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n          test: /\\.ts$/,\n\n          // 要使用的 loader\n          use: ['ts-loader'],\n\n          // 排除要编译的文件夹\n          exclude: /node_modules/\n        }\n      ]\n    },\n\n    // 用来设置需要引用的模块文件 (这里包括了 ts 和 js) 不设置的话, 引用其他 ts/js 文件会编译报错\n    resolve: {\n      extensions: ['.ts', '.js']\n    },\n\n    // 配置 webpack 插件\n    plugins: [\n      new CleanWebpackPlugin()\n    ],\n  }\n```\n\n### 使用 html 文件配置\n\n> 前端项目中我们编译完的 js 文件最终会用到 html 文件中. 我们手动创建并引入 js 的话也不是不行, 但是很麻烦, 如果以后要增加一些其他的 js 或者 css 都得重新去手动引入. 这时候就可以用 `webpack` 给我们提供的一个自动引入经过 loader 编译后的文件 html 的插件 `html-webpack-plugin`\n>\n> `**_npm install -D html-webpack-plugin_**`\n\n\n在最外层的 `plugins` 中配置\n\n[更多 html-webpack-plugin 的配置信息看这里](https://github.com/jantimon/html-webpack-plugin#configuration)\n\n```javascript\n  // 引入插件\n  const HtmlWebpackPlugin = require(\"html-webpack-plugin\")\n\n  module.exprots = {\n    // 配置 webpack 插件\n    plugins: [\n      new HtmlWebpackPlugin({\n        // 配置 html 模板文件的目录\n        template: path.resolve(__dirname, 'public/index.html')\n      })\n    ],\n  }\n```\n\n### 使用 webpack-server 实时编译\n\n> 弄好 `html` 自动引入后我们需要打开网页去调试我们的 ts 程序, 按照普通方式来修改一次又要打包一遍, 又要重新刷新一遍网页的话就很麻烦, 这时我们可以用 `webpack-server` 来进行开发服务器部署\n>\n> `**_npm install -D webpack-server_**`\n>\n> 安装完后直接在 `package.json` 中进行配置运行命令运行就行了\n\n\n```json\n  {\n    \"scripts\": {\n      \"dev\": \"webpack server --mode development\"\n    }\n  }\n```\n\n### 配置 babel 来进行浏览器兼容\n\n在日常的开发中我们会经常遇到要兼容低版本浏览器的需要, 这时候为了增加开发效率我们可以用 `**_babel_**` 来将一些 `**_ES6_**` 中的高级属性来转换为低版本浏览器中的兼容属性\n\n需要的开发依赖\n\n>\n> 1. @babel/core ( babel 的核心代码 )\n> 2. @babel/preset-env ( babel 的兼容库 )\n> 3. core-js ( 高级属性的兼容性替代方案 )\n>\n\n> `**_npm install -D @babel/core @babel/preset-env core-js_**`\n\n\nwebpack 配置\n\n```javascript\n\n  module.exports = {\n\n    // 使用的编译模块\n    module: {\n      // 指定要加载的规则\n      rules: [\n        {\n          // test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n          test: /\\.ts$/,\n\n          // 要使用的 loader\n          use: [\n\n            // 配置 babel\n            {\n              // 指定要用的加载器\n              loader: 'babel-loader',\n\n              options: {\n                // 设置预定义的环境\n                presets: [\n                  [\n                    \"@babel-preset-env\",\n\n                    {\n                      // 需要兼容的目标浏览器, 根据项目需求填写\n                      targets: {\n                        \"chrome\": 95\n                      },\n\n                      // 指定的 core 版本\n                      \"corejs\": '3',\n\n                      // 使用 corejs 的方式 \"usage\" 按需加载\n                      \"useBuiltIns\": \"usage\"\n                    }\n                  ]\n                ]\n              }\n            },\n\n            // 由于 webpack 中 rules 是从数组从后往前执行的, 所以 ts-loader 放在后面, 让 ts 先编译为 js 在通过 babel 进行兼容性转换\n            'ts-loader'\n          ],\n        }\n      ]\n    }\n  }\n```\n","slug":"typescript/webpack 搭建 ts 开发环境","published":1,"updated":"2023-01-03T09:02:23.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcigr1tm0010nkvnav2385jg","content":"<h1 id=\"webpack-创建简单的-ts-开发环境\"><a href=\"#webpack-创建简单的-ts-开发环境\" class=\"headerlink\" title=\"webpack 创建简单的 ts 开发环境\"></a>webpack 创建简单的 ts 开发环境</h1><h2 id=\"前置要求\"><a href=\"#前置要求\" class=\"headerlink\" title=\"前置要求\"></a>前置要求</h2><p>需要的的 <code>npm</code> 插件</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>webpack ( webpack 本体 )</li>\n<li>webpack-cli ( webpack 的命令行工具 )</li>\n<li>typescript ( typescript 核心代码 )</li>\n<li>ts-loader (typescript 的 webpck 编译模块)</li>\n<li>clean-webpack-plugin ( 打包前清除之前打包的文件夹 )</li>\n</ol></blockquote>\n<h2 id=\"ts-开发环境目录\"><a href=\"#ts-开发环境目录\" class=\"headerlink\" title=\"ts 开发环境目录\"></a>ts 开发环境目录</h2><p><img src=\"https://s2.loli.net/2023/01/03/XS1lVDEMyifWocg.png\" alt=\"Snipaste_2022-03-05_15-32-16.png\"></p>\n<h2 id=\"tsconfig-json-配置\"><a href=\"#tsconfig-json-配置\" class=\"headerlink\" title=\"tsconfig.json 配置\"></a>tsconfig.json 配置</h2><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;compilerOptions&quot;: &#123;\n\n    &quot;module&quot;: &quot;ES6&quot;,             &#x2F;&#x2F; 使用的模块规则\n\n    &quot;target&quot;: &quot;ES6&quot;,             &#x2F;&#x2F; 编译生成 js 的版本\n\n    &quot;noImplicitAny&quot;: true,       &#x2F;&#x2F; 不允许隐式的 any 类型\n\n    &quot;removeComments&quot;: true,      &#x2F;&#x2F; 删除注释\n\n    &quot;preserveConstEnums&quot;: true,  &#x2F;&#x2F; 保留 const 和 enum 声明\n\n    &quot;strict&quot;: true               &#x2F;&#x2F; 使用严格模式\n  &#125;,\n\n  &#x2F;&#x2F; 需要编译的 ts 文件\n  &quot;include&quot;: [\n    &quot;.&#x2F;src&#x2F;**&#x2F;*&quot;\n  ]\n&#125;</code></pre>\n\n<h2 id=\"webpack-config-js-配置\"><a href=\"#webpack-config-js-配置\" class=\"headerlink\" title=\"webpack.config.js 配置\"></a>webpack.config.js 配置</h2><h3 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const path &#x3D; require(&quot;path&quot;)\nconst &#123; CleanWebpackPlugin &#125; &#x3D; require(&quot;clean-webpack-plugin&quot;)\n\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; 入口文件\n  entry: &quot;.&#x2F;src&#x2F;index.ts&quot;,\n\n  &#x2F;&#x2F; 打包后的出口文件\n  output: &#123;\n    &#x2F;&#x2F; 文件路径\n    path: path.resolve(__dirname, &quot;dist&quot;),\n\n    &#x2F;&#x2F; 文件名\n    filename: &quot;bundle.js&quot;,\n  &#125;,\n  &#x2F;&#x2F; 使用的编译模块\n  module: &#123;\n\n    &#x2F;&#x2F; 指定要加载的规则\n    rules: [\n      &#123;\n        &#x2F;&#x2F; test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n        test: &#x2F;\\.ts$&#x2F;,\n\n        &#x2F;&#x2F; 要使用的 loader\n        use: [&#39;ts-loader&#39;],\n\n        &#x2F;&#x2F; 排除要编译的文件夹\n        exclude: &#x2F;node_modules&#x2F;\n      &#125;\n    ]\n  &#125;,\n\n  &#x2F;&#x2F; 用来设置需要引用的模块文件 (这里包括了 ts 和 js) 不设置的话, 引用其他 ts&#x2F;js 文件会编译报错\n  resolve: &#123;\n    extensions: [&#39;.ts&#39;, &#39;.js&#39;]\n  &#125;,\n\n  &#x2F;&#x2F; 配置 webpack 插件\n  plugins: [\n    new CleanWebpackPlugin()\n  ],\n&#125;</code></pre>\n\n<h3 id=\"使用-html-文件配置\"><a href=\"#使用-html-文件配置\" class=\"headerlink\" title=\"使用 html 文件配置\"></a>使用 html 文件配置</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>前端项目中我们编译完的 js 文件最终会用到 html 文件中. 我们手动创建并引入 js 的话也不是不行, 但是很麻烦, 如果以后要增加一些其他的 js 或者 css 都得重新去手动引入. 这时候就可以用 <code>webpack</code> 给我们提供的一个自动引入经过 loader 编译后的文件 html 的插件 <code>html-webpack-plugin</code></p>\n<p><code>**_npm install -D html-webpack-plugin_**</code></p></blockquote>\n<p>在最外层的 <code>plugins</code> 中配置</p>\n<p><a href=\"https://github.com/jantimon/html-webpack-plugin#configuration\">更多 html-webpack-plugin 的配置信息看这里</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 引入插件\nconst HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;)\n\nmodule.exprots &#x3D; &#123;\n  &#x2F;&#x2F; 配置 webpack 插件\n  plugins: [\n    new HtmlWebpackPlugin(&#123;\n      &#x2F;&#x2F; 配置 html 模板文件的目录\n      template: path.resolve(__dirname, &#39;public&#x2F;index.html&#39;)\n    &#125;)\n  ],\n&#125;</code></pre>\n\n<h3 id=\"使用-webpack-server-实时编译\"><a href=\"#使用-webpack-server-实时编译\" class=\"headerlink\" title=\"使用 webpack-server 实时编译\"></a>使用 webpack-server 实时编译</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>弄好 <code>html</code> 自动引入后我们需要打开网页去调试我们的 ts 程序, 按照普通方式来修改一次又要打包一遍, 又要重新刷新一遍网页的话就很麻烦, 这时我们可以用 <code>webpack-server</code> 来进行开发服务器部署</p>\n<p><code>**_npm install -D webpack-server_**</code></p>\n<p>安装完后直接在 <code>package.json</code> 中进行配置运行命令运行就行了</p></blockquote>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;webpack server --mode development&quot;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"配置-babel-来进行浏览器兼容\"><a href=\"#配置-babel-来进行浏览器兼容\" class=\"headerlink\" title=\"配置 babel 来进行浏览器兼容\"></a>配置 babel 来进行浏览器兼容</h3><p>在日常的开发中我们会经常遇到要兼容低版本浏览器的需要, 这时候为了增加开发效率我们可以用 <code>**_babel_**</code> 来将一些 <code>**_ES6_**</code> 中的高级属性来转换为低版本浏览器中的兼容属性</p>\n<p>需要的开发依赖</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>@babel/core ( babel 的核心代码 )</li>\n<li>@babel/preset-env ( babel 的兼容库 )</li>\n<li>core-js ( 高级属性的兼容性替代方案 )</li>\n</ol></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>**_npm install -D @babel/core @babel/preset-env core-js_**</code></p></blockquote>\n<p>webpack 配置</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\nmodule.exports &#x3D; &#123;\n\n  &#x2F;&#x2F; 使用的编译模块\n  module: &#123;\n    &#x2F;&#x2F; 指定要加载的规则\n    rules: [\n      &#123;\n        &#x2F;&#x2F; test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n        test: &#x2F;\\.ts$&#x2F;,\n\n        &#x2F;&#x2F; 要使用的 loader\n        use: [\n\n          &#x2F;&#x2F; 配置 babel\n          &#123;\n            &#x2F;&#x2F; 指定要用的加载器\n            loader: &#39;babel-loader&#39;,\n\n            options: &#123;\n              &#x2F;&#x2F; 设置预定义的环境\n              presets: [\n                [\n                  &quot;@babel-preset-env&quot;,\n\n                  &#123;\n                    &#x2F;&#x2F; 需要兼容的目标浏览器, 根据项目需求填写\n                    targets: &#123;\n                      &quot;chrome&quot;: 95\n                    &#125;,\n\n                    &#x2F;&#x2F; 指定的 core 版本\n                    &quot;corejs&quot;: &#39;3&#39;,\n\n                    &#x2F;&#x2F; 使用 corejs 的方式 &quot;usage&quot; 按需加载\n                    &quot;useBuiltIns&quot;: &quot;usage&quot;\n                  &#125;\n                ]\n              ]\n            &#125;\n          &#125;,\n\n          &#x2F;&#x2F; 由于 webpack 中 rules 是从数组从后往前执行的, 所以 ts-loader 放在后面, 让 ts 先编译为 js 在通过 babel 进行兼容性转换\n          &#39;ts-loader&#39;\n        ],\n      &#125;\n    ]\n  &#125;\n&#125;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"webpack-创建简单的-ts-开发环境\"><a href=\"#webpack-创建简单的-ts-开发环境\" class=\"headerlink\" title=\"webpack 创建简单的 ts 开发环境\"></a>webpack 创建简单的 ts 开发环境</h1><h2 id=\"前置要求\"><a href=\"#前置要求\" class=\"headerlink\" title=\"前置要求\"></a>前置要求</h2><p>需要的的 <code>npm</code> 插件</p>\n<blockquote>\n<ol>\n<li>webpack ( webpack 本体 )</li>\n<li>webpack-cli ( webpack 的命令行工具 )</li>\n<li>typescript ( typescript 核心代码 )</li>\n<li>ts-loader (typescript 的 webpck 编译模块)</li>\n<li>clean-webpack-plugin ( 打包前清除之前打包的文件夹 )</li>\n</ol>\n</blockquote>\n<h2 id=\"ts-开发环境目录\"><a href=\"#ts-开发环境目录\" class=\"headerlink\" title=\"ts 开发环境目录\"></a>ts 开发环境目录</h2><p><img src=\"https://s2.loli.net/2023/01/03/XS1lVDEMyifWocg.png\" alt=\"Snipaste_2022-03-05_15-32-16.png\"></p>\n<h2 id=\"tsconfig-json-配置\"><a href=\"#tsconfig-json-配置\" class=\"headerlink\" title=\"tsconfig.json 配置\"></a>tsconfig.json 配置</h2><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;compilerOptions&quot;: &#123;\n\n    &quot;module&quot;: &quot;ES6&quot;,             &#x2F;&#x2F; 使用的模块规则\n\n    &quot;target&quot;: &quot;ES6&quot;,             &#x2F;&#x2F; 编译生成 js 的版本\n\n    &quot;noImplicitAny&quot;: true,       &#x2F;&#x2F; 不允许隐式的 any 类型\n\n    &quot;removeComments&quot;: true,      &#x2F;&#x2F; 删除注释\n\n    &quot;preserveConstEnums&quot;: true,  &#x2F;&#x2F; 保留 const 和 enum 声明\n\n    &quot;strict&quot;: true               &#x2F;&#x2F; 使用严格模式\n  &#125;,\n\n  &#x2F;&#x2F; 需要编译的 ts 文件\n  &quot;include&quot;: [\n    &quot;.&#x2F;src&#x2F;**&#x2F;*&quot;\n  ]\n&#125;</code></pre>\n\n<h2 id=\"webpack-config-js-配置\"><a href=\"#webpack-config-js-配置\" class=\"headerlink\" title=\"webpack.config.js 配置\"></a>webpack.config.js 配置</h2><h3 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const path &#x3D; require(&quot;path&quot;)\nconst &#123; CleanWebpackPlugin &#125; &#x3D; require(&quot;clean-webpack-plugin&quot;)\n\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; 入口文件\n  entry: &quot;.&#x2F;src&#x2F;index.ts&quot;,\n\n  &#x2F;&#x2F; 打包后的出口文件\n  output: &#123;\n    &#x2F;&#x2F; 文件路径\n    path: path.resolve(__dirname, &quot;dist&quot;),\n\n    &#x2F;&#x2F; 文件名\n    filename: &quot;bundle.js&quot;,\n  &#125;,\n  &#x2F;&#x2F; 使用的编译模块\n  module: &#123;\n\n    &#x2F;&#x2F; 指定要加载的规则\n    rules: [\n      &#123;\n        &#x2F;&#x2F; test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n        test: &#x2F;\\.ts$&#x2F;,\n\n        &#x2F;&#x2F; 要使用的 loader\n        use: [&#39;ts-loader&#39;],\n\n        &#x2F;&#x2F; 排除要编译的文件夹\n        exclude: &#x2F;node_modules&#x2F;\n      &#125;\n    ]\n  &#125;,\n\n  &#x2F;&#x2F; 用来设置需要引用的模块文件 (这里包括了 ts 和 js) 不设置的话, 引用其他 ts&#x2F;js 文件会编译报错\n  resolve: &#123;\n    extensions: [&#39;.ts&#39;, &#39;.js&#39;]\n  &#125;,\n\n  &#x2F;&#x2F; 配置 webpack 插件\n  plugins: [\n    new CleanWebpackPlugin()\n  ],\n&#125;</code></pre>\n\n<h3 id=\"使用-html-文件配置\"><a href=\"#使用-html-文件配置\" class=\"headerlink\" title=\"使用 html 文件配置\"></a>使用 html 文件配置</h3><blockquote>\n<p>前端项目中我们编译完的 js 文件最终会用到 html 文件中. 我们手动创建并引入 js 的话也不是不行, 但是很麻烦, 如果以后要增加一些其他的 js 或者 css 都得重新去手动引入. 这时候就可以用 <code>webpack</code> 给我们提供的一个自动引入经过 loader 编译后的文件 html 的插件 <code>html-webpack-plugin</code></p>\n<p><code>**_npm install -D html-webpack-plugin_**</code></p>\n</blockquote>\n<p>在最外层的 <code>plugins</code> 中配置</p>\n<p><a href=\"https://github.com/jantimon/html-webpack-plugin#configuration\">更多 html-webpack-plugin 的配置信息看这里</a></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 引入插件\nconst HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;)\n\nmodule.exprots &#x3D; &#123;\n  &#x2F;&#x2F; 配置 webpack 插件\n  plugins: [\n    new HtmlWebpackPlugin(&#123;\n      &#x2F;&#x2F; 配置 html 模板文件的目录\n      template: path.resolve(__dirname, &#39;public&#x2F;index.html&#39;)\n    &#125;)\n  ],\n&#125;</code></pre>\n\n<h3 id=\"使用-webpack-server-实时编译\"><a href=\"#使用-webpack-server-实时编译\" class=\"headerlink\" title=\"使用 webpack-server 实时编译\"></a>使用 webpack-server 实时编译</h3><blockquote>\n<p>弄好 <code>html</code> 自动引入后我们需要打开网页去调试我们的 ts 程序, 按照普通方式来修改一次又要打包一遍, 又要重新刷新一遍网页的话就很麻烦, 这时我们可以用 <code>webpack-server</code> 来进行开发服务器部署</p>\n<p><code>**_npm install -D webpack-server_**</code></p>\n<p>安装完后直接在 <code>package.json</code> 中进行配置运行命令运行就行了</p>\n</blockquote>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;webpack server --mode development&quot;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"配置-babel-来进行浏览器兼容\"><a href=\"#配置-babel-来进行浏览器兼容\" class=\"headerlink\" title=\"配置 babel 来进行浏览器兼容\"></a>配置 babel 来进行浏览器兼容</h3><p>在日常的开发中我们会经常遇到要兼容低版本浏览器的需要, 这时候为了增加开发效率我们可以用 <code>**_babel_**</code> 来将一些 <code>**_ES6_**</code> 中的高级属性来转换为低版本浏览器中的兼容属性</p>\n<p>需要的开发依赖</p>\n<blockquote>\n<ol>\n<li>@babel/core ( babel 的核心代码 )</li>\n<li>@babel/preset-env ( babel 的兼容库 )</li>\n<li>core-js ( 高级属性的兼容性替代方案 )</li>\n</ol>\n</blockquote>\n<blockquote>\n<p><code>**_npm install -D @babel/core @babel/preset-env core-js_**</code></p>\n</blockquote>\n<p>webpack 配置</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\nmodule.exports &#x3D; &#123;\n\n  &#x2F;&#x2F; 使用的编译模块\n  module: &#123;\n    &#x2F;&#x2F; 指定要加载的规则\n    rules: [\n      &#123;\n        &#x2F;&#x2F; test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n        test: &#x2F;\\.ts$&#x2F;,\n\n        &#x2F;&#x2F; 要使用的 loader\n        use: [\n\n          &#x2F;&#x2F; 配置 babel\n          &#123;\n            &#x2F;&#x2F; 指定要用的加载器\n            loader: &#39;babel-loader&#39;,\n\n            options: &#123;\n              &#x2F;&#x2F; 设置预定义的环境\n              presets: [\n                [\n                  &quot;@babel-preset-env&quot;,\n\n                  &#123;\n                    &#x2F;&#x2F; 需要兼容的目标浏览器, 根据项目需求填写\n                    targets: &#123;\n                      &quot;chrome&quot;: 95\n                    &#125;,\n\n                    &#x2F;&#x2F; 指定的 core 版本\n                    &quot;corejs&quot;: &#39;3&#39;,\n\n                    &#x2F;&#x2F; 使用 corejs 的方式 &quot;usage&quot; 按需加载\n                    &quot;useBuiltIns&quot;: &quot;usage&quot;\n                  &#125;\n                ]\n              ]\n            &#125;\n          &#125;,\n\n          &#x2F;&#x2F; 由于 webpack 中 rules 是从数组从后往前执行的, 所以 ts-loader 放在后面, 让 ts 先编译为 js 在通过 babel 进行兼容性转换\n          &#39;ts-loader&#39;\n        ],\n      &#125;\n    ]\n  &#125;\n&#125;</code></pre>\n"},{"title":"基础 - 原始数据类型","cover":"https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png","_content":"\n# 基础 - 原始数据类型\n\nJavaScript的数据类型分为两种: 原始数据类型([Primitive Data types](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive))和对象类型(Object types)\n\n原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。\n\n## 布尔值\n\n布尔值是最基础的数据类型, 在TypeScript中, 使用 `boolean`布尔值类型\n\n```TypeScript\nlet isMan: boolean = true\n\n// 编译通过\n```\n\n:::tip\n注意，使用构造函数 Boolean 创造的对象不是布尔值：\n:::\n\n```TypeScript\nlet createByNewBoolean: boolean = new Boolean(1)\n\n// 此时会编译报错\n// Type 'Boolean' is not assignable to type 'boolean'.\n//   'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible.\n```\n\n事实上 `new Boolean()` 返回的是一个`Boolean`对象:\n\n:::tip\n直接调用`Boolean`也可以返回一个boolean类型\n\n```TypeScript\nlet createdByBoolean: boolean = Boolean(1);\n```\n\n:::\n\n在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。\n\n## 数值\n\n使用 `number`定义数值类型\n\n```TypeScript\nlet decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\n// ES6 中的二进制表示法\nlet binaryLiteral: number = 0b1010;\n// ES6 中的八进制表示法\nlet octalLiteral: number = 0o744;\nlet notANumber: number = NaN;\nlet infinityNumber: number = Infinity;\n```\n\ntsc的编译结果\n\n```TypeScript\nvar decLiteral = 6;\nvar hexLiteral = 0xf00d;\n// ES6 中的二进制表示法\nvar binaryLiteral = 10;\n// ES6 中的八进制表示法\nvar octalLiteral = 484;\nvar notANumber = NaN;\nvar infinityNumber = Infinity;\n```\n\n其中 0b1010 和 0o744 是 [ES6 中的二进制和八进制表示法](https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95)，它们会被编译为十进制数字。\n\n## 字符串\n\n使用 `string`定义字符串类型\n\n```TypeScript\nlet str: string = 'jeck'\n\n// 模板字符串\nlet str_o: string = `my name is ${str}`\n```\n\n编译结果:\n\n```TypeScript\nvar str = jeck\n\n// 模板字符串\nvar str_o = 'my name is' + str\n```\n\n## 空值\n\nJavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：\n\n```TypeScript\nfunction alertName(): void {\n    alert('My name is Tom');\n}\n```\n\n声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null（只在 --strictNullChecks 未指定时）：\n\n```TypeScript\nlet unusable: void = undefined;\n```\n\n## Null 和 Undefined\n\n在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：\n\n```TypeScript\nlet u: undefined = undefined;\nlet n: null = null;\n```\n\n> 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：\n\n```TypeScript\n// 这样不会报错\nlet num: number = undefined;\n```\n\n```TypeScript\n// 这样也不会报错\nlet u: undefined;\nlet num: number = u;\n```\n\n而 void 类型的变量不能赋值给 number 类型的变量：\n\n```TypeScript\nlet u: void;\nlet num: number = u;\n\n// Type 'void' is not assignable to type 'number'.\n```\n\n## 参考\n\n- [Basic Types（中文版）](https://www.typescriptlang.org/zh/docs/handbook/2/everyday-types.html)\n- [Primitive data types](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)\n- [ES6 中的新类型 Symbol](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n- [ES6 中的二进制和八进制表示法](https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95)\n- [ES6 中的模板字符串](http://es6.ruanyifeng.com/#docs/string#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2)","source":"_posts/typescript/基础/原始数据类型.md","raw":"---\ntitle: 基础 - 原始数据类型\ncover: https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png\ncategories:\n  - TypeScript\ntags:\n  - TypeScript\n---\n\n# 基础 - 原始数据类型\n\nJavaScript的数据类型分为两种: 原始数据类型([Primitive Data types](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive))和对象类型(Object types)\n\n原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。\n\n## 布尔值\n\n布尔值是最基础的数据类型, 在TypeScript中, 使用 `boolean`布尔值类型\n\n```TypeScript\nlet isMan: boolean = true\n\n// 编译通过\n```\n\n:::tip\n注意，使用构造函数 Boolean 创造的对象不是布尔值：\n:::\n\n```TypeScript\nlet createByNewBoolean: boolean = new Boolean(1)\n\n// 此时会编译报错\n// Type 'Boolean' is not assignable to type 'boolean'.\n//   'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible.\n```\n\n事实上 `new Boolean()` 返回的是一个`Boolean`对象:\n\n:::tip\n直接调用`Boolean`也可以返回一个boolean类型\n\n```TypeScript\nlet createdByBoolean: boolean = Boolean(1);\n```\n\n:::\n\n在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。\n\n## 数值\n\n使用 `number`定义数值类型\n\n```TypeScript\nlet decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\n// ES6 中的二进制表示法\nlet binaryLiteral: number = 0b1010;\n// ES6 中的八进制表示法\nlet octalLiteral: number = 0o744;\nlet notANumber: number = NaN;\nlet infinityNumber: number = Infinity;\n```\n\ntsc的编译结果\n\n```TypeScript\nvar decLiteral = 6;\nvar hexLiteral = 0xf00d;\n// ES6 中的二进制表示法\nvar binaryLiteral = 10;\n// ES6 中的八进制表示法\nvar octalLiteral = 484;\nvar notANumber = NaN;\nvar infinityNumber = Infinity;\n```\n\n其中 0b1010 和 0o744 是 [ES6 中的二进制和八进制表示法](https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95)，它们会被编译为十进制数字。\n\n## 字符串\n\n使用 `string`定义字符串类型\n\n```TypeScript\nlet str: string = 'jeck'\n\n// 模板字符串\nlet str_o: string = `my name is ${str}`\n```\n\n编译结果:\n\n```TypeScript\nvar str = jeck\n\n// 模板字符串\nvar str_o = 'my name is' + str\n```\n\n## 空值\n\nJavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：\n\n```TypeScript\nfunction alertName(): void {\n    alert('My name is Tom');\n}\n```\n\n声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null（只在 --strictNullChecks 未指定时）：\n\n```TypeScript\nlet unusable: void = undefined;\n```\n\n## Null 和 Undefined\n\n在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：\n\n```TypeScript\nlet u: undefined = undefined;\nlet n: null = null;\n```\n\n> 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：\n\n```TypeScript\n// 这样不会报错\nlet num: number = undefined;\n```\n\n```TypeScript\n// 这样也不会报错\nlet u: undefined;\nlet num: number = u;\n```\n\n而 void 类型的变量不能赋值给 number 类型的变量：\n\n```TypeScript\nlet u: void;\nlet num: number = u;\n\n// Type 'void' is not assignable to type 'number'.\n```\n\n## 参考\n\n- [Basic Types（中文版）](https://www.typescriptlang.org/zh/docs/handbook/2/everyday-types.html)\n- [Primitive data types](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)\n- [ES6 中的新类型 Symbol](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n- [ES6 中的二进制和八进制表示法](https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95)\n- [ES6 中的模板字符串](http://es6.ruanyifeng.com/#docs/string#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2)","slug":"typescript/基础/原始数据类型","published":1,"date":"2023-01-05T02:23:28.205Z","updated":"2023-01-05T04:00:47.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcikoslh0000asvng9x2e0ho","content":"<h1 id=\"基础-原始数据类型\"><a href=\"#基础-原始数据类型\" class=\"headerlink\" title=\"基础 - 原始数据类型\"></a>基础 - 原始数据类型</h1><p>JavaScript的数据类型分为两种: 原始数据类型(<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive\">Primitive Data types</a>)和对象类型(Object types)</p>\n<p>原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。</p>\n<h2 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h2><p>布尔值是最基础的数据类型, 在TypeScript中, 使用 <code>boolean</code>布尔值类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let isMan: boolean &#x3D; true\n\n&#x2F;&#x2F; 编译通过</code></pre>\n\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>注意，使用构造函数 Boolean 创造的对象不是布尔值：</p>\n</div>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let createByNewBoolean: boolean &#x3D; new Boolean(1)\n\n&#x2F;&#x2F; 此时会编译报错\n&#x2F;&#x2F; Type &#39;Boolean&#39; is not assignable to type &#39;boolean&#39;.\n&#x2F;&#x2F;   &#39;boolean&#39; is a primitive, but &#39;Boolean&#39; is a wrapper object. Prefer using &#39;boolean&#39; when possible.</code></pre>\n\n<p>事实上 <code>new Boolean()</code> 返回的是一个<code>Boolean</code>对象:</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>直接调用<code>Boolean</code>也可以返回一个boolean类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let createdByBoolean: boolean &#x3D; Boolean(1);</code></pre>\n\n</p>\n</div>\n<p>在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。</p>\n<h2 id=\"数值\"><a href=\"#数值\" class=\"headerlink\" title=\"数值\"></a>数值</h2><p>使用 <code>number</code>定义数值类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let decLiteral: number &#x3D; 6;\nlet hexLiteral: number &#x3D; 0xf00d;\n&#x2F;&#x2F; ES6 中的二进制表示法\nlet binaryLiteral: number &#x3D; 0b1010;\n&#x2F;&#x2F; ES6 中的八进制表示法\nlet octalLiteral: number &#x3D; 0o744;\nlet notANumber: number &#x3D; NaN;\nlet infinityNumber: number &#x3D; Infinity;</code></pre>\n\n<p>tsc的编译结果</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">var decLiteral &#x3D; 6;\nvar hexLiteral &#x3D; 0xf00d;\n&#x2F;&#x2F; ES6 中的二进制表示法\nvar binaryLiteral &#x3D; 10;\n&#x2F;&#x2F; ES6 中的八进制表示法\nvar octalLiteral &#x3D; 484;\nvar notANumber &#x3D; NaN;\nvar infinityNumber &#x3D; Infinity;</code></pre>\n\n<p>其中 0b1010 和 0o744 是 <a href=\"https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95\">ES6 中的二进制和八进制表示法</a>，它们会被编译为十进制数字。</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>使用 <code>string</code>定义字符串类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let str: string &#x3D; &#39;jeck&#39;\n\n&#x2F;&#x2F; 模板字符串\nlet str_o: string &#x3D; &#96;my name is $&#123;str&#125;&#96;</code></pre>\n\n<p>编译结果:</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">var str &#x3D; jeck\n\n&#x2F;&#x2F; 模板字符串\nvar str_o &#x3D; &#39;my name is&#39; + str</code></pre>\n\n<h2 id=\"空值\"><a href=\"#空值\" class=\"headerlink\" title=\"空值\"></a>空值</h2><p>JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function alertName(): void &#123;\n    alert(&#39;My name is Tom&#39;);\n&#125;</code></pre>\n\n<p>声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null（只在 –strictNullChecks 未指定时）：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let unusable: void &#x3D; undefined;</code></pre>\n\n<h2 id=\"Null-和-Undefined\"><a href=\"#Null-和-Undefined\" class=\"headerlink\" title=\"Null 和 Undefined\"></a>Null 和 Undefined</h2><p>在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let u: undefined &#x3D; undefined;\nlet n: null &#x3D; null;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：</p></blockquote>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">&#x2F;&#x2F; 这样不会报错\nlet num: number &#x3D; undefined;</code></pre>\n\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">&#x2F;&#x2F; 这样也不会报错\nlet u: undefined;\nlet num: number &#x3D; u;</code></pre>\n\n<p>而 void 类型的变量不能赋值给 number 类型的变量：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let u: void;\nlet num: number &#x3D; u;\n\n&#x2F;&#x2F; Type &#39;void&#39; is not assignable to type &#39;number&#39;.</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.typescriptlang.org/zh/docs/handbook/2/everyday-types.html\">Basic Types（中文版）</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive\">Primitive data types</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">ES6 中的新类型 Symbol</a></li>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95\">ES6 中的二进制和八进制表示法</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/string#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2\">ES6 中的模板字符串</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基础-原始数据类型\"><a href=\"#基础-原始数据类型\" class=\"headerlink\" title=\"基础 - 原始数据类型\"></a>基础 - 原始数据类型</h1><p>JavaScript的数据类型分为两种: 原始数据类型(<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive\">Primitive Data types</a>)和对象类型(Object types)</p>\n<p>原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。</p>\n<h2 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h2><p>布尔值是最基础的数据类型, 在TypeScript中, 使用 <code>boolean</code>布尔值类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let isMan: boolean &#x3D; true\n\n&#x2F;&#x2F; 编译通过</code></pre>\n\n<p>:::tip<br>注意，使用构造函数 Boolean 创造的对象不是布尔值：<br>:::</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let createByNewBoolean: boolean &#x3D; new Boolean(1)\n\n&#x2F;&#x2F; 此时会编译报错\n&#x2F;&#x2F; Type &#39;Boolean&#39; is not assignable to type &#39;boolean&#39;.\n&#x2F;&#x2F;   &#39;boolean&#39; is a primitive, but &#39;Boolean&#39; is a wrapper object. Prefer using &#39;boolean&#39; when possible.</code></pre>\n\n<p>事实上 <code>new Boolean()</code> 返回的是一个<code>Boolean</code>对象:</p>\n<p>:::tip<br>直接调用<code>Boolean</code>也可以返回一个boolean类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let createdByBoolean: boolean &#x3D; Boolean(1);</code></pre>\n\n<p>:::</p>\n<p>在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。</p>\n<h2 id=\"数值\"><a href=\"#数值\" class=\"headerlink\" title=\"数值\"></a>数值</h2><p>使用 <code>number</code>定义数值类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let decLiteral: number &#x3D; 6;\nlet hexLiteral: number &#x3D; 0xf00d;\n&#x2F;&#x2F; ES6 中的二进制表示法\nlet binaryLiteral: number &#x3D; 0b1010;\n&#x2F;&#x2F; ES6 中的八进制表示法\nlet octalLiteral: number &#x3D; 0o744;\nlet notANumber: number &#x3D; NaN;\nlet infinityNumber: number &#x3D; Infinity;</code></pre>\n\n<p>tsc的编译结果</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">var decLiteral &#x3D; 6;\nvar hexLiteral &#x3D; 0xf00d;\n&#x2F;&#x2F; ES6 中的二进制表示法\nvar binaryLiteral &#x3D; 10;\n&#x2F;&#x2F; ES6 中的八进制表示法\nvar octalLiteral &#x3D; 484;\nvar notANumber &#x3D; NaN;\nvar infinityNumber &#x3D; Infinity;</code></pre>\n\n<p>其中 0b1010 和 0o744 是 <a href=\"https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95\">ES6 中的二进制和八进制表示法</a>，它们会被编译为十进制数字。</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>使用 <code>string</code>定义字符串类型</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let str: string &#x3D; &#39;jeck&#39;\n\n&#x2F;&#x2F; 模板字符串\nlet str_o: string &#x3D; &#96;my name is $&#123;str&#125;&#96;</code></pre>\n\n<p>编译结果:</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">var str &#x3D; jeck\n\n&#x2F;&#x2F; 模板字符串\nvar str_o &#x3D; &#39;my name is&#39; + str</code></pre>\n\n<h2 id=\"空值\"><a href=\"#空值\" class=\"headerlink\" title=\"空值\"></a>空值</h2><p>JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">function alertName(): void &#123;\n    alert(&#39;My name is Tom&#39;);\n&#125;</code></pre>\n\n<p>声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null（只在 –strictNullChecks 未指定时）：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let unusable: void &#x3D; undefined;</code></pre>\n\n<h2 id=\"Null-和-Undefined\"><a href=\"#Null-和-Undefined\" class=\"headerlink\" title=\"Null 和 Undefined\"></a>Null 和 Undefined</h2><p>在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let u: undefined &#x3D; undefined;\nlet n: null &#x3D; null;</code></pre>\n\n<blockquote>\n<p>与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：</p>\n</blockquote>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">&#x2F;&#x2F; 这样不会报错\nlet num: number &#x3D; undefined;</code></pre>\n\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">&#x2F;&#x2F; 这样也不会报错\nlet u: undefined;\nlet num: number &#x3D; u;</code></pre>\n\n<p>而 void 类型的变量不能赋值给 number 类型的变量：</p>\n<pre class=\"line-numbers language-TypeScript\" data-language=\"TypeScript\"><code class=\"language-TypeScript\">let u: void;\nlet num: number &#x3D; u;\n\n&#x2F;&#x2F; Type &#39;void&#39; is not assignable to type &#39;number&#39;.</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.typescriptlang.org/zh/docs/handbook/2/everyday-types.html\">Basic Types（中文版）</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive\">Primitive data types</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">ES6 中的新类型 Symbol</a></li>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/number#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95\">ES6 中的二进制和八进制表示法</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/string#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2\">ES6 中的模板字符串</a></li>\n</ul>\n"},{"title":"基础","cover":"https://whitelabelcoders.com/app/uploads/18.jpg","_content":"\n# 基础\n\n> 本部分介绍了 TypeScript 中的常用类型和一些基本概念，旨在让大家对 TypeScript 有个初步的理解。具体内容包括：\n\n- [原始数据类型](/post/typescript/基础/原始数据类型)\n-\n- [任意值](/post/typescript/基础/任意值)\n-\n- [类型推论](/post/typescript/基础/类型推论)\n-\n- [联合类型](/post/typescript/基础/联合类型)\n-\n- [对象的类型——接口](/post/typescript/基础/对象的类型——接口)\n-\n- [数组的类型](/post/typescript/基础/数组的类型)\n-\n- [函数的类型](/post/typescript/基础/函数的类型)\n-\n- [类型断言](/post/typescript/基础/类型断言)\n-\n- [声明文件](/post/typescript/基础/声明文件)\n-\n- [内置对象](/post/typescript/基础/内置对象)","source":"_posts/typescript/基础/基础.md","raw":"---\ntitle: 基础\ncover: https://whitelabelcoders.com/app/uploads/18.jpg\ncategories:\n  - TypeScript入门\ntags:\n  - TypeScript\n---\n\n# 基础\n\n> 本部分介绍了 TypeScript 中的常用类型和一些基本概念，旨在让大家对 TypeScript 有个初步的理解。具体内容包括：\n\n- [原始数据类型](/post/typescript/基础/原始数据类型)\n-\n- [任意值](/post/typescript/基础/任意值)\n-\n- [类型推论](/post/typescript/基础/类型推论)\n-\n- [联合类型](/post/typescript/基础/联合类型)\n-\n- [对象的类型——接口](/post/typescript/基础/对象的类型——接口)\n-\n- [数组的类型](/post/typescript/基础/数组的类型)\n-\n- [函数的类型](/post/typescript/基础/函数的类型)\n-\n- [类型断言](/post/typescript/基础/类型断言)\n-\n- [声明文件](/post/typescript/基础/声明文件)\n-\n- [内置对象](/post/typescript/基础/内置对象)","slug":"typescript/基础/基础","published":1,"date":"2023-01-05T02:27:24.372Z","updated":"2023-01-05T02:37:41.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clcikoslm0001asvn4uph0lhr","content":"<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>本部分介绍了 TypeScript 中的常用类型和一些基本概念，旨在让大家对 TypeScript 有个初步的理解。具体内容包括：</p></blockquote>\n<ul>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\">原始数据类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E4%BB%BB%E6%84%8F%E5%80%BC\">任意值</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA\">类型推论</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B\">联合类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3\">对象的类型——接口</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84%E7%9A%84%E7%B1%BB%E5%9E%8B\">数组的类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B\">函数的类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80\">类型断言</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">声明文件</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1\">内置对象</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><blockquote>\n<p>本部分介绍了 TypeScript 中的常用类型和一些基本概念，旨在让大家对 TypeScript 有个初步的理解。具体内容包括：</p>\n</blockquote>\n<ul>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\">原始数据类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E4%BB%BB%E6%84%8F%E5%80%BC\">任意值</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA\">类型推论</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B\">联合类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3\">对象的类型——接口</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84%E7%9A%84%E7%B1%BB%E5%9E%8B\">数组的类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B\">函数的类型</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80\">类型断言</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6\">声明文件</a></li>\n<li></li>\n<li><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1\">内置对象</a></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clcigr1t40001nkvndf6uefcy","category_id":"clcigr1t90003nkvnf0wi994y","_id":"clcigr1tf000ankvn8nz43saz"},{"post_id":"clcigr1t80002nkvn96s9a7g8","category_id":"clcigr1t90003nkvnf0wi994y","_id":"clcigr1tg000dnkvndu0md9l0"},{"post_id":"clcigr1tb0005nkvn2l9ag8h9","category_id":"clcigr1t90003nkvnf0wi994y","_id":"clcigr1th000gnkvn63czegxg"},{"post_id":"clcigr1td0006nkvn7c1x3xga","category_id":"clcigr1tg000cnkvnf38pb39f","_id":"clcigr1ti000knkvn8ttp7x8e"},{"post_id":"clcigr1tl000znkvn4fl0eku8","category_id":"clcigr1tg000cnkvnf38pb39f","_id":"clcigr1tn0012nkvnczmr1bln"},{"post_id":"clcigr1tm0010nkvnav2385jg","category_id":"clcigr1tg000cnkvnf38pb39f","_id":"clcigr1tn0013nkvnfjp2ev8e"},{"post_id":"clcikoslh0000asvng9x2e0ho","category_id":"clcigr1tg000cnkvnf38pb39f","_id":"clcikosls0005asvn2och2ny6"},{"post_id":"clcikoslm0001asvn4uph0lhr","category_id":"clcikoslp0003asvn9q3k3qq7","_id":"clcikosls0006asvng8pig1ad"}],"PostTag":[{"post_id":"clcigr1t40001nkvndf6uefcy","tag_id":"clcigr1tb0004nkvnajl74yhx","_id":"clcigr1th000fnkvngr2nawq1"},{"post_id":"clcigr1t40001nkvndf6uefcy","tag_id":"clcigr1te0008nkvnhllk1f3s","_id":"clcigr1th000hnkvn0xcw5pnm"},{"post_id":"clcigr1t40001nkvndf6uefcy","tag_id":"clcigr1tg000bnkvnh74b0nps","_id":"clcigr1ti000jnkvnakktfpty"},{"post_id":"clcigr1t80002nkvn96s9a7g8","tag_id":"clcigr1tb0004nkvnajl74yhx","_id":"clcigr1tj000nnkvnf0ul8xd1"},{"post_id":"clcigr1t80002nkvn96s9a7g8","tag_id":"clcigr1te0008nkvnhllk1f3s","_id":"clcigr1tj000onkvne8z8gkd6"},{"post_id":"clcigr1t80002nkvn96s9a7g8","tag_id":"clcigr1tg000bnkvnh74b0nps","_id":"clcigr1tj000qnkvn0f0wg6e8"},{"post_id":"clcigr1tb0005nkvn2l9ag8h9","tag_id":"clcigr1tb0004nkvnajl74yhx","_id":"clcigr1tk000tnkvn77zc8cml"},{"post_id":"clcigr1tb0005nkvn2l9ag8h9","tag_id":"clcigr1tj000pnkvnfwj049hu","_id":"clcigr1tk000unkvnbaar4ncl"},{"post_id":"clcigr1tb0005nkvn2l9ag8h9","tag_id":"clcigr1tj000rnkvnbaqy42mw","_id":"clcigr1tk000wnkvnfjpbd0cs"},{"post_id":"clcigr1td0006nkvn7c1x3xga","tag_id":"clcigr1tk000snkvn3sva8pw8","_id":"clcigr1tk000xnkvn9kpd8cx0"},{"post_id":"clcigr1td0006nkvn7c1x3xga","tag_id":"clcigr1tk000vnkvn52i2dd3l","_id":"clcigr1tk000ynkvn3wfdg8zp"},{"post_id":"clcigr1tl000znkvn4fl0eku8","tag_id":"clcigr1tk000snkvn3sva8pw8","_id":"clcigr1tn0015nkvn2fcmadm2"},{"post_id":"clcigr1tl000znkvn4fl0eku8","tag_id":"clcigr1tn0011nkvn7az291nt","_id":"clcigr1tn0016nkvnftwzbl4n"},{"post_id":"clcigr1tm0010nkvnav2385jg","tag_id":"clcigr1tk000snkvn3sva8pw8","_id":"clcigr1to0018nkvng7nka2zp"},{"post_id":"clcigr1tm0010nkvnav2385jg","tag_id":"clcigr1tn0014nkvnh1midkea","_id":"clcigr1to0019nkvn2txb1tbn"},{"post_id":"clcigr1tm0010nkvnav2385jg","tag_id":"clcigr1to0017nkvn8sym2zin","_id":"clcigr1to001ankvn9j6c0soz"},{"post_id":"clcikoslh0000asvng9x2e0ho","tag_id":"clcigr1tk000snkvn3sva8pw8","_id":"clcikoslo0002asvnbfia4qp2"},{"post_id":"clcikoslm0001asvn4uph0lhr","tag_id":"clcigr1tk000snkvn3sva8pw8","_id":"clcikosls0004asvnhrs10t8p"}],"Tag":[{"name":"Docker","_id":"clcigr1tb0004nkvnajl74yhx"},{"name":"容器","_id":"clcigr1te0008nkvnhllk1f3s"},{"name":"container","_id":"clcigr1tg000bnkvnh74b0nps"},{"name":"镜像","_id":"clcigr1tj000pnkvnfwj049hu"},{"name":"images","_id":"clcigr1tj000rnkvnbaqy42mw"},{"name":"TypeScript","_id":"clcigr1tk000snkvn3sva8pw8"},{"name":"数据类型","_id":"clcigr1tk000vnkvn52i2dd3l"},{"name":"tsconfig","_id":"clcigr1tn0011nkvn7az291nt"},{"name":"环境搭建","_id":"clcigr1tn0014nkvnh1midkea"},{"name":"webpack","_id":"clcigr1to0017nkvn8sym2zin"}]}}