[{"id":"bb4675de51cf9271a480ed892e5e9379","title":"基础 - 数组的类型","content":"数组的类型在 TypeScript 中，数组类型有多种定义方式，比较灵活。\n「类型 + 方括号」表示法最简单的方法是使用「类型 + 方括号」来表示数组：\nlet fibonacci: number[] &#x3D; [1, 1, 2, 3, 5];\n\n数组的项中不允许出现其他的类型：\nlet fibonacci: number[] &#x3D; [1, &#39;1&#39;, 2, 3, 5];\n\n&#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;number&#39;.\n\n数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：\nlet fibonacci: number[] &#x3D; [1, 1, 2, 3, 5];\nfibonacci.push(&#39;8&#39;);\n\n&#x2F;&#x2F; Argument of type &#39;&quot;8&quot;&#39; is not assignable to parameter of type &#39;number&#39;.\n\n上例中，push 方法只允许传入 number 类型的参数，但是却传了一个 &quot;8&quot; 类型的参数，所以报错了。这里 &quot;8&quot; 是一个字符串字面量类型，会在后续章节中详细介绍。\n数组泛型我们也可以使用数组泛型（Array Generic） Array 来表示数组：\nlet fibonacci: Array&lt;number&gt; &#x3D; [1, 1, 2, 3, 5];\n\n关于泛型，可以参考泛型一章。\n用接口表示数组接口也可以用来描述数组：\ninterface NumberArray &#123;\n    [index: number]: number;\n&#125;\nlet fibonacci: NumberArray &#x3D; [1, 1, 2, 3, 5];\n\nNumberArray 表示：只要索引的类型是数字时，那么值的类型必须是数字。\n虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。\n不过有一种情况例外，那就是它常用来表示类数组。\n类数组类数组（Array-like Object）不是数组类型，比如 arguments：\nfunction sum() &#123;\n    let args: number[] &#x3D; arguments;\n&#125;\n\n&#x2F;&#x2F; Type &#39;IArguments&#39; is missing the following properties from type &#39;number[]&#39;: pop, push, concat, join, and 24 more.\n\n上例中，arguments 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：\nfunction sum() &#123;\n    let args: &#123;\n        [index: number]: number;\n        length: number;\n        callee: Function;\n    &#125; &#x3D; arguments;\n&#125;\n\n在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 length 和 callee 两个属性。\n事实上常用的类数组都有自己的接口定义，如 IArguments, NodeList, HTMLCollection 等：\nfunction sum() &#123;\n    let args: IArguments &#x3D; arguments;\n&#125;\n\n其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是：\ninterface IArguments &#123;\n    [index: number]: any;\n    length: number;\n    callee: Function;\n&#125;\n\n关于内置对象，可以参考内置对象一章。\nany 在数组中的应用一个比较常见的做法是，用 any 表示数组中允许出现任意类型：\ninterface IArguments &#123;\n    [index: number]: any;\n    length: number;\n    callee: Function;\n&#125;\n\n参考\nBasic Types # Array\nInterfaces # Indexable Types\n\n","slug":"typescript/基础/数组的类型","date":"2023-01-05T09:45:01.484Z","categories_index":"TypeScript入门","tags_index":"TypeScript,类型,数组","author_index":"木木木"},{"id":"681258ab14d4e7b50ea459ce622019e2","title":"基础 - 对象的类型——接口","content":"对象的类型——接口在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。\n什么是接口在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。\nTypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。\n简单的例子interface Person &#123;\n    name: string;\n    age: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25\n&#125;;\n\n上面的例子中，我们定义了一个接口 Person，接着定义了一个变量 tom，它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person 一致。\n接口一般首字母大写。有的编程语言中会建议接口的名称加上 I 前缀。\n定义的变量比接口少了一些属性是不允许的：\ninterface Person &#123;\n    name: string;\n    age: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;\n&#125;;\n\n&#x2F;&#x2F; index.ts(6,5): error TS2322: Type &#39;&#123; name: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Property &#39;age&#39; is missing in type &#39;&#123; name: string; &#125;&#39;.\n\n多一些属性也是不允许的：\ninterface Person &#123;\n    name: string;\n    age: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n&#x2F;&#x2F; index.ts(9,5): error TS2322: Type &#39;&#123; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Object literal may only specify known properties, and &#39;gender&#39; does not exist in type &#39;Person&#39;.\n\n可见，赋值的时候，变量的形状必须和接口的形状保持一致。\n可选属性有时我们希望不要完全匹配一个形状，那么可以用可选属性：\ninterface Person &#123;\n    name: string;\n    age?: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;\n&#125;;\n\ninterface Person &#123;\n    name: string;\n    age?: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25\n&#125;;\n\n可选属性的含义是该属性可以不存在。\n这时仍然不允许添加未定义的属性：\ninterface Person &#123;\n    name: string;\n    age?: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n&#x2F;&#x2F; examples&#x2F;playground&#x2F;index.ts(9,5): error TS2322: Type &#39;&#123; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Object literal may only specify known properties, and &#39;gender&#39; does not exist in type &#39;Person&#39;.\n\n任意属性有时候我们希望一个接口允许有任意的属性，可以使用如下方式：\ninterface Person &#123;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;\n\n使用 [propName: string] 定义了任意属性取 string 类型的值。\n需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的同类型或者子集：\ninterface Person &#123;\n    name: string;\n    age?: number;\n    [propName: string]: string;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n&#x2F;&#x2F; index.ts(3,5): error TS2411: Property &#39;age&#39; of type &#39;number&#39; is not assignable to string index type &#39;string&#39;.\n&#x2F;&#x2F; index.ts(7,5): error TS2322: Type &#39;&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Index signatures are incompatible.\n&#x2F;&#x2F;     Type &#39;string | number&#39; is not assignable to type &#39;string&#39;.\n&#x2F;&#x2F;       Type &#39;number&#39; is not assignable to type &#39;string&#39;.\n\n上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。\n另外，在报错信息中可以看出，此时 &#123; name: &#39;Tom&#39;, age: 25, gender: &#39;male&#39; &#125; 的类型被推断成了 &#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;，这是联合类型和接口的结合。\n一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：\ninterface Person &#123;\n    name: string;\n    age?: number;\n    [propName: string]: string | number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n只读属性有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性：\ninterface Person &#123;\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    id: 89757,\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;\n\ntom.id &#x3D; 9527;\n\n&#x2F;&#x2F; index.ts(14,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-only property.\n\n上例中，使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了。\n注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：\ninterface Person &#123;\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;\n\ntom.id &#x3D; 89757;\n\n&#x2F;&#x2F; index.ts(8,5): error TS2322: Type &#39;&#123; name: string; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Property &#39;id&#39; is missing in type &#39;&#123; name: string; gender: string; &#125;&#39;.\n&#x2F;&#x2F; index.ts(13,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-only property.\n\n上例中，报错信息有两处，第一处是在对 tom 进行赋值的时候，没有给 id 赋值。\n第二处是在给 tom.id 赋值的时候，由于它是只读属性，所以报错了。\n参考\nInterfaces\n\n","slug":"typescript/基础/对象的类型——接口","date":"2023-01-05T08:16:54.245Z","categories_index":"TypeScript入门","tags_index":"TypeScript,类型","author_index":"木木木"},{"id":"b1398d75ab86fa5e1ccefc06f04a3c6f","title":"基础 - 联合类型","content":"联合类型联合类型（Union Types）表示取值可以为多种类型中的一种。\nlet myFavoriteNumber: string | number;\nmyFavoriteNumber &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\nlet myFavoriteNumber: string | number;\nmyFavoriteNumber &#x3D; true;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;boolean&#39; is not assignable to type &#39;string | number&#39;.\n&#x2F;&#x2F;   Type &#39;boolean&#39; is not assignable to type &#39;number&#39;.\n\n\n\n\n\n\n\n提示\n联合类型使用 | 分隔每个类型。\n这里的 let myFavoriteNumber: string | number 的含义是，允许 myFavoriteNumber 的类型是 string 或者 number，但是不能是其他类型。\n\n访问联合类型的属性或方法当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：\nfunction getLength(something: string | number): number &#123;\n    return something.length;\n&#125;\n\n&#x2F;&#x2F; index.ts(2,22): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.\n&#x2F;&#x2F;   Property &#39;length&#39; does not exist on type &#39;number&#39;.\n\n上例中，length 不是 string 和 number 的共有属性，所以会报错。\n访问 string 和 number 的共有属性是没问题的：\nfunction getString(something: string | number): string &#123;\n    return something.toString();\n&#125;\n\n联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：\nlet myFavoriteNumber: string | number;\nmyFavoriteNumber &#x3D; &#39;seven&#39;;\nconsole.log(myFavoriteNumber.length); &#x2F;&#x2F; 5\nmyFavoriteNumber &#x3D; 7;\nconsole.log(myFavoriteNumber.length); &#x2F;&#x2F; 编译时报错\n\n&#x2F;&#x2F; index.ts(5,30): error TS2339: Property &#39;length&#39; does not exist on type &#39;number&#39;.\n\n参考\nAdvanced Types # Union Types\n\n","slug":"typescript/基础/联合类型","date":"2023-01-05T08:05:08.103Z","categories_index":"TypeScript入门","tags_index":"TypeScript,类型","author_index":"木木木"},{"id":"60214032119e37fbea15a4db1ead45d9","title":"基础 - 类型推论","content":"类型推论如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。\n什么是类型推论以下代码虽然没有指定类型，但是会在编译的时候报错:\nlet myFavoriteNumber &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;\n\n事实上，它等价于：\nlet myFavoriteNumber: string &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.\n\nTypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。\n如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：\nlet myFavoriteNumber;\nmyFavoriteNumber &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n参考\nType Interface\n\n","slug":"typescript/基础/类型推论","date":"2023-01-05T07:51:40.501Z","categories_index":"TypeScript入门","tags_index":"TypeScript,基础","author_index":"木木木"},{"id":"4a36cb26fb4c51b35df980776346e43b","title":"基础 - 任意值","content":"任意值任意值（Any）用来表示允许赋值为任意类型。\n什么是任意值类型如果是一个普通类型，在赋值过程中改变类型是不被允许的：\nlet myFavoriteNumber: string &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.\n\n但如果是 any 类型，则允许被赋值为任意类型\nlet myFavoriteNumber: any &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n任意值的属性和方法在任意值上访问任何属性都是允许的：\nlet anyThing: any &#x3D; &#39;hello&#39;;\nconsole.log(anyThing.myName);\nconsole.log(anyThing.myName.firstName);\n\n也可以调用任何方法\nlet anyThing: any &#x3D; &#39;Tom&#39;;\nanyThing.setName(&#39;Jerry&#39;);\nanyThing.setName(&#39;Jerry&#39;).sayHello();\nanyThing.myName.setFirstName(&#39;Cat&#39;);\n\n可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值\n未声明类型的变量变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：\nlet something;\nsomething &#x3D; &#39;seven&#39;;\nsomething &#x3D; 7;\n\nsomething.setName(&#39;Tom&#39;);\n\n等价于\nlet something: any;\nsomething &#x3D; &#39;seven&#39;;\nsomething &#x3D; 7;\n\nsomething.setName(&#39;Tom&#39;);\n\n参考\nBasic Types # Any（中文版）\n\n","slug":"typescript/基础/任意值","date":"2023-01-05T07:02:13.455Z","categories_index":"TypeScript入门","tags_index":"TypeScript,基础","author_index":"木木木"},{"id":"95785751ac1389398263330b9b39fc70","title":"基础","content":"基础\n\n\n\n\n\n\n\n\n本部分介绍了 TypeScript 中的常用类型和一些基本概念，旨在让大家对 TypeScript 有个初步的理解。具体内容包括：\n\n原始数据类型\n\n任意值\n\n类型推论\n\n联合类型\n\n对象的类型——接口\n\n数组的类型\n\n函数的类型\n\n类型断言\n\n声明文件\n\n内置对象\n\n","slug":"typescript/基础/基础","date":"2023-01-05T02:27:24.372Z","categories_index":"TypeScript入门","tags_index":"TypeScript,基础","author_index":"木木木"},{"id":"78e5ff641c0f32df664f03d82148a661","title":"基础 - 原始数据类型","content":"基础 - 原始数据类型JavaScript的数据类型分为两种: 原始数据类型(Primitive Data types)和对象类型(Object types)\n原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。\n布尔值布尔值是最基础的数据类型, 在TypeScript中, 使用 boolean布尔值类型\nlet isMan: boolean &#x3D; true\n\n&#x2F;&#x2F; 编译通过\n\n\n\n\n\n\n\n提示\n注意，使用构造函数 Boolean 创造的对象不是布尔值：\n\nlet createByNewBoolean: boolean &#x3D; new Boolean(1)\n\n&#x2F;&#x2F; 此时会编译报错\n&#x2F;&#x2F; Type &#39;Boolean&#39; is not assignable to type &#39;boolean&#39;.\n&#x2F;&#x2F;   &#39;boolean&#39; is a primitive, but &#39;Boolean&#39; is a wrapper object. Prefer using &#39;boolean&#39; when possible.\n\n事实上 new Boolean() 返回的是一个Boolean对象:\n\n\n\n\n\n\n提示\n直接调用Boolean也可以返回一个boolean类型\nlet createdByBoolean: boolean &#x3D; Boolean(1);\n\n\n\n在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。\n数值使用 number定义数值类型\nlet decLiteral: number &#x3D; 6;\nlet hexLiteral: number &#x3D; 0xf00d;\n&#x2F;&#x2F; ES6 中的二进制表示法\nlet binaryLiteral: number &#x3D; 0b1010;\n&#x2F;&#x2F; ES6 中的八进制表示法\nlet octalLiteral: number &#x3D; 0o744;\nlet notANumber: number &#x3D; NaN;\nlet infinityNumber: number &#x3D; Infinity;\n\ntsc的编译结果\nvar decLiteral &#x3D; 6;\nvar hexLiteral &#x3D; 0xf00d;\n&#x2F;&#x2F; ES6 中的二进制表示法\nvar binaryLiteral &#x3D; 10;\n&#x2F;&#x2F; ES6 中的八进制表示法\nvar octalLiteral &#x3D; 484;\nvar notANumber &#x3D; NaN;\nvar infinityNumber &#x3D; Infinity;\n\n其中 0b1010 和 0o744 是 ES6 中的二进制和八进制表示法，它们会被编译为十进制数字。\n字符串使用 string定义字符串类型\nlet str: string &#x3D; &#39;jeck&#39;\n\n&#x2F;&#x2F; 模板字符串\nlet str_o: string &#x3D; &#96;my name is $&#123;str&#125;&#96;\n\n编译结果:\nvar str &#x3D; jeck\n\n&#x2F;&#x2F; 模板字符串\nvar str_o &#x3D; &#39;my name is&#39; + str\n\n空值JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：\nfunction alertName(): void &#123;\n    alert(&#39;My name is Tom&#39;);\n&#125;\n\n声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null（只在 –strictNullChecks 未指定时）：\nlet unusable: void &#x3D; undefined;\n\nNull 和 Undefined在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：\nlet u: undefined &#x3D; undefined;\nlet n: null &#x3D; null;\n\n\n\n\n\n\n\n\n\n\n与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：\n&#x2F;&#x2F; 这样不会报错\nlet num: number &#x3D; undefined;\n\n&#x2F;&#x2F; 这样也不会报错\nlet u: undefined;\nlet num: number &#x3D; u;\n\n而 void 类型的变量不能赋值给 number 类型的变量：\nlet u: void;\nlet num: number &#x3D; u;\n\n&#x2F;&#x2F; Type &#39;void&#39; is not assignable to type &#39;number&#39;.\n\n参考\nBasic Types（中文版）\nPrimitive data types\nES6 中的新类型 Symbol\nES6 中的二进制和八进制表示法\nES6 中的模板字符串\n\n","slug":"typescript/基础/原始数据类型","date":"2023-01-05T02:23:28.205Z","categories_index":"TypeScript入门","tags_index":"TypeScript,基础","author_index":"木木木"},{"id":"1e85ed2976471a124c7c5c4dd3f1cabd","title":"Docker 镜像的使用","content":"列出镜像列表我们可以使用 docker images 来列出本地主机上的镜像\n$ docker images\n\n选项说明\nREPOSITORY: 表示镜像的仓库源\nTAG:　镜像的标签\nIMAGE ID: 镜像ID\nCREATED: 镜像的创建时间\nSIZE: 镜像大小\n\n\n\n\n\n\n\n\n同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。\n\n\n获取一个新的镜像当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。\ndocker pull centos:8\n当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。\n查找镜像我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： https://hub.docker.com/我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。\n$ docker search httpd\n\n选项说明\nNAME: 镜像仓库源名称\nDESCRIPTION: 镜像的描述\nOFFICIAL: 是否 docker 官方发布\nSTARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。\nAUTOMATED: 自动构建。拖取镜像$ docker pull httpd\n下载完后我们就可以使用这个镜像了$ docker run httpd\n删除镜像$ docker rmi httpd\n\n","slug":"docker/Docker 镜像的使用","date":"2023-01-03T07:15:43.000Z","categories_index":"Docker","tags_index":"Docker,镜像,images","author_index":"木木木"},{"id":"dc1fbac9dbffcd89c2c867f0e7ab4b37","title":"Docker 容器的使用","content":"网络端口映射有以下两种端口映射方式\ndocker run -itd -P --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash\ndocker run -itd -p 1000:22 --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash\n参数说明\n-i：交互式操作\n\n-t: 终端\n\n-d: 后台运行\n\n-p 1000:22 :以指定的1000端口映射容器的22端口\n\n-P: 容器内部端口随机映射到主机端口\n\n–name: 容器别名\n\ndokken/centos-8: 容器源名称\n\n/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n区别\n-P :是容器内部端口随机映射到主机的端口。\n\n-p : 是容器内部端口绑定到指定的主机端口。\n\n\n另外, 我们可以指定容器绑定的网络地址, 比如绑定 127.0.0.1\ndocker run -itd -p 127.0.0.1:1000:22 --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash\n这样我们就可以通过127.0.0.1:1000来访问容器的22端口了\n","slug":"docker/Docker 容器连接","date":"2023-01-03T07:13:50.000Z","categories_index":"Docker","tags_index":"Docker,容器,container","author_index":"木木木"},{"id":"dc1fbac9dbffcd89c2c867f0e7ab4b37","title":"Docker 容器的使用","content":"获取容器我们可以使用docker pull 命令来下载 centos镜像\n$ docker pull centos8\n启动容器$ docker run -it centos8 &#x2F;bin&#x2F;bash\n参数说明\n-i：交互式操作\n-t: 终端\ncentos8：centos8镜像\n/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n\n如果要退出终端那就使用\n$ exit\n查看所有容器$ docker ps -a\n启动一个已经停止的容器$ docker start b750bbbcfd88(容器id)\n停止一个已经启动的容器$ docker stop b750bbbcfd88(容器id)\n后台运行容器(不想进入容器的时候)$ docker -itd --name content_8 centos8 &#x2F;bin&#x2F;bash\n参数说明\n-i：交互式操作\n\n-t: 终端\n\n-d: 后台运行\n\n–name: 运行时指定容器的名称\n\n/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n进入容器在使用参数 -d 时, 容器会进入后台, 这个时候如果想要进入容器内部可以使用以下命令\n$ docker exec -it [容器ID] &#x2F;bin&#x2F;bash\n参数说明\n-i：交互式操作\n\n-t: 终端\n\n/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n导入和导出容器导出容器如果要导出到本地的某个容器, 可以使用 docker export 命令\n$ docker export [容器ID] &gt; centos8.tar\n\n\n\n\n\n\n\n\n\n导出容器ID到本地文件的 centos8.tar\n\n\n导入容器$ cat docker&#x2F;ubuntu.tar | docker import - test&#x2F;ubuntu:v1\n此外, 还可以通过指定URL或某个目录来导入\n$ docker import http:&#x2F;&#x2F;example.com&#x2F;exampleimage.tgz example&#x2F;imagerepo\n删除容器$ docker rm -f [容器ID]\n清除所有处于终止状态下的容器\n$ docker container prune\n\n","slug":"docker/Docker 容器的使用","date":"2022-12-06T08:00:12.000Z","categories_index":"Docker","tags_index":"Docker,容器,container","author_index":"木木木"},{"id":"38e6c7f2663dfaf0d43db7ca2bc52b5c","title":"webpack 创建简单的 ts 开发环境","content":"webpack 创建简单的 ts 开发环境前置要求需要的的 npm 插件\n\n\n\n\n\n\n\n\n\n\nwebpack ( webpack 本体 )\nwebpack-cli ( webpack 的命令行工具 )\ntypescript ( typescript 核心代码 )\nts-loader (typescript 的 webpck 编译模块)\nclean-webpack-plugin ( 打包前清除之前打包的文件夹 )\n\nts 开发环境目录\ntsconfig.json 配置&#123;\n  &quot;compilerOptions&quot;: &#123;\n\n    &quot;module&quot;: &quot;ES6&quot;,             &#x2F;&#x2F; 使用的模块规则\n\n    &quot;target&quot;: &quot;ES6&quot;,             &#x2F;&#x2F; 编译生成 js 的版本\n\n    &quot;noImplicitAny&quot;: true,       &#x2F;&#x2F; 不允许隐式的 any 类型\n\n    &quot;removeComments&quot;: true,      &#x2F;&#x2F; 删除注释\n\n    &quot;preserveConstEnums&quot;: true,  &#x2F;&#x2F; 保留 const 和 enum 声明\n\n    &quot;strict&quot;: true               &#x2F;&#x2F; 使用严格模式\n  &#125;,\n\n  &#x2F;&#x2F; 需要编译的 ts 文件\n  &quot;include&quot;: [\n    &quot;.&#x2F;src&#x2F;**&#x2F;*&quot;\n  ]\n&#125;\n\nwebpack.config.js 配置基本配置const path &#x3D; require(&quot;path&quot;)\nconst &#123; CleanWebpackPlugin &#125; &#x3D; require(&quot;clean-webpack-plugin&quot;)\n\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; 入口文件\n  entry: &quot;.&#x2F;src&#x2F;index.ts&quot;,\n\n  &#x2F;&#x2F; 打包后的出口文件\n  output: &#123;\n    &#x2F;&#x2F; 文件路径\n    path: path.resolve(__dirname, &quot;dist&quot;),\n\n    &#x2F;&#x2F; 文件名\n    filename: &quot;bundle.js&quot;,\n  &#125;,\n  &#x2F;&#x2F; 使用的编译模块\n  module: &#123;\n\n    &#x2F;&#x2F; 指定要加载的规则\n    rules: [\n      &#123;\n        &#x2F;&#x2F; test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n        test: &#x2F;\\.ts$&#x2F;,\n\n        &#x2F;&#x2F; 要使用的 loader\n        use: [&#39;ts-loader&#39;],\n\n        &#x2F;&#x2F; 排除要编译的文件夹\n        exclude: &#x2F;node_modules&#x2F;\n      &#125;\n    ]\n  &#125;,\n\n  &#x2F;&#x2F; 用来设置需要引用的模块文件 (这里包括了 ts 和 js) 不设置的话, 引用其他 ts&#x2F;js 文件会编译报错\n  resolve: &#123;\n    extensions: [&#39;.ts&#39;, &#39;.js&#39;]\n  &#125;,\n\n  &#x2F;&#x2F; 配置 webpack 插件\n  plugins: [\n    new CleanWebpackPlugin()\n  ],\n&#125;\n\n使用 html 文件配置\n\n\n\n\n\n\n\n\n前端项目中我们编译完的 js 文件最终会用到 html 文件中. 我们手动创建并引入 js 的话也不是不行, 但是很麻烦, 如果以后要增加一些其他的 js 或者 css 都得重新去手动引入. 这时候就可以用 webpack 给我们提供的一个自动引入经过 loader 编译后的文件 html 的插件 html-webpack-plugin\n**_npm install -D html-webpack-plugin_**\n在最外层的 plugins 中配置\n更多 html-webpack-plugin 的配置信息看这里\n&#x2F;&#x2F; 引入插件\nconst HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;)\n\nmodule.exprots &#x3D; &#123;\n  &#x2F;&#x2F; 配置 webpack 插件\n  plugins: [\n    new HtmlWebpackPlugin(&#123;\n      &#x2F;&#x2F; 配置 html 模板文件的目录\n      template: path.resolve(__dirname, &#39;public&#x2F;index.html&#39;)\n    &#125;)\n  ],\n&#125;\n\n使用 webpack-server 实时编译\n\n\n\n\n\n\n\n\n弄好 html 自动引入后我们需要打开网页去调试我们的 ts 程序, 按照普通方式来修改一次又要打包一遍, 又要重新刷新一遍网页的话就很麻烦, 这时我们可以用 webpack-server 来进行开发服务器部署\n**_npm install -D webpack-server_**\n安装完后直接在 package.json 中进行配置运行命令运行就行了\n&#123;\n  &quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;webpack server --mode development&quot;\n  &#125;\n&#125;\n\n配置 babel 来进行浏览器兼容在日常的开发中我们会经常遇到要兼容低版本浏览器的需要, 这时候为了增加开发效率我们可以用 **_babel_** 来将一些 **_ES6_** 中的高级属性来转换为低版本浏览器中的兼容属性\n需要的开发依赖\n\n\n\n\n\n\n\n\n\n\n@babel/core ( babel 的核心代码 )\n@babel/preset-env ( babel 的兼容库 )\ncore-js ( 高级属性的兼容性替代方案 )\n\n\n\n\n\n\n\n\n\n\n**_npm install -D @babel/core @babel/preset-env core-js_**\nwebpack 配置\n\nmodule.exports &#x3D; &#123;\n\n  &#x2F;&#x2F; 使用的编译模块\n  module: &#123;\n    &#x2F;&#x2F; 指定要加载的规则\n    rules: [\n      &#123;\n        &#x2F;&#x2F; test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n        test: &#x2F;\\.ts$&#x2F;,\n\n        &#x2F;&#x2F; 要使用的 loader\n        use: [\n\n          &#x2F;&#x2F; 配置 babel\n          &#123;\n            &#x2F;&#x2F; 指定要用的加载器\n            loader: &#39;babel-loader&#39;,\n\n            options: &#123;\n              &#x2F;&#x2F; 设置预定义的环境\n              presets: [\n                [\n                  &quot;@babel-preset-env&quot;,\n\n                  &#123;\n                    &#x2F;&#x2F; 需要兼容的目标浏览器, 根据项目需求填写\n                    targets: &#123;\n                      &quot;chrome&quot;: 95\n                    &#125;,\n\n                    &#x2F;&#x2F; 指定的 core 版本\n                    &quot;corejs&quot;: &#39;3&#39;,\n\n                    &#x2F;&#x2F; 使用 corejs 的方式 &quot;usage&quot; 按需加载\n                    &quot;useBuiltIns&quot;: &quot;usage&quot;\n                  &#125;\n                ]\n              ]\n            &#125;\n          &#125;,\n\n          &#x2F;&#x2F; 由于 webpack 中 rules 是从数组从后往前执行的, 所以 ts-loader 放在后面, 让 ts 先编译为 js 在通过 babel 进行兼容性转换\n          &#39;ts-loader&#39;\n        ],\n      &#125;\n    ]\n  &#125;\n&#125;\n","slug":"typescript/webpack 搭建 ts 开发环境","date":"2022-03-05T08:55:46.000Z","categories_index":"TypeScript","tags_index":"TypeScript,环境搭建,webpack","author_index":"木木木"},{"id":"2eed4986ddc0b5ad3de17ce564c45e28","title":"TypeScript的数据类型","content":"TypeScript的数据类型\n\n\n\n\n\n\n\n\n变量一但定义了某个数据类型后就不允许赋值其他数据类型的数值了\n基础数据类型numberstringbooleanvoidnullundefindedany (使用 TS 时不建议使用 any 类型)&#x2F;&#x2F; 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet d; &lt;&#x3D;&gt; let d: any;\n\n&#x2F;&#x2F; any 类型还可以赋值给任意类型的变量\nlet s: string;\ns &#x3D; d &#x2F;&#x2F; 这时候是成立的\n\nunknown&#x2F;&#x2F; 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet un: unknown;\n\n&#x2F;&#x2F; any 类型还可以赋值给任意类型的变量\nlet s: string;\ns &#x3D; un &#x2F;&#x2F; 这时候是不成立的\n&#x2F;&#x2F; 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n&#x2F;&#x2F; unknown 实际上就是一个类型安全的 any\n&#x2F;&#x2F; unknown 类型的变量不能直接赋值给其他类型的变量,可以间接实现\nif (typeof un &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;\n  s &#x3D; un; &#x2F;&#x2F; 由于先进行了类型判断, 所以这时候赋值是成立的\n&#125;\n\nenum(枚举类型)&#x2F;&#x2F; 使用场景\nenum Gender &#123;\n  male,\n  female\n&#125;\n\nlet p: &#123; name: string, gender: Gender &#125;\np &#x3D; &#123;\n  name: &#39;林丹&#39;,\n  gnder: Gender.male\n&#125;\n\n引用数据类型arrayobject&#x2F;&#x2F; 基础的定义方式\n&#x2F;&#x2F; 由于在 js 中几乎万物皆是对象,所以不推荐这样使用\nlet o: object\no &#x3D; &#123;&#125;\no &#x3D; function\n\n&#x2F;&#x2F; 可以用字面量的方式\nlet o1: &#123; name: string, age: number &#125;\no1 &#x3D; &#123; name: &#39;hanler&#39;, age: 12 &#125;\n\n&#x2F;&#x2F; 如果要可选常数则在常数后面加个问号\nlet o2: &#123; name: string, age?: number &#125;\no2 &#x3D; &#123; name: &#39;hehe&#39; &#125;\n\n&#x2F;&#x2F; 当你需要一个固定值, 但是又需要其他值且不清楚数量的时候可以像以下定义\n&#x2F;**\n * @param &#123;string&#125; propsName 这个是属性名, 后面的 string 代表的是 string 格式的属性名\n * 中括号后面的 string 代表的是属性(propsName)的值的格式\n * *&#x2F;\nlet o3: &#123; name: string, [propsName: string]: string &#125;\no3 &#x3D; &#123; name: &#39;str&#39;, age: &#39;12&#39; &#125;\n\n类型断言\n\n\n\n\n\n\n\n\n可以用来告诉 ts 解析器变量的实际数据类型\nlet un: nuknown;\nun &#x3D; &#39;string&#39;\n\nlet s: string;\n\ns &#x3D; un; &#x2F;&#x2F; 此时是不成立的\n&#x2F;&#x2F; 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n&#x2F;&#x2F; 由于此时的 un 确实是 string 类型,我们可以使用类型断言来告诉解析器 un 就是 string 类型的来解决解析器报错问题\n\n&#x2F;&#x2F; 两种写法\ns &#x3D; un as string;\ns &#x3D; &lt;string&gt;un;\n","slug":"typescript/TypeScript的数据类型","date":"2022-03-05T08:47:36.000Z","categories_index":"TypeScript","tags_index":"TypeScript,数据类型","author_index":"木木木"},{"id":"56833ebc3b5ebf1e1226fc895706e9a1","title":"tsconfig.json 编译配置","content":"tsconfig.json 编译配置&#123;\n  &#x2F;&#x2F; 设置保存文件的时候自动编译，但需要编译器支持。\n  &quot;compileOnSave&quot;: false,\n\n  &#x2F;&#x2F; 编译选项配置\n  &quot;compilerOptions&quot;: &#123;\n    &quot;incremental&quot;: true, &#x2F;&#x2F; TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n\n    &quot;tsBuildInfoFile&quot;: &quot;.&#x2F;buildFile&quot;, &#x2F;&#x2F; 增量编译文件的存储位置\n\n    &quot;diagnostics&quot;: true, &#x2F;&#x2F; 打印诊断信息\n\n    &quot;target&quot;: &quot;ES5&quot;, &#x2F;&#x2F; 目标语言的版本\n\n    &quot;module&quot;: &quot;CommonJS&quot;, &#x2F;&#x2F; 生成代码的模板标准\n\n    &quot;outFile&quot;: &quot;.&#x2F;app.js&quot;, &#x2F;&#x2F; 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置&quot;module&quot;: &quot;AMD&quot;,\n\n    &quot;lib&quot;: [&quot;DOM&quot;, &quot;ES2015&quot;, &quot;ScriptHost&quot;, &quot;ES2019.Array&quot;], &#x2F;&#x2F; TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入&quot;ES2019.Array&quot;,\n\n    &quot;allowJS&quot;: true, &#x2F;&#x2F; 允许编译器编译JS，JSX文件\n\n    &quot;checkJs&quot;: true, &#x2F;&#x2F; 允许在JS文件中报错，通常与allowJS一起使用\n\n    &quot;outDir&quot;: &quot;.&#x2F;dist&quot;, &#x2F;&#x2F; 指定输出目录\n\n    &quot;rootDir&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 指定输出文件目录(用于输出)，用于控制输出目录结构\n\n    &quot;declaration&quot;: true, &#x2F;&#x2F; 生成声明文件，开启后会自动生成声明文件\n\n    &quot;declarationDir&quot;: &quot;.&#x2F;file&quot;, &#x2F;&#x2F; 指定生成声明文件存放目录\n\n    &quot;emitDeclarationOnly&quot;: true, &#x2F;&#x2F; 只生成声明文件，而不会生成js文件\n\n    &quot;sourceMap&quot;: true, &#x2F;&#x2F; 生成目标文件的sourceMap文件\n\n    &quot;inlineSourceMap&quot;: true, &#x2F;&#x2F; 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n\n    &quot;declarationMap&quot;: true, &#x2F;&#x2F; 为声明文件生成sourceMap\n\n    &quot;typeRoots&quot;: [], &#x2F;&#x2F; 声明文件目录，默认时node_modules&#x2F;@types\n\n    &quot;types&quot;: [], &#x2F;&#x2F; 加载的声明文件包\n\n    &quot;removeComments&quot;:true, &#x2F;&#x2F; 删除注释\n\n    &quot;noEmit&quot;: true, &#x2F;&#x2F; 不输出文件,即编译后不会生成任何js文件\n\n    &quot;noEmitOnError&quot;: true, &#x2F;&#x2F; 发送错误时不输出任何文件\n\n    &quot;noEmitHelpers&quot;: true, &#x2F;&#x2F; 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n\n    &quot;importHelpers&quot;: true, &#x2F;&#x2F; 通过tslib引入helper函数，文件必须是模块\n\n    &quot;downlevelIteration&quot;: true, &#x2F;&#x2F; 降级遍历器实现，如果目标源是es3&#x2F;5，那么遍历器会有降级的实现\n\n    &quot;strict&quot;: true, &#x2F;&#x2F; 开启所有严格的类型检查\n\n    &quot;alwaysStrict&quot;: true, &#x2F;&#x2F; 在代码中注入&#39;use strict&#39;\n\n    &quot;noImplicitAny&quot;: true, &#x2F;&#x2F; 不允许隐式的any类型\n\n    &quot;strictNullChecks&quot;: true, &#x2F;&#x2F; 不允许把null、undefined赋值给其他类型的变量\n\n    &quot;strictFunctionTypes&quot;: true, &#x2F;&#x2F; 不允许函数参数双向协变\n\n    &quot;strictPropertyInitialization&quot;: true, &#x2F;&#x2F; 类的实例属性必须初始化\n\n    &quot;strictBindCallApply&quot;: true, &#x2F;&#x2F; 严格的bind&#x2F;call&#x2F;apply检查\n\n    &quot;noImplicitThis&quot;: true, &#x2F;&#x2F; 不允许this有隐式的any类型\n\n    &quot;noUnusedLocals&quot;: true, &#x2F;&#x2F; 检查只声明、未使用的局部变量(只提示不报错)\n\n    &quot;noUnusedParameters&quot;: true, &#x2F;&#x2F; 检查未使用的函数参数(只提示不报错)\n\n    &quot;noFallthroughCasesInSwitch&quot;: true, &#x2F;&#x2F; 防止switch语句贯穿(即如果没有break语句后面不会执行)\n\n    &quot;noImplicitReturns&quot;: true, &#x2F;&#x2F;每个分支都会有返回值\n\n    &quot;esModuleInterop&quot;: true, &#x2F;&#x2F; 允许export&#x3D;导出，由import from 导入\n\n    &quot;allowUmdGlobalAccess&quot;: true, &#x2F;&#x2F; 允许在模块中全局变量的方式访问umd模块\n\n    &quot;moduleResolution&quot;: &quot;node&quot;, &#x2F;&#x2F; 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n\n    &quot;baseUrl&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 解析非相对模块的基地址，默认是当前目录\n\n    &quot;paths&quot;: &#123; &#x2F;&#x2F; 路径映射，相对于baseUrl\n      &#x2F;&#x2F; 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n      &quot;jquery&quot;: [&quot;node_modules&#x2F;jquery&#x2F;dist&#x2F;jquery.min.js&quot;]\n    &#125;,\n\n    &quot;rootDirs&quot;: [&quot;src&quot;,&quot;out&quot;], &#x2F;&#x2F; 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n\n    &quot;listEmittedFiles&quot;: true, &#x2F;&#x2F; 打印输出文件\n\n    &quot;listFiles&quot;: true&#x2F;&#x2F; 打印编译的文件(包括引用的声明文件)\n  &#125;,\n\n  &#x2F;&#x2F; include 属性作用是指定编译需要编译的文件或目录。\n  &quot;include&quot;: [&quot;.&#x2F;src&#x2F;**&#x2F;*&quot;],\n\n  &#x2F;&#x2F; exclude 属性作用是指定编译器需要排除的文件或文件夹。默认排除 node_modules 文件夹下文件。\n  &quot;exclude&quot;: [&quot;.&#x2F;utils&#x2F;**&#x2F;*&quot;],\n\n  &#x2F;&#x2F; extends 属性作用是引入其他配置文件，继承配置。\n  &quot;extends&quot;: &quot;.&#x2F;tsconfig.base.json&quot;,\n\n  &#x2F;&#x2F; files 属性作用是指定需要编译的单个文件列表。 默认包含当前目录和子目录下所有 TypeScript 文件。\n  &quot;files&quot;: [\n    &#x2F;&#x2F; 指定编译文件是src目录下的leo.ts文件\n    &quot;scr&#x2F;leo.ts&quot;\n  ],\n\n  &#x2F;&#x2F; references 属性作用是指定工程引用依赖。\n  &#x2F;&#x2F; 在项目开发中，有时候我们为了方便将前端项目和后端node项目放在同一个目录下开发，两个项目依赖同一个配置文件和通用文件，但我们希望前后端项目进行灵活的分别打包，那么我们可以进行如下配置：\n  &quot;references&quot;: [ &#x2F;&#x2F; 指定依赖的工程\n    &#123;&quot;path&quot;: &quot;.&#x2F;common&quot;&#125;\n  ],\n\n  &#x2F;&#x2F; typeAcquisition 属性作用是设置自动引入库类型定义文件(.d.ts)相关。\n  &#x2F;&#x2F; enable  : 布尔类型，是否开启自动引入库类型定义文件(.d.ts)，默认为 false；\n  &#x2F;&#x2F; include  : 数组类型，允许自动引入的库名，如：[&quot;jquery&quot;, &quot;lodash&quot;]；\n  &#x2F;&#x2F; exculde  : 数组类型，排除的库名。\n  &quot;typeAcquisition&quot;: &#123;\n    &quot;enable&quot;: false,\n    &quot;exclude&quot;: [&quot;jquery&quot;],\n    &quot;include&quot;: [&quot;jest&quot;]\n  &#125;\n&#125;\n","slug":"typescript/tsconfig.json 编译配置","date":"2022-03-05T08:40:02.000Z","categories_index":"TypeScript","tags_index":"TypeScript,tsconfig","author_index":"木木木"}]