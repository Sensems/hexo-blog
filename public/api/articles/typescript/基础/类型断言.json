{"title":"基础 - 类型断言","uid":"1edd776b9215e397a3ff2ca6bed21b52","slug":"typescript/基础/类型断言","date":"2023-01-06T07:14:23.135Z","updated":"2023-01-06T08:29:41.914Z","comments":true,"path":"api/articles/typescript/基础/类型断言.json","keywords":null,"cover":"https://whitelabelcoders.com/app/uploads/18.jpg","content":"<h1 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h1><h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">值 as 类型 \n&#x2F;&#x2F; 或者\n&lt;类型&gt;值</code></pre>\n\n<h2 id=\"类型断言的用途\"><a href=\"#类型断言的用途\" class=\"headerlink\" title=\"类型断言的用途\"></a>类型断言的用途</h2><p>类型断言的常见用途有以下几种</p>\n<h3 id=\"将一个联合类型断言为其中一种\"><a href=\"#将一个联合类型断言为其中一种\" class=\"headerlink\" title=\"将一个联合类型断言为其中一种\"></a>将一个联合类型断言为其中一种</h3><p><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B#%E8%AE%BF%E9%97%AE%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E6%88%96%E6%96%B9%E6%B3%95\">之前提到过</a>，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型中共有的属性或方法</strong>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Cat &#123;\n    name: &#39;mimi;&#39;\n    cry(): void;\n&#125;\n\ninterface Dog &#123;\n    name: &#39;来福&#39;\n    cay(): void;\n&#125;\n\nfunction (fun: Cat | Dog) &#123;\n    return Cat.name\n&#125;</code></pre>\n\n<p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法，比如：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Cat &#123;\n    name: &#39;mimi;&#39;\n    cry(): void;\n&#125;\n\ninterface Dog &#123;\n    name: &#39;来福&#39;\n    run(): void;\n&#125;\n\nfunction (fun: Cat | Dog): boolean &#123;\n    if (typeof fun.cry &#x3D;&#x3D; &#39;function&#39;) return true\n    return false\n&#125;\n&#x2F;&#x2F; index.ts:11:23 - error TS2339: Property &#39;cry&#39; does not exist on type &#39;Cat | Dog&#39;.\n&#x2F;&#x2F;   Property &#39;cry&#39; does not exist on type &#39;Cat&#39;.</code></pre>\n\n<p>上面的例子中，获取 <code>animal.swim</code> 的时候会报错。</p>\n<p>此时可以使用类型断言，将 <code>animal</code> 断言成 <code>Fish</code>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Cat &#123;\n    name: &#39;mimi;&#39;\n    cry(): void;\n&#125;\n\ninterface Dog &#123;\n    name: &#39;来福&#39;\n    run(): void;\n&#125;\n\nfunction (fun: Cat | Dog): boolean &#123;\n    if (typeof (fun.cry as Cat) &#x3D;&#x3D; &#39;function&#39;) return true\n    return false\n&#125;</code></pre>\n\n<p>这样就可以解决访问 <code>animal.swim</code> 时报错的问题了。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误：</p>\n\n</div>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Cat &#123;\n    name: &#39;mimi;&#39;\n    cry(): void;\n&#125;\n\ninterface Dog &#123;\n    name: &#39;来福&#39;\n    run(): void;\n&#125;\n\nfunction dosth (fun: Cat | Dog): boolean &#123;\n    if (typeof (fun.cry as Cat) &#x3D;&#x3D; &#39;function&#39;) return true\n    return false\n&#125;\n\nconst jeck: Dog &#x3D; &#123;\n    name: &#39;哼哈&#39;,\n    run() &#123; console.log(&#39;run&#39;) &#125;\n&#125;\n\ndosth(jeck)\n&#x2F;&#x2F; Uncaught TypeError: fun.cry is not a function&#96;</code></pre>\n\n<p>报错的原因是因为 <code>(fun.cry as Cat)</code> 隐藏了<code>fun</code>为<code>Dog</code>的可能性, 直接将<code>fun</code>断言为了<code>Cat</code>而<code>Cat</code>类型里就没有<code>run</code>方法, 就会导致运行时错误了。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>总之，使用类型断言时一定要格外小心，尽量避免断言后调用方法或引用深层属性，以减少不必要的运行时错误。</p></blockquote>\n<h3 id=\"将一个父类断言为更具体的子类\"><a href=\"#将一个父类断言为更具体的子类\" class=\"headerlink\" title=\"将一个父类断言为更具体的子类\"></a>将一个父类断言为更具体的子类</h3><p>当类之间有继承关系的时候, 类型断言也是很常见的</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class ApiError extends Error &#123;\n    code: number &#x3D; 0\n&#125;\n\nclass HttpError extends Error &#123;\n    statuscode: number &#x3D; 200\n&#125;\n\nfunction isHttpError (error: Error) &#123;\n    if (typeof (error as HttpError).statuscode &#x3D; &#39;number&#39;) return true\n    return false\n&#125;</code></pre>\n\n<p>上面的例子中，我们声明了函数 <code>isHttpError</code>，它用来判断传入的参数是不是 <code>HttpError</code> 类型，为了实现这样一个函数，它的参数的类型肯定得是比<code>ApiError</code>和<code>HttpError</code>更抽象的父类 <code>Error</code>，这样的话这个函数就能接受 <code>Error</code> 或它的子类作为参数了。</p>\n<p>但是由于父类 <code>Error</code> 中没有 <code>statuscode</code> 属性，故直接获取 <code>error.statuscode</code> 会报错，需要使用类型断言获取 <code>(error as HttpError).code</code>。</p>\n<p>大家可能会注意到，在这个例子中有一个更合适的方式来判断是不是 <code>HttpError</code>，那就是使用 <code>instanceof</code>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class ApiError extends Error &#123;\n    code: number &#x3D; 0\n&#125;\n\nclass HttpError extends Error &#123;\n    statuscode: number &#x3D; 200\n&#125;\n\nfunction isHttpError (error: Error) &#123;\n    if (error instanceof HttpError) return true\n    return false\n&#125;</code></pre>\n\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>上面的例子中，确实使用 <code>instanceof</code> 更加合适，因为 <code>HttpError</code> 是一个 JavaScript 的类，能够通过 <code>instanceof</code> 来判断 <code>error</code> 是否是它的实例。</p>\n<p>但是有的情况下 <code>ApiError</code> 和 <code>HttpError</code> 不是一个真正的类，而只是一个 TypeScript 的接口（<code>interface</code>），接口是一个类型，不是一个真正的值，它在编译结果中会被删除，当然就无法使用 <code>instanceof</code> 来做运行时判断了</p>\n</p>\n</div>\n<p>此时就只能用类型断言，通过判断是否存在 <code>code</code> 属性，来判断传入的参数是不是 <code>ApiError</code> 了：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface ApiError extends Error &#123;\n    code: number;\n&#125;\ninterface HttpError extends Error &#123;\n    statusCode: number;\n&#125;\n\nfunction isApiError(error: Error) &#123;\n    if (typeof (error as ApiError).code &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;\n        return true;\n    &#125;\n    return false;\n&#125;</code></pre>","feature":true,"text":"类型断言语法值 as 类型 &#x2F;&#x2F; 或者 &lt;类型&gt;值 类型断言的用途类型断言的常见用途有以下几种 将一个联合类型断言为其中一种之前提到过，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型中共有的...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"TypeScript入门","slug":"TypeScript入门","count":9,"path":"api/categories/TypeScript入门.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":12,"path":"api/tags/TypeScript.json"},{"name":"基础","slug":"基础","count":5,"path":"api/tags/基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80\"><span class=\"toc-text\">类型断言</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E7%9A%84%E7%94%A8%E9%80%94\"><span class=\"toc-text\">类型断言的用途</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%86%E4%B8%80%E4%B8%AA%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E4%B8%BA%E5%85%B6%E4%B8%AD%E4%B8%80%E7%A7%8D\"><span class=\"toc-text\">将一个联合类型断言为其中一种</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%86%E4%B8%80%E4%B8%AA%E7%88%B6%E7%B1%BB%E6%96%AD%E8%A8%80%E4%B8%BA%E6%9B%B4%E5%85%B7%E4%BD%93%E7%9A%84%E5%AD%90%E7%B1%BB\"><span class=\"toc-text\">将一个父类断言为更具体的子类</span></a></li></ol></li></ol></li></ol>","author":{"name":"木木木","slug":"blog-author","avatar":"https://homeimage.hoiyee.net/lbs/2023-1-3/ywa8wim0wn_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230103144606.jpg","link":"/","description":"一位正在重塑和新增知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"基础 - 函数的类型","uid":"29afe61d2c425b0032ecc379d9200dbe","slug":"typescript/基础/函数的类型","date":"2023-01-06T02:30:32.294Z","updated":"2023-01-06T07:52:55.847Z","comments":true,"path":"api/articles/typescript/基础/函数的类型.json","keywords":null,"cover":"https://whitelabelcoders.com/app/uploads/18.jpg","text":"函数的类型函数的声明一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单： function sum(x: number, y:number): number &#123; return x + y &#125;...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"TypeScript入门","slug":"TypeScript入门","count":9,"path":"api/categories/TypeScript入门.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":12,"path":"api/tags/TypeScript.json"},{"name":"类型","slug":"类型","count":4,"path":"api/tags/类型.json"},{"name":"函数","slug":"函数","count":1,"path":"api/tags/函数.json"}],"author":{"name":"木木木","slug":"blog-author","avatar":"https://homeimage.hoiyee.net/lbs/2023-1-3/ywa8wim0wn_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230103144606.jpg","link":"/","description":"一位正在重塑和新增知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}