{"title":"基础 - 类型断言","uid":"1edd776b9215e397a3ff2ca6bed21b52","slug":"typescript/基础/类型断言","date":"2023-01-06T07:14:23.135Z","updated":"2023-01-09T08:01:24.690Z","comments":true,"path":"api/articles/typescript/基础/类型断言.json","keywords":null,"cover":"https://whitelabelcoders.com/app/uploads/18.jpg","content":"<h1 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h1><h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">值 as 类型 \n&#x2F;&#x2F; 或者\n&lt;类型&gt;值</code></pre>\n\n<h2 id=\"类型断言的用途\"><a href=\"#类型断言的用途\" class=\"headerlink\" title=\"类型断言的用途\"></a>类型断言的用途</h2><p>类型断言的常见用途有以下几种</p>\n<h3 id=\"将一个联合类型断言为其中一种\"><a href=\"#将一个联合类型断言为其中一种\" class=\"headerlink\" title=\"将一个联合类型断言为其中一种\"></a>将一个联合类型断言为其中一种</h3><p><a href=\"/post/typescript/%E5%9F%BA%E7%A1%80/%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B#%E8%AE%BF%E9%97%AE%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E6%88%96%E6%96%B9%E6%B3%95\">之前提到过</a>，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型中共有的属性或方法</strong>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Cat &#123;\n    name: &#39;mimi;&#39;\n    cry(): void;\n&#125;\n\ninterface Dog &#123;\n    name: &#39;来福&#39;\n    cay(): void;\n&#125;\n\nfunction (fun: Cat | Dog) &#123;\n    return Cat.name\n&#125;</code></pre>\n\n<p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法，比如：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Cat &#123;\n    name: &#39;mimi;&#39;\n    cry(): void;\n&#125;\n\ninterface Dog &#123;\n    name: &#39;来福&#39;\n    run(): void;\n&#125;\n\nfunction (fun: Cat | Dog): boolean &#123;\n    if (typeof fun.cry &#x3D;&#x3D; &#39;function&#39;) return true\n    return false\n&#125;\n&#x2F;&#x2F; index.ts:11:23 - error TS2339: Property &#39;cry&#39; does not exist on type &#39;Cat | Dog&#39;.\n&#x2F;&#x2F;   Property &#39;cry&#39; does not exist on type &#39;Cat&#39;.</code></pre>\n\n<p>上面的例子中，获取 <code>animal.swim</code> 的时候会报错。</p>\n<p>此时可以使用类型断言，将 <code>animal</code> 断言成 <code>Fish</code>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Cat &#123;\n    name: &#39;mimi;&#39;\n    cry(): void;\n&#125;\n\ninterface Dog &#123;\n    name: &#39;来福&#39;\n    run(): void;\n&#125;\n\nfunction (fun: Cat | Dog): boolean &#123;\n    if (typeof (fun.cry as Cat) &#x3D;&#x3D; &#39;function&#39;) return true\n    return false\n&#125;</code></pre>\n\n<p>这样就可以解决访问 <code>animal.swim</code> 时报错的问题了。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误：</p>\n\n</div>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Cat &#123;\n    name: &#39;mimi;&#39;\n    cry(): void;\n&#125;\n\ninterface Dog &#123;\n    name: &#39;来福&#39;\n    run(): void;\n&#125;\n\nfunction dosth (fun: Cat | Dog): boolean &#123;\n    if (typeof (fun.cry as Cat) &#x3D;&#x3D; &#39;function&#39;) return true\n    return false\n&#125;\n\nconst jeck: Dog &#x3D; &#123;\n    name: &#39;哼哈&#39;,\n    run() &#123; console.log(&#39;run&#39;) &#125;\n&#125;\n\ndosth(jeck)\n&#x2F;&#x2F; Uncaught TypeError: fun.cry is not a function&#96;</code></pre>\n\n<p>报错的原因是因为 <code>(fun.cry as Cat)</code> 隐藏了<code>fun</code>为<code>Dog</code>的可能性, 直接将<code>fun</code>断言为了<code>Cat</code>而<code>Cat</code>类型里就没有<code>run</code>方法, 就会导致运行时错误了。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>总之，使用类型断言时一定要格外小心，尽量避免断言后调用方法或引用深层属性，以减少不必要的运行时错误。</p></blockquote>\n<h3 id=\"将一个父类断言为更具体的子类\"><a href=\"#将一个父类断言为更具体的子类\" class=\"headerlink\" title=\"将一个父类断言为更具体的子类\"></a>将一个父类断言为更具体的子类</h3><p>当类之间有继承关系的时候, 类型断言也是很常见的</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class ApiError extends Error &#123;\n    code: number &#x3D; 0\n&#125;\n\nclass HttpError extends Error &#123;\n    statuscode: number &#x3D; 200\n&#125;\n\nfunction isHttpError (error: Error) &#123;\n    if (typeof (error as HttpError).statuscode &#x3D; &#39;number&#39;) return true\n    return false\n&#125;</code></pre>\n\n<p>上面的例子中，我们声明了函数 <code>isHttpError</code>，它用来判断传入的参数是不是 <code>HttpError</code> 类型，为了实现这样一个函数，它的参数的类型肯定得是比<code>ApiError</code>和<code>HttpError</code>更抽象的父类 <code>Error</code>，这样的话这个函数就能接受 <code>Error</code> 或它的子类作为参数了。</p>\n<p>但是由于父类 <code>Error</code> 中没有 <code>statuscode</code> 属性，故直接获取 <code>error.statuscode</code> 会报错，需要使用类型断言获取 <code>(error as HttpError).code</code>。</p>\n<p>大家可能会注意到，在这个例子中有一个更合适的方式来判断是不是 <code>HttpError</code>，那就是使用 <code>instanceof</code>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class ApiError extends Error &#123;\n    code: number &#x3D; 0\n&#125;\n\nclass HttpError extends Error &#123;\n    statuscode: number &#x3D; 200\n&#125;\n\nfunction isHttpError (error: Error) &#123;\n    if (error instanceof HttpError) return true\n    return false\n&#125;</code></pre>\n\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p><p>上面的例子中，确实使用 <code>instanceof</code> 更加合适，因为 <code>HttpError</code> 是一个 JavaScript 的类，能够通过 <code>instanceof</code> 来判断 <code>error</code> 是否是它的实例。</p>\n<p>但是有的情况下 <code>ApiError</code> 和 <code>HttpError</code> 不是一个真正的类，而只是一个 TypeScript 的接口（<code>interface</code>），接口是一个类型，不是一个真正的值，它在编译结果中会被删除，当然就无法使用 <code>instanceof</code> 来做运行时判断了</p>\n</p>\n</div>\n<p>此时就只能用类型断言，通过判断是否存在 <code>code</code> 属性，来判断传入的参数是不是 <code>ApiError</code> 了：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface ApiError extends Error &#123;\n    code: number;\n&#125;\ninterface HttpError extends Error &#123;\n    statusCode: number;\n&#125;\n\nfunction isApiError(error: Error) &#123;\n    if (typeof (error as ApiError).code &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;\n        return true;\n    &#125;\n    return false;\n&#125;</code></pre>\n\n<h3 id=\"将任何一个类型断言为\"><a href=\"#将任何一个类型断言为\" class=\"headerlink\" title=\"将任何一个类型断言为\"></a>将任何一个类型断言为</h3><p>理想情况下，TypeScript 的类型系统运转良好，每个值的类型都具体而精确。</p>\n<p>当我们引用一个在此类型上不存在的属性或方法时，就会报错：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const foo: number &#x3D; 1;\nfoo.length &#x3D; 1;\n\n&#x2F;&#x2F; index.ts:2:5 - error TS2339: Property &#39;length&#39; does not exist on type &#39;number&#39;.</code></pre>\n\n<p>上面的例子中，数字类型的变量 <code>foo</code> 上是没有 <code>length</code> 属性的，故 TypeScript 给出了相应的错误提示。</p>\n<p>这种错误提示显然是非常有用的。</p>\n<p>但有的时候，我们非常确定这段代码不会出错，比如下面这个例子：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">window.foo &#x3D; 1;\n\n&#x2F;&#x2F; index.ts:1:8 - error TS2339: Property &#39;foo&#39; does not exist on type &#39;Window &amp; typeof globalThis&#39;.</code></pre>\n\n<p>上面的例子中，我们需要将 <code>window</code> 上添加一个属性 <code>foo</code>，但 TypeScript 编译时会报错，提示我们 <code>window</code> 上不存在 <code>foo</code> 属性。</p>\n<p>此时我们可以使用 <code>as any</code> 临时将 <code>window</code> 断言为 <code>any</code> 类型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">(window as any).foo &#x3D; 1;</code></pre>\n\n<p>在 <code>any</code> 类型的变量上，访问任何属性都是允许的。</p>\n<p>需要注意的是，将一个变量断言为 <code>any</code> 可以说是解决 TypeScript 中类型问题的最后一个手段。</p>\n<p><strong>它极有可能掩盖了真正的类型错误，所以如果不是非常确定，就不要使用 <code>as any</code>。</strong></p>\n<p>上面的例子中，我们也可以通过[扩展 window 的类型（TODO）][]解决这个错误，不过如果只是临时的增加 <code>foo</code> 属性，<code>as any</code> 会更加方便。</p>\n<p>总之，<strong>一方面不能滥用 <code>as any</code>，另一方面也不要完全否定它的作用，我们需要在类型的严格性和开发的便利性之间掌握平衡</strong>（这也是 <a href=\"https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals\">TypeScript 的设计理念</a>之一），才能发挥出 TypeScript 最大的价值。</p>\n<h3 id=\"将-any-断言为一个具体的类型\"><a href=\"#将-any-断言为一个具体的类型\" class=\"headerlink\" title=\"将 any 断言为一个具体的类型\"></a>将 <code>any</code> 断言为一个具体的类型</h3><p>在日常的开发中，我们不可避免的需要处理 <code>any</code> 类型的变量，它们可能是由于第三方库未能定义好自己的类型，也有可能是历史遗留的或其他人编写的烂代码，还可能是受到 TypeScript 类型系统的限制而无法精确定义类型的场景。</p>\n<p>遇到 <code>any</code> 类型的变量时，我们可以选择无视它，任由它滋生更多的 <code>any</code>。</p>\n<p>我们也可以选择改进它，通过类型断言及时的把 <code>any</code> 断言为精确的类型，亡羊补牢，使我们的代码向着高可维护性的目标发展。</p>\n<p>举例来说，历史遗留的代码中有个 <code>getCacheData</code>，它的返回值是 <code>any</code>：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getCacheData(key: string): any &#123;\n    return (window as any).cache[key];\n&#125;</code></pre>\n\n<p>那么我们在使用它时，最好能够将调用了它之后的返回值断言成一个精确的类型，这样就方便了后续的操作：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getCacheData(key: string): any &#123;\n    return (window as any).cache[key];\n&#125;\n\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst tom &#x3D; getCacheData(&#39;tom&#39;) as Cat;\ntom.run();</code></pre>\n\n<p>上面的例子中，我们调用完 <code>getCacheData</code> 之后，立即将它断言为 <code>Cat</code> 类型。这样的话明确了 <code>tom</code> 的类型，后续对 <code>tom</code> 的访问时就有了代码补全，提高了代码的可维护性。</p>\n<h2 id=\"类型断言的限制\"><a href=\"#类型断言的限制\" class=\"headerlink\" title=\"类型断言的限制\"></a>类型断言的限制</h2><p>从上面的例子中，我们可以总结出：</p>\n<ul>\n<li>联合类型可以被断言为其中一个类型</li>\n<li>父类可以被断言为子类</li>\n<li>任何类型都可以被断言为 any</li>\n<li>any 可以被断言为任何类型</li>\n</ul>\n<p>那么类型断言有没有什么限制呢？是不是任何一个类型都可以被断言为任何另一个类型呢？</p>\n<p>答案是否定的——并不是任何一个类型都可以被断言为任何另一个类型。</p>\n<p>具体来说，若 <code>A</code> 兼容 <code>B</code>，那么 <code>A</code> 能够被断言为 <code>B</code>，<code>B</code> 也能被断言为 <code>A</code>。</p>\n<p>下面我们通过一个简化的例子，来理解类型断言的限制：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n    name: string;\n&#125;\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nlet tom: Cat &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    run: () &#x3D;&gt; &#123; console.log(&#39;run&#39;) &#125;\n&#125;;\nlet animal: Animal &#x3D; tom;</code></pre>\n\n<p>我们知道，TypeScript 是结构类型系统，类型之间的对比只会比较它们最终的结构，而会忽略它们定义时的关系。</p>\n<p>在上面的例子中，<code>Cat</code> 包含了 <code>Animal</code> 中的所有属性，除此之外，它还有一个额外的方法 <code>run</code>。TypeScript 并不关心 <code>Cat</code> 和 <code>Animal</code> 之间定义时是什么关系，而只会看它们最终的结构有什么关系——所以它与 <code>Cat extends Animal</code> 是等价的：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n    name: string;\n&#125;\ninterface Cat extends Animal &#123;\n    run(): void;\n&#125;</code></pre>\n\n<p>那么也不难理解为什么 <code>Cat</code> 类型的 <code>tom</code> 可以赋值给 <code>Animal</code> 类型的 <code>animal</code> 了——就像面向对象编程中我们可以将子类的实例赋值给类型为父类的变量。</p>\n<p>我们把它换成 TypeScript 中更专业的说法，即：<code>Animal</code> 兼容 <code>Cat</code>。</p>\n<p>当 <code>Animal</code> 兼容 <code>Cat</code> 时，它们就可以互相进行类型断言了：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n    name: string;\n&#125;\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nfunction testAnimal(animal: Animal) &#123;\n    return (animal as Cat);\n&#125;\nfunction testCat(cat: Cat) &#123;\n    return (cat as Animal);\n&#125;</code></pre>\n\n<p>这样的设计其实也很容易就能理解：</p>\n<ul>\n<li>允许 <code>animal as Cat</code> 是因为「父类可以被断言为子类」，这个前面已经学习过了</li>\n<li>允许 <code>cat as Animal</code> 是因为既然子类拥有父类的属性和方法，那么被断言为父类，获取父类的属性、调用父类的方法，就不会有任何问题，故「子类可以被断言为父类」</li>\n</ul>\n<p>需要注意的是，这里我们使用了简化的父类子类的关系来表达类型的兼容性，而实际上 TypeScript 在判断类型的兼容性时，比这种情况复杂很多，详细请参考[类型的兼容性（TODO)][]章节。</p>\n<p>总之，若 <code>A</code> 兼容 <code>B</code>，那么 <code>A</code> 能够被断言为 <code>B</code>，<code>B</code> 也能被断言为 <code>A</code>。</p>\n<p>同理，若 <code>B</code> 兼容 <code>A</code>，那么 <code>A</code> 能够被断言为 <code>B</code>，<code>B</code> 也能被断言为 <code>A</code>。</p>\n<p>所以这也可以换一种说法：</p>\n<p>要使得 <code>A</code> 能够被断言为 <code>B</code>，只需要 <code>A</code> 兼容 <code>B</code> 或 <code>B</code> 兼容 <code>A</code> 即可，这也是为了在类型断言时的安全考虑，毕竟毫无根据的断言是非常危险的。</p>\n<p>综上所述：</p>\n<ul>\n<li>联合类型可以被断言为其中一个类型</li>\n<li>父类可以被断言为子类</li>\n<li>任何类型都可以被断言为 any</li>\n<li>any 可以被断言为任何类型</li>\n<li>要使得 <code>A</code> 能够被断言为 <code>B</code>，只需要 <code>A</code> 兼容 <code>B</code> 或 <code>B</code> 兼容 <code>A</code> 即可</li>\n</ul>\n<p>其实前四种情况都是最后一个的特例。</p>\n<h2 id=\"双重断言\"><a href=\"#双重断言\" class=\"headerlink\" title=\"双重断言\"></a>双重断言</h2><p>既然：</p>\n<ul>\n<li>任何类型都可以被断言为 any</li>\n<li>any 可以被断言为任何类型</li>\n</ul>\n<p>那么我们是不是可以使用双重断言 <code>as any as Foo</code> 来将任何一个类型断言为任何另一个类型呢？</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Cat &#123;\n    run(): void;\n&#125;\ninterface Fish &#123;\n    swim(): void;\n&#125;\n\nfunction testCat(cat: Cat) &#123;\n    return (cat as any as Fish);\n&#125;</code></pre>\n\n<p>在上面的例子中，若直接使用 <code>cat as Fish</code> 肯定会报错，因为 <code>Cat</code> 和 <code>Fish</code> 互相都不兼容。</p>\n<p>但是若使用双重断言，则可以打破「要使得 <code>A</code> 能够被断言为 <code>B</code>，只需要 <code>A</code> 兼容 <code>B</code> 或 <code>B</code> 兼容 <code>A</code> 即可」的限制，将任何一个类型断言为任何另一个类型。</p>\n<p>若你使用了这种双重断言，那么十有八九是非常错误的，它很可能会导致运行时错误。</p>\n<p><strong>除非迫不得已，千万别用双重断言。</strong></p>\n<h2 id=\"类型断言VS类型转换\"><a href=\"#类型断言VS类型转换\" class=\"headerlink\" title=\"类型断言VS类型转换\"></a>类型断言VS类型转换</h2><p>类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function toBoolean(something: any): boolean &#123;\n    return something as boolean;\n&#125;\n\ntoBoolean(1);\n&#x2F;&#x2F; 返回值为 1</code></pre>\n\n<p>在上面的例子中，将 <code>something</code> 断言为 <code>boolean</code> 虽然可以通过编译，但是并没有什么用，代码在编译后会变成：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function toBoolean(something) &#123;\n    return something;\n&#125;\n\ntoBoolean(1);\n&#x2F;&#x2F; 返回值为 1</code></pre>\n\n<p>所以类型断言不是类型转换，它不会真的影响到变量的类型。</p>\n<p>若要进行类型转换，需要直接调用类型转换的方法：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function toBoolean(something: any): boolean &#123;\n    return Boolean(something);\n&#125;\n\ntoBoolean(1);\n&#x2F;&#x2F; 返回值为 true</code></pre>\n\n<h2 id=\"类型断言-vs-类型声明\"><a href=\"#类型断言-vs-类型声明\" class=\"headerlink\" title=\"类型断言 vs 类型声明\"></a>类型断言 vs 类型声明</h2><p>在这个例子中：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getCacheData(key: string): any &#123;\n    return (window as any).cache[key];\n&#125;\n\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst tom &#x3D; getCacheData(&#39;tom&#39;) as Cat;\ntom.run();</code></pre>\n\n<p>我们使用 <code>as Cat</code> 将 <code>any</code> 类型断言为了 <code>Cat</code> 类型。</p>\n<p>但实际上还有其他方式可以解决这个问题：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getCacheData(key: string): any &#123;\n    return (window as any).cache[key];\n&#125;\n\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst tom: Cat &#x3D; getCacheData(&#39;tom&#39;);\ntom.run();</code></pre>\n\n<p>上面的例子中，我们通过类型声明的方式，将 <code>tom</code> 声明为 <code>Cat</code>，然后再将 <code>any</code> 类型的 <code>getCacheData(&#39;tom&#39;)</code> 赋值给 <code>Cat</code> 类型的 <code>tom</code>。</p>\n<p>这和类型断言是非常相似的，而且产生的结果也几乎是一样的——<code>tom</code> 在接下来的代码中都变成了 <code>Cat</code> 类型。</p>\n<p>它们的区别，可以通过这个例子来理解：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n    name: string;\n&#125;\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst animal: Animal &#x3D; &#123;\n    name: &#39;tom&#39;\n&#125;;\nlet tom &#x3D; animal as Cat;</code></pre>\n\n<p>在上面的例子中，由于 <code>Animal</code> 兼容 <code>Cat</code>，故可以将 <code>animal</code> 断言为 <code>Cat</code> 赋值给 <code>tom</code>。</p>\n<p>但是若直接声明 <code>tom</code> 为 <code>Cat</code> 类型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Animal &#123;\n    name: string;\n&#125;\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst animal: Animal &#x3D; &#123;\n    name: &#39;tom&#39;\n&#125;;\nlet tom: Cat &#x3D; animal;\n\n&#x2F;&#x2F; index.ts:12:5 - error TS2741: Property &#39;run&#39; is missing in type &#39;Animal&#39; but required in type &#39;Cat&#39;.</code></pre>\n\n<p>则会报错，不允许将 <code>animal</code> 赋值为 <code>Cat</code> 类型的 <code>tom</code>。</p>\n<p>这很容易理解，<code>Animal</code> 可以看作是 <code>Cat</code> 的父类，当然不能将父类的实例赋值给类型为子类的变量。</p>\n<p>深入的讲，它们的核心区别就在于：</p>\n<ul>\n<li><code>animal</code> 断言为 <code>Cat</code>，只需要满足 <code>Animal</code> 兼容 <code>Cat</code> 或 <code>Cat</code> 兼容 <code>Animal</code> 即可</li>\n<li><code>animal</code> 赋值给 <code>tom</code>，需要满足 <code>Cat</code> 兼容 <code>Animal</code> 才行</li>\n</ul>\n<p>但是 <code>Cat</code> 并不兼容 <code>Animal</code>。</p>\n<p>而在前一个例子中，由于 <code>getCacheData(&#39;tom&#39;)</code> 是 <code>any</code> 类型，<code>any</code> 兼容 <code>Cat</code>，<code>Cat</code> 也兼容 <code>any</code>，故</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const tom &#x3D; getCacheData(&#39;tom&#39;) as Cat;</code></pre>\n\n<p>等价于</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">const tom: Cat &#x3D; getCacheData(&#39;tom&#39;);</code></pre>\n\n<p>知道了它们的核心区别，就知道了类型声明是比类型断言更加严格的。</p>\n<p>所以为了增加代码的质量，我们最好优先使用类型声明，这也比类型断言的 <code>as</code> 语法更加优雅。</p>\n<h2 id=\"类型断言-vs-泛型\"><a href=\"#类型断言-vs-泛型\" class=\"headerlink\" title=\"类型断言 vs 泛型\"></a>类型断言 vs 泛型</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>本小节的前置知识点：<a href=\"/post/typescript/%E8%BF%9B%E9%98%B6/%E6%B3%9B%E5%9E%8B\">泛型</a></p></blockquote>\n<p>还是这个例子：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getCacheData(key: string): any &#123;\n    return (window as any).cache[key];\n&#125;\n\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst tom &#x3D; getCacheData(&#39;tom&#39;) as Cat;\ntom.run();</code></pre>\n\n<p>我们还有第三种方式可以解决这个问题，那就是泛型：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function getCacheData&lt;T&gt;(key: string): T &#123;\n    return (window as any).cache[key];\n&#125;\n\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst tom &#x3D; getCacheData&lt;Cat&gt;(&#39;tom&#39;);\ntom.run();</code></pre>\n\n<p>通过给 <code>getCacheData</code> 函数添加了一个泛型 <code>&lt;T&gt;</code>，我们可以更加规范的实现对 <code>getCacheData</code> 返回值的约束，这也同时去除掉了代码中的 <code>any</code>，是最优的一个解决方案。</p>\n<h2 id=\"参考§\"><a href=\"#参考§\" class=\"headerlink\" title=\"参考§\"></a>参考<a href=\"https://ts.xcatliu.com/basics/type-assertion.html#%E5%8F%82%E8%80%83\">§</a></h2><ul>\n<li><a href=\"https://basarat.gitbooks.io/typescript/content/docs/types/type-assertion.html\">TypeScript Deep Dive / Type Assertion</a></li>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types\">Advanced Types # Type Guards and Differentiating Types</a>（[中文版](<a href=\"https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced\">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced</a> Types.html#类型保护与区分类型（type-guards-and-differentiating-types）)）</li>\n<li><a href=\"https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals\">TypeScript 的设计理念</a></li>\n</ul>\n","text":"类型断言语法值 as 类型 &#x2F;&#x2F; 或者 &lt;类型&gt;值 类型断言的用途类型断言的常见用途有以下几种 将一个联合类型断言为其中一种之前提到过，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型中共有的...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"TypeScript入门","slug":"TypeScript入门","count":11,"path":"api/categories/TypeScript入门.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":14,"path":"api/tags/TypeScript.json"},{"name":"基础","slug":"基础","count":6,"path":"api/tags/基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80\"><span class=\"toc-text\">类型断言</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">语法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E7%9A%84%E7%94%A8%E9%80%94\"><span class=\"toc-text\">类型断言的用途</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%86%E4%B8%80%E4%B8%AA%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E4%B8%BA%E5%85%B6%E4%B8%AD%E4%B8%80%E7%A7%8D\"><span class=\"toc-text\">将一个联合类型断言为其中一种</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%86%E4%B8%80%E4%B8%AA%E7%88%B6%E7%B1%BB%E6%96%AD%E8%A8%80%E4%B8%BA%E6%9B%B4%E5%85%B7%E4%BD%93%E7%9A%84%E5%AD%90%E7%B1%BB\"><span class=\"toc-text\">将一个父类断言为更具体的子类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%86%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E4%B8%BA\"><span class=\"toc-text\">将任何一个类型断言为</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%86-any-%E6%96%AD%E8%A8%80%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%85%B7%E4%BD%93%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">将 any 断言为一个具体的类型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E7%9A%84%E9%99%90%E5%88%B6\"><span class=\"toc-text\">类型断言的限制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E9%87%8D%E6%96%AD%E8%A8%80\"><span class=\"toc-text\">双重断言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80VS%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">类型断言VS类型转换</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80-vs-%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">类型断言 vs 类型声明</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80-vs-%E6%B3%9B%E5%9E%8B\"><span class=\"toc-text\">类型断言 vs 泛型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%C2%A7\"><span class=\"toc-text\">参考</span></a></li></ol></li></ol>","author":{"name":"木木木","slug":"blog-author","avatar":"https://homeimage.hoiyee.net/lbs/2023-1-3/ywa8wim0wn_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230103144606.jpg","link":"/","description":"一位正在重塑和新增知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"CentOS 镜像","uid":"5c52f5f10bab6e186ef547fb5e21cada","slug":"centos/centos镜像","date":"2023-01-09T07:45:49.147Z","updated":"2023-01-10T08:54:46.932Z","comments":true,"path":"api/articles/centos/centos镜像.json","keywords":null,"cover":"https://api.onedrive.com/v1.0/shares/s!AkvcybxHlBS0kABBGGJbNnm15YHO/root/content","text":"CentOS 镜像在线体验基于CentOS快速搭建LAMP环境去体验本教程介绍如何搭建LAMP环境，其中LAMP分别代表Linux、Apache、MySQL和PHP。 简介CentOS，是基于Red Hat Linux提供的可自由使用源代码的企业级Linux发行版本；是一个稳定，...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"Centos","slug":"Centos","count":1,"path":"api/categories/Centos.json"}],"tags":[{"name":"Centos","slug":"Centos","count":1,"path":"api/tags/Centos.json"},{"name":"镜像","slug":"镜像","count":2,"path":"api/tags/镜像.json"}],"author":{"name":"木木木","slug":"blog-author","avatar":"https://homeimage.hoiyee.net/lbs/2023-1-3/ywa8wim0wn_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230103144606.jpg","link":"/","description":"一位正在重塑和新增知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"基础 - 函数的类型","uid":"29afe61d2c425b0032ecc379d9200dbe","slug":"typescript/基础/函数的类型","date":"2023-01-06T02:30:32.294Z","updated":"2023-01-10T06:36:31.425Z","comments":true,"path":"api/articles/typescript/基础/函数的类型.json","keywords":null,"cover":"https://whitelabelcoders.com/app/uploads/18.jpg","text":"函数的类型函数的声明一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单： function sum(x: number, y:number): number &#123; return x + y &#125;...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"TypeScript入门","slug":"TypeScript入门","count":11,"path":"api/categories/TypeScript入门.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":14,"path":"api/tags/TypeScript.json"},{"name":"类型","slug":"类型","count":4,"path":"api/tags/类型.json"},{"name":"函数","slug":"函数","count":1,"path":"api/tags/函数.json"}],"author":{"name":"木木木","slug":"blog-author","avatar":"https://homeimage.hoiyee.net/lbs/2023-1-3/ywa8wim0wn_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230103144606.jpg","link":"/","description":"一位正在重塑和新增知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}