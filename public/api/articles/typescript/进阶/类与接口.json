{"title":"进阶 - 类与接口","uid":"d98d9110fe663f18e58e01638df35f52","slug":"typescript/进阶/类与接口","date":"2023-01-13T06:23:15.936Z","updated":"2023-01-13T06:24:52.045Z","comments":true,"path":"api/articles/typescript/进阶/类与接口.json","keywords":null,"cover":"https://api.onedrive.com/v1.0/shares/s!AkvcybxHlBS0kAEgrAsbNR5Gj39i/root/content","content":"<h1 id=\"类与接口\"><a href=\"#类与接口\" class=\"headerlink\" title=\"类与接口\"></a>类与接口</h1><p><a href=\"https://ts.xcatliu.com/basics/type-of-object-interfaces.html\">之前学习过</a>，接口（Interfaces）可以用于对「对象的形状（Shape）」进行描述。</p>\n<p>这一章主要介绍接口的另一个用途，对类的一部分行为进行抽象。</p>\n<h2 id=\"类实现接口\"><a href=\"#类实现接口\" class=\"headerlink\" title=\"类实现接口\"></a>类实现接口</h2><p>实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 <code>implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性。</p>\n<p>举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Alarm &#123;\n    alert(): void;\n&#125;\n\nclass Door &#123;\n&#125;\n\nclass SecurityDoor extends Door implements Alarm &#123;\n    alert() &#123;\n        console.log(&#39;SecurityDoor alert&#39;);\n    &#125;\n&#125;\n\nclass Car implements Alarm &#123;\n    alert() &#123;\n        console.log(&#39;Car alert&#39;);\n    &#125;\n&#125;</code></pre>\n\n<p>一个类可以实现多个接口：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Alarm &#123;\n    alert(): void;\n&#125;\n\ninterface Light &#123;\n    lightOn(): void;\n    lightOff(): void;\n&#125;\n\nclass Car implements Alarm, Light &#123;\n    alert() &#123;\n        console.log(&#39;Car alert&#39;);\n    &#125;\n    lightOn() &#123;\n        console.log(&#39;Car light on&#39;);\n    &#125;\n    lightOff() &#123;\n        console.log(&#39;Car light off&#39;);\n    &#125;\n&#125;</code></pre>\n\n<p>上例中，<code>Car</code> 实现了 <code>Alarm</code> 和 <code>Light</code> 接口，既能报警，也能开关车灯。</p>\n<h2 id=\"接口继承接口\"><a href=\"#接口继承接口\" class=\"headerlink\" title=\"接口继承接口\"></a>接口继承接口</h2><p>接口与接口之间可以是继承关系：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Alarm &#123;\n    alert(): void;\n&#125;\n\ninterface LightableAlarm extends Alarm &#123;\n    lightOn(): void;\n    lightOff(): void;\n&#125;</code></pre>\n\n<p>这很好理解，<code>LightableAlarm</code> 继承了 <code>Alarm</code>，除了拥有 <code>alert</code> 方法之外，还拥有两个新方法 <code>lightOn</code> 和 <code>lightOff</code>。</p>\n<h2 id=\"接口继承类\"><a href=\"#接口继承类\" class=\"headerlink\" title=\"接口继承类\"></a>接口继承类</h2><p>常见的面向对象语言中，接口是不能继承类的，但是在 TypeScript 中却是可以的：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class Point &#123;\n    x: number;\n    y: number;\n    constructor(x: number, y: number) &#123;\n        this.x &#x3D; x;\n        this.y &#x3D; y;\n    &#125;\n&#125;\n\ninterface Point3d extends Point &#123;\n    z: number;\n&#125;\n\nlet point3d: Point3d &#x3D; &#123;x: 1, y: 2, z: 3&#125;;</code></pre>\n\n<p>为什么 TypeScript 会支持接口继承类呢？</p>\n<p>实际上，当我们在声明 <code>class Point</code> 时，除了会创建一个名为 <code>Point</code> 的类之外，同时也创建了一个名为 <code>Point</code> 的类型（实例的类型）。</p>\n<p>所以我们既可以将 <code>Point</code> 当做一个类来用（使用 <code>new Point</code> 创建它的实例）：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class Point &#123;\n    x: number;\n    y: number;\n    constructor(x: number, y: number) &#123;\n        this.x &#x3D; x;\n        this.y &#x3D; y;\n    &#125;\n&#125;\n\nconst p &#x3D; new Point(1, 2);</code></pre>\n\n<p>也可以将 <code>Point</code> 当做一个类型来用（使用 <code>: Point</code> 表示参数的类型）：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class Point &#123;\n    x: number;\n    y: number;\n    constructor(x: number, y: number) &#123;\n        this.x &#x3D; x;\n        this.y &#x3D; y;\n    &#125;\n&#125;\n\nfunction printPoint(p: Point) &#123;\n    console.log(p.x, p.y);\n&#125;\n\nprintPoint(new Point(1, 2));</code></pre>\n\n<p>这个例子实际上可以等价于：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class Point &#123;\n    x: number;\n    y: number;\n    constructor(x: number, y: number) &#123;\n        this.x &#x3D; x;\n        this.y &#x3D; y;\n    &#125;\n&#125;\n\ninterface PointInstanceType &#123;\n    x: number;\n    y: number;\n&#125;\n\nfunction printPoint(p: PointInstanceType) &#123;\n    console.log(p.x, p.y);\n&#125;\n\nprintPoint(new Point(1, 2));</code></pre>\n\n<p>上例中我们新声明的 <code>PointInstanceType</code> 类型，与声明 <code>class Point</code> 时创建的 <code>Point</code> 类型是等价的。</p>\n<p>所以回到 <code>Point3d</code> 的例子中，我们就能很容易的理解为什么 TypeScript 会支持接口继承类了：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class Point &#123;\n    x: number;\n    y: number;\n    constructor(x: number, y: number) &#123;\n        this.x &#x3D; x;\n        this.y &#x3D; y;\n    &#125;\n&#125;\n\ninterface PointInstanceType &#123;\n    x: number;\n    y: number;\n&#125;\n\n&#x2F;&#x2F; 等价于 interface Point3d extends PointInstanceType\ninterface Point3d extends Point &#123;\n    z: number;\n&#125;\n\nlet point3d: Point3d &#x3D; &#123;x: 1, y: 2, z: 3&#125;;</code></pre>\n\n<p>当我们声明 <code>interface Point3d extends Point</code> 时，<code>Point3d</code> 继承的实际上是类 <code>Point</code> 的实例的类型。</p>\n<p>换句话说，可以理解为定义了一个接口 <code>Point3d</code> 继承另一个接口 <code>PointInstanceType</code>。</p>\n<p>所以「接口继承类」和「接口继承接口」没有什么本质的区别。</p>\n<p>值得注意的是，<code>PointInstanceType</code> 相比于 <code>Point</code>，缺少了 <code>constructor</code> 方法，这是因为声明 <code>Point</code> 类时创建的 <code>Point</code> 类型是不包含构造函数的。另外，除了构造函数是不包含的，静态属性或静态方法也是不包含的（实例的类型当然不应该包括构造函数、静态属性或静态方法）。</p>\n<p>换句话说，声明 <code>Point</code> 类时创建的 <code>Point</code> 类型只包含其中的实例属性和实例方法：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class Point &#123;\n    &#x2F;** 静态属性，坐标系原点 *&#x2F;\n    static origin &#x3D; new Point(0, 0);\n    &#x2F;** 静态方法，计算与原点距离 *&#x2F;\n    static distanceToOrigin(p: Point) &#123;\n        return Math.sqrt(p.x * p.x + p.y * p.y);\n    &#125;\n    &#x2F;** 实例属性，x 轴的值 *&#x2F;\n    x: number;\n    &#x2F;** 实例属性，y 轴的值 *&#x2F;\n    y: number;\n    &#x2F;** 构造函数 *&#x2F;\n    constructor(x: number, y: number) &#123;\n        this.x &#x3D; x;\n        this.y &#x3D; y;\n    &#125;\n    &#x2F;** 实例方法，打印此点 *&#x2F;\n    printPoint() &#123;\n        console.log(this.x, this.y);\n    &#125;\n&#125;\n\ninterface PointInstanceType &#123;\n    x: number;\n    y: number;\n    printPoint(): void;\n&#125;\n\nlet p1: Point;\nlet p2: PointInstanceType;</code></pre>\n\n<p>上例中最后的类型 <code>Point</code> 和类型 <code>PointInstanceType</code> 是等价的。</p>\n<p>同样的，在接口继承类的时候，也只会继承它的实例属性和实例方法。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/interfaces.html\">Interfaces</a>（<a href=\"https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Interfaces.html\">中文版</a>）</li>\n</ul>\n","text":"类与接口之前学习过，接口（Interfaces）可以用于对「对象的形状（Shape）」进行描述。 这一章主要介绍接口的另一个用途，对类的一部分行为进行抽象。 类实现接口实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"TypeScript入门","slug":"TypeScript入门","count":19,"path":"api/categories/TypeScript入门.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":23,"path":"api/tags/TypeScript.json"},{"name":"进阶","slug":"进阶","count":8,"path":"api/tags/进阶.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">类与接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">类实现接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">接口继承接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E7%B1%BB\"><span class=\"toc-text\">接口继承类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol></li></ol>","author":{"name":"木木木","slug":"blog-author","avatar":"https://homeimage.hoiyee.net/lbs/2023-1-3/ywa8wim0wn_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230103144606.jpg","link":"/","description":"一位正在重塑和新增知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"进阶 - 泛型","uid":"d6f1b6e982ce476d664aab7cf5051e90","slug":"typescript/进阶/泛型","date":"2023-01-13T06:55:07.240Z","updated":"2023-01-13T07:12:32.840Z","comments":true,"path":"api/articles/typescript/进阶/泛型.json","keywords":null,"cover":"https://api.onedrive.com/v1.0/shares/s!AkvcybxHlBS0kAEgrAsbNR5Gj39i/root/content","text":"泛型泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 简单的例子首先，我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值： function createArra...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"TypeScript入门","slug":"TypeScript入门","count":19,"path":"api/categories/TypeScript入门.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":23,"path":"api/tags/TypeScript.json"},{"name":"进阶","slug":"进阶","count":8,"path":"api/tags/进阶.json"}],"author":{"name":"木木木","slug":"blog-author","avatar":"https://homeimage.hoiyee.net/lbs/2023-1-3/ywa8wim0wn_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230103144606.jpg","link":"/","description":"一位正在重塑和新增知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"进阶 - 类","uid":"9f43aa5c8aeb36a61685f7ea1f1e54fa","slug":"typescript/进阶/类","date":"2023-01-13T06:12:38.033Z","updated":"2023-01-13T06:24:26.913Z","comments":true,"path":"api/articles/typescript/进阶/类.json","keywords":null,"cover":"https://api.onedrive.com/v1.0/shares/s!AkvcybxHlBS0kAEgrAsbNR5Gj39i/root/content","text":"类传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承。而在 ES6 中，我们终于迎来了 class。 TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。 这一节主要介绍类的用法，下一节再介绍如何定义类的类型。 类的概...","link":"","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[{"name":"TypeScript入门","slug":"TypeScript入门","count":19,"path":"api/categories/TypeScript入门.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":23,"path":"api/tags/TypeScript.json"},{"name":"进阶","slug":"进阶","count":8,"path":"api/tags/进阶.json"}],"author":{"name":"木木木","slug":"blog-author","avatar":"https://homeimage.hoiyee.net/lbs/2023-1-3/ywa8wim0wn_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230103144606.jpg","link":"/","description":"一位正在重塑和新增知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}