{"title":"进阶 - 类","uid":"9f43aa5c8aeb36a61685f7ea1f1e54fa","slug":"typescript/进阶/类","date":"2023-01-13T06:12:38.033Z","updated":"2023-01-13T06:24:26.913Z","comments":true,"path":"api/articles/typescript/进阶/类.json","keywords":null,"cover":"https://api.onedrive.com/v1.0/shares/s!AkvcybxHlBS0kAEgrAsbNR5Gj39i/root/content","content":"<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><p>传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承。而在 ES6 中，我们终于迎来了 <code>class</code>。</p>\n<p>TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。</p>\n<p>这一节主要介绍类的用法，下一节再介绍如何定义类的类型。</p>\n<h2 id=\"类的概念\"><a href=\"#类的概念\" class=\"headerlink\" title=\"类的概念\"></a>类的概念</h2><p>虽然 JavaScript 中有类的概念，但是可能大多数 JavaScript 程序员并不是非常熟悉类，这里对类相关的概念做一个简单的介绍。</p>\n<ul>\n<li>类（Class）：定义了一件事物的抽象特点，包含它的属性和方法</li>\n<li>对象（Object）：类的实例，通过 <code>new</code> 生成</li>\n<li>面向对象（OOP）的三大特性：封装、继承、多态</li>\n<li>封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</li>\n<li>继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li>\n<li>多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 <code>Cat</code> 和 <code>Dog</code> 都继承自 <code>Animal</code>，但是分别实现了自己的 <code>eat</code> 方法。此时针对某一个实例，我们无需了解它是 <code>Cat</code> 还是 <code>Dog</code>，就可以直接调用 <code>eat</code> 方法，程序会自动判断出来应该如何执行 <code>eat</code></li>\n<li>存取器（getter &amp; setter）：用以改变属性的读取和赋值行为</li>\n<li>修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 <code>public</code> 表示公有属性或方法</li>\n<li>抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li>\n<li>接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口</li>\n</ul>\n<h2 id=\"ES6-中类的用法\"><a href=\"#ES6-中类的用法\" class=\"headerlink\" title=\"ES6 中类的用法\"></a>ES6 中类的用法</h2><p>下面我们先回顾一下 ES6 中类的用法，更详细的介绍可以参考 <a href=\"http://es6.ruanyifeng.com/#docs/class\">ECMAScript 6 入门 - Class</a>。</p>\n<h3 id=\"属性和方法\"><a href=\"#属性和方法\" class=\"headerlink\" title=\"属性和方法\"></a>属性和方法</h3><p>使用 <code>class</code> 定义类，使用 <code>constructor</code> 定义构造函数。</p>\n<p>通过 <code>new</code> 生成新实例的时候，会自动调用构造函数。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Animal &#123;\n    public name;\n    constructor(name) &#123;\n        this.name &#x3D; name;\n    &#125;\n    sayHi() &#123;\n        return &#96;My name is $&#123;this.name&#125;&#96;;\n    &#125;\n&#125;\n\nlet a &#x3D; new Animal(&#39;Jack&#39;);\nconsole.log(a.sayHi()); &#x2F;&#x2F; My name is Jack</code></pre>\n\n<h3 id=\"类的继承\"><a href=\"#类的继承\" class=\"headerlink\" title=\"类的继承\"></a>类的继承</h3><p>使用 <code>extends</code> 关键字实现继承，子类中使用 <code>super</code> 关键字来调用父类的构造函数和方法。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Cat extends Animal &#123;\n  constructor(name) &#123;\n    super(name); &#x2F;&#x2F; 调用父类的 constructor(name)\n    console.log(this.name);\n  &#125;\n  sayHi() &#123;\n    return &#39;Meow, &#39; + super.sayHi(); &#x2F;&#x2F; 调用父类的 sayHi()\n  &#125;\n&#125;\n\nlet c &#x3D; new Cat(&#39;Tom&#39;); &#x2F;&#x2F; Tom\nconsole.log(c.sayHi()); &#x2F;&#x2F; Meow, My name is Tom</code></pre>\n\n<h3 id=\"存取器\"><a href=\"#存取器\" class=\"headerlink\" title=\"存取器\"></a>存取器</h3><p>使用 getter 和 setter 可以改变属性的赋值和读取行为：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Animal &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n  get name() &#123;\n    return &#39;Jack&#39;;\n  &#125;\n  set name(value) &#123;\n    console.log(&#39;setter: &#39; + value);\n  &#125;\n&#125;\n\nlet a &#x3D; new Animal(&#39;Kitty&#39;); &#x2F;&#x2F; setter: Kitty\na.name &#x3D; &#39;Tom&#39;; &#x2F;&#x2F; setter: Tom\nconsole.log(a.name); &#x2F;&#x2F; Jack</code></pre>\n\n<h3 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h3><p>使用 <code>static</code> 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Animal &#123;\n  static isAnimal(a) &#123;\n    return a instanceof Animal;\n  &#125;\n&#125;\n\nlet a &#x3D; new Animal(&#39;Jack&#39;);\nAnimal.isAnimal(a); &#x2F;&#x2F; true\na.isAnimal(a); &#x2F;&#x2F; TypeError: a.isAnimal is not a function</code></pre>\n\n<h2 id=\"ES7-中类的用法\"><a href=\"#ES7-中类的用法\" class=\"headerlink\" title=\"ES7 中类的用法\"></a>ES7 中类的用法</h2><p>ES7 中有一些关于类的提案，TypeScript 也实现了它们，这里做一个简单的介绍。</p>\n<h3 id=\"实例属性\"><a href=\"#实例属性\" class=\"headerlink\" title=\"实例属性\"></a>实例属性</h3><p>ES6 中实例的属性只能通过构造函数中的 <code>this.xxx</code> 来定义，ES7 提案中可以直接在类里面定义：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Animal &#123;\n  name &#x3D; &#39;Jack&#39;;\n\n  constructor() &#123;\n    &#x2F;&#x2F; ...\n  &#125;\n&#125;\n\nlet a &#x3D; new Animal();\nconsole.log(a.name); &#x2F;&#x2F; Jack</code></pre>\n\n<h3 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h3><p>ES7 提案中，可以使用 <code>static</code> 定义一个静态属性：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Animal &#123;\n  static num &#x3D; 42;\n\n  constructor() &#123;\n    &#x2F;&#x2F; ...\n  &#125;\n&#125;\n\nconsole.log(Animal.num); &#x2F;&#x2F; 42</code></pre>\n\n<h2 id=\"TypeScript-中类的用法\"><a href=\"#TypeScript-中类的用法\" class=\"headerlink\" title=\"TypeScript 中类的用法\"></a>TypeScript 中类的用法</h2><h3 id=\"public-private-和-protected\"><a href=\"#public-private-和-protected\" class=\"headerlink\" title=\"public private 和 protected\"></a>public private 和 protected</h3><p>TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 <code>public</code>、<code>private</code> 和 <code>protected</code>。</p>\n<ul>\n<li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code> 的</li>\n<li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li>\n<li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</li>\n</ul>\n<p>下面举一些例子：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class Animal &#123;\n  public name;\n  public constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n&#125;\n\nlet a &#x3D; new Animal(&#39;Jack&#39;);\nconsole.log(a.name); &#x2F;&#x2F; Jack\na.name &#x3D; &#39;Tom&#39;;\nconsole.log(a.name); &#x2F;&#x2F; Tom</code></pre>\n\n<p>上面的例子中，<code>name</code> 被设置为了 <code>public</code>，所以直接访问实例的 <code>name</code> 属性是允许的。</p>\n<p>很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 <code>private</code> 了：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class Animal &#123;\n  private name;\n  public constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n&#125;\n\nlet a &#x3D; new Animal(&#39;Jack&#39;);\nconsole.log(a.name);\na.name &#x3D; &#39;Tom&#39;;\n\n&#x2F;&#x2F; index.ts(9,13): error TS2341: Property &#39;name&#39; is private and only accessible within class &#39;Animal&#39;.\n&#x2F;&#x2F; index.ts(10,1): error TS2341: Property &#39;name&#39; is private and only accessible within class &#39;Animal&#39;.</code></pre>\n\n<p>需要注意的是，TypeScript 编译之后的代码中，并没有限制 <code>private</code> 属性在外部的可访问性。</p>\n<p>上面的例子编译后的代码是：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var Animal &#x3D; (function () &#123;\n  function Animal(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n  return Animal;\n&#125;)();\nvar a &#x3D; new Animal(&#39;Jack&#39;);\nconsole.log(a.name);\na.name &#x3D; &#39;Tom&#39;;</code></pre>\n\n<p>使用 <code>private</code> 修饰的属性或方法，在子类中也是不允许访问的：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class Animal &#123;\n  private name;\n  public constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n&#125;\n\nclass Cat extends Animal &#123;\n  constructor(name) &#123;\n    super(name);\n    console.log(this.name);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; index.ts(11,17): error TS2341: Property &#39;name&#39; is private and only accessible within class &#39;Animal&#39;.</code></pre>\n\n<p>而如果是用 <code>protected</code> 修饰，则允许在子类中访问：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class Animal &#123;\n  protected name;\n  public constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n&#125;\n\nclass Cat extends Animal &#123;\n  constructor(name) &#123;\n    super(name);\n    console.log(this.name);\n  &#125;\n&#125;</code></pre>\n\n<p>当构造函数修饰为 <code>private</code> 时，该类不允许被继承或者实例化：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class Animal &#123;\n  public name;\n  private constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n&#125;\nclass Cat extends Animal &#123;\n  constructor(name) &#123;\n    super(name);\n  &#125;\n&#125;\n\nlet a &#x3D; new Animal(&#39;Jack&#39;);\n\n&#x2F;&#x2F; index.ts(7,19): TS2675: Cannot extend a class &#39;Animal&#39;. Class constructor is marked as private.\n&#x2F;&#x2F; index.ts(13,9): TS2673: Constructor of class &#39;Animal&#39; is private and only accessible within the class declaration.</code></pre>\n\n<p>当构造函数修饰为 <code>protected</code> 时，该类只允许被继承：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class Animal &#123;\n  public name;\n  protected constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n&#125;\nclass Cat extends Animal &#123;\n  constructor(name) &#123;\n    super(name);\n  &#125;\n&#125;\n\nlet a &#x3D; new Animal(&#39;Jack&#39;);\n\n&#x2F;&#x2F; index.ts(13,9): TS2674: Constructor of class &#39;Animal&#39; is protected and only accessible within the class declaration.</code></pre>\n\n<h3 id=\"参数属性-§\"><a href=\"#参数属性-§\" class=\"headerlink\" title=\"参数属性[§]\"></a>参数属性[§]</h3><p>修饰符和<code>readonly</code>还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class Animal &#123;\n  &#x2F;&#x2F; public name: string;\n  public constructor(public name) &#123;\n    &#x2F;&#x2F; this.name &#x3D; name;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"readonly\"><a href=\"#readonly\" class=\"headerlink\" title=\"readonly\"></a>readonly</h3><p>只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class Animal &#123;\n  readonly name;\n  public constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n&#125;\n\nlet a &#x3D; new Animal(&#39;Jack&#39;);\nconsole.log(a.name); &#x2F;&#x2F; Jack\na.name &#x3D; &#39;Tom&#39;;\n\n&#x2F;&#x2F; index.ts(10,3): TS2540: Cannot assign to &#39;name&#39; because it is a read-only property.</code></pre>\n\n<p>注意如果 <code>readonly</code> 和其他访问修饰符同时存在的话，需要写在其后面。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class Animal &#123;\n  &#x2F;&#x2F; public readonly name;\n  public constructor(public readonly name) &#123;\n    &#x2F;&#x2F; this.name &#x3D; name;\n  &#125;\n&#125;</code></pre>\n\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><p><code>abstract</code> 用于定义抽象类和其中的抽象方法。</p>\n<p>什么是抽象类？</p>\n<p>首先，抽象类是不允许被实例化的：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">abstract class Animal &#123;\n  public name;\n  public constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n  public abstract sayHi();\n&#125;\n\nlet a &#x3D; new Animal(&#39;Jack&#39;);\n\n&#x2F;&#x2F; index.ts(9,11): error TS2511: Cannot create an instance of the abstract class &#39;Animal&#39;.</code></pre>\n\n<p>上面的例子中，我们定义了一个抽象类 <code>Animal</code>，并且定义了一个抽象方法 <code>sayHi</code>。在实例化抽象类的时候报错了。</p>\n<p>其次，抽象类中的抽象方法必须被子类实现：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">abstract class Animal &#123;\n  public name;\n  public constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n  public abstract sayHi();\n&#125;\n\nclass Cat extends Animal &#123;\n  public eat() &#123;\n    console.log(&#96;$&#123;this.name&#125; is eating.&#96;);\n  &#125;\n&#125;\n\nlet cat &#x3D; new Cat(&#39;Tom&#39;);\n\n&#x2F;&#x2F; index.ts(9,7): error TS2515: Non-abstract class &#39;Cat&#39; does not implement inherited abstract member &#39;sayHi&#39; from class &#39;Animal&#39;.</code></pre>\n\n<p>上面的例子中，我们定义了一个类 <code>Cat</code> 继承了抽象类 <code>Animal</code>，但是没有实现抽象方法 <code>sayHi</code>，所以编译报错了。</p>\n<p>下面是一个正确使用抽象类的例子：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">abstract class Animal &#123;\n  public name;\n  public constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n  public abstract sayHi();\n&#125;\n\nclass Cat extends Animal &#123;\n  public sayHi() &#123;\n    console.log(&#96;Meow, My name is $&#123;this.name&#125;&#96;);\n  &#125;\n&#125;\n\nlet cat &#x3D; new Cat(&#39;Tom&#39;);</code></pre>\n\n<p>上面的例子中，我们实现了抽象方法 <code>sayHi</code>，编译通过了。</p>\n<p>需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类，上面的代码的编译结果是：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var __extends &#x3D;\n  (this &amp;&amp; this.__extends) ||\n  function (d, b) &#123;\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] &#x3D; b[p];\n    function __() &#123;\n      this.constructor &#x3D; d;\n    &#125;\n    d.prototype &#x3D; b &#x3D;&#x3D;&#x3D; null ? Object.create(b) : ((__.prototype &#x3D; b.prototype), new __());\n  &#125;;\nvar Animal &#x3D; (function () &#123;\n  function Animal(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n  return Animal;\n&#125;)();\nvar Cat &#x3D; (function (_super) &#123;\n  __extends(Cat, _super);\n  function Cat() &#123;\n    _super.apply(this, arguments);\n  &#125;\n  Cat.prototype.sayHi &#x3D; function () &#123;\n    console.log(&#39;Meow, My name is &#39; + this.name);\n  &#125;;\n  return Cat;\n&#125;)(Animal);\nvar cat &#x3D; new Cat(&#39;Tom&#39;);</code></pre>\n\n<h2 id=\"类的类型\"><a href=\"#类的类型\" class=\"headerlink\" title=\"类的类型\"></a>类的类型</h2><p>给类加上 TypeScript 的类型很简单，与接口类似：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class Animal &#123;\n  name: string;\n  constructor(name: string) &#123;\n    this.name &#x3D; name;\n  &#125;\n  sayHi(): string &#123;\n    return &#96;My name is $&#123;this.name&#125;&#96;;\n  &#125;\n&#125;\n\nlet a: Animal &#x3D; new Animal(&#39;Jack&#39;);\nconsole.log(a.sayHi()); &#x2F;&#x2F; My name is Jack</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/classes.html\">Classes</a>（<a href=\"https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Classes.html\">中文版</a>）</li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/class\">ECMAScript 6 入门 - Class</a></li>\n</ul>\n","text":"类传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承。而在 ES6 中，我们终于迎来了 class。 TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。 这一节主要介绍类的用法，下一节再介绍如何定义类的类型。 类的概...","link":"","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[{"name":"TypeScript入门","slug":"TypeScript入门","count":19,"path":"api/categories/TypeScript入门.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":23,"path":"api/tags/TypeScript.json"},{"name":"进阶","slug":"进阶","count":8,"path":"api/tags/进阶.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B1%BB\"><span class=\"toc-text\">类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">类的概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ES6-%E4%B8%AD%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">ES6 中类的用法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">属性和方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">类的继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%8F%96%E5%99%A8\"><span class=\"toc-text\">存取器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">静态方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ES7-%E4%B8%AD%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">ES7 中类的用法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">实例属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">静态属性</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TypeScript-%E4%B8%AD%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">TypeScript 中类的用法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#public-private-%E5%92%8C-protected\"><span class=\"toc-text\">public private 和 protected</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E5%B1%9E%E6%80%A7-%C2%A7\"><span class=\"toc-text\">参数属性[§]</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#readonly\"><span class=\"toc-text\">readonly</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E7%B1%BB\"><span class=\"toc-text\">抽象类</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">类的类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol></li></ol>","author":{"name":"木木木","slug":"blog-author","avatar":"https://homeimage.hoiyee.net/lbs/2023-1-3/ywa8wim0wn_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230103144606.jpg","link":"/","description":"一位正在重塑和新增知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"进阶 - 类与接口","uid":"d98d9110fe663f18e58e01638df35f52","slug":"typescript/进阶/类与接口","date":"2023-01-13T06:23:15.936Z","updated":"2023-01-13T06:24:52.045Z","comments":true,"path":"api/articles/typescript/进阶/类与接口.json","keywords":null,"cover":"https://api.onedrive.com/v1.0/shares/s!AkvcybxHlBS0kAEgrAsbNR5Gj39i/root/content","text":"类与接口之前学习过，接口（Interfaces）可以用于对「对象的形状（Shape）」进行描述。 这一章主要介绍接口的另一个用途，对类的一部分行为进行抽象。 类实现接口实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"TypeScript入门","slug":"TypeScript入门","count":19,"path":"api/categories/TypeScript入门.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":23,"path":"api/tags/TypeScript.json"},{"name":"进阶","slug":"进阶","count":8,"path":"api/tags/进阶.json"}],"author":{"name":"木木木","slug":"blog-author","avatar":"https://homeimage.hoiyee.net/lbs/2023-1-3/ywa8wim0wn_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230103144606.jpg","link":"/","description":"一位正在重塑和新增知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"进阶 - 枚举","uid":"166aa4a154e3566e6dbc6748e810dd70","slug":"typescript/进阶/枚举","date":"2023-01-11T06:19:25.299Z","updated":"2023-01-13T07:12:15.776Z","comments":true,"path":"api/articles/typescript/进阶/枚举.json","keywords":null,"cover":"https://api.onedrive.com/v1.0/shares/s!AkvcybxHlBS0kAEgrAsbNR5Gj39i/root/content","text":"枚举枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。 简单的例子枚举使用 enum 关键字来定义： enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;; 枚举成员会被赋值为从...","link":"","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[{"name":"TypeScript入门","slug":"TypeScript入门","count":19,"path":"api/categories/TypeScript入门.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":23,"path":"api/tags/TypeScript.json"},{"name":"进阶","slug":"进阶","count":8,"path":"api/tags/进阶.json"}],"author":{"name":"木木木","slug":"blog-author","avatar":"https://homeimage.hoiyee.net/lbs/2023-1-3/ywa8wim0wn_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230103144606.jpg","link":"/","description":"一位正在重塑和新增知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}