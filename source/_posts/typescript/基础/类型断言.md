---
title: 基础 - 类型断言
cover: https://whitelabelcoders.com/app/uploads/18.jpg
categories:
  - TypeScript入门
tags:
  - TypeScript
  - 基础
---

# 类型断言

## 语法

```ts
值 as 类型 
// 或者
<类型>值
```

## 类型断言的用途

类型断言的常见用途有以下几种

### 将一个联合类型断言为其中一种

[之前提到过](/post/typescript%2F基础%2F联合类型#访问联合类型的属性或方法)，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们**只能访问此联合类型的所有类型中共有的属性或方法**：

```ts
interface Cat {
    name: 'mimi;'
    cry(): void;
}

interface Dog {
    name: '来福'
    cay(): void;
}

function (fun: Cat | Dog) {
    return Cat.name
}
```

而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法，比如：

```ts
interface Cat {
    name: 'mimi;'
    cry(): void;
}

interface Dog {
    name: '来福'
    run(): void;
}

function (fun: Cat | Dog): boolean {
    if (typeof fun.cry == 'function') return true
    return false
}
// index.ts:11:23 - error TS2339: Property 'cry' does not exist on type 'Cat | Dog'.
//   Property 'cry' does not exist on type 'Cat'.
```

上面的例子中，获取 `animal.swim` 的时候会报错。

此时可以使用类型断言，将 `animal` 断言成 `Fish`：

```ts
interface Cat {
    name: 'mimi;'
    cry(): void;
}

interface Dog {
    name: '来福'
    run(): void;
}

function (fun: Cat | Dog): boolean {
    if (typeof (fun.cry as Cat) == 'function') return true
    return false
}
```

这样就可以解决访问 `animal.swim` 时报错的问题了。

:::tip

需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误：

:::

```ts
interface Cat {
    name: 'mimi;'
    cry(): void;
}

interface Dog {
    name: '来福'
    run(): void;
}

function dosth (fun: Cat | Dog): boolean {
    if (typeof (fun.cry as Cat) == 'function') return true
    return false
}

const jeck: Dog = {
    name: '哼哈',
    run() { console.log('run') }
}

dosth(jeck)
// Uncaught TypeError: fun.cry is not a function`
```

报错的原因是因为 `(fun.cry as Cat)` 隐藏了`fun`为`Dog`的可能性, 直接将`fun`断言为了`Cat`而`Cat`类型里就没有`run`方法, 就会导致运行时错误了。

>总之，使用类型断言时一定要格外小心，尽量避免断言后调用方法或引用深层属性，以减少不必要的运行时错误。

### 将一个父类断言为更具体的子类

当类之间有继承关系的时候, 类型断言也是很常见的

```ts
class ApiError extends Error {
    code: number = 0
}

class HttpError extends Error {
    statuscode: number = 200
}

function isHttpError (error: Error) {
    if (typeof (error as HttpError).statuscode = 'number') return true
    return false
}
```

上面的例子中，我们声明了函数 `isHttpError`，它用来判断传入的参数是不是 `HttpError` 类型，为了实现这样一个函数，它的参数的类型肯定得是比`ApiError`和`HttpError`更抽象的父类 `Error`，这样的话这个函数就能接受 `Error` 或它的子类作为参数了。

但是由于父类 `Error` 中没有 `statuscode` 属性，故直接获取 `error.statuscode` 会报错，需要使用类型断言获取 `(error as HttpError).code`。

大家可能会注意到，在这个例子中有一个更合适的方式来判断是不是 `HttpError`，那就是使用 `instanceof`：

```ts
class ApiError extends Error {
    code: number = 0
}

class HttpError extends Error {
    statuscode: number = 200
}

function isHttpError (error: Error) {
    if (error instanceof HttpError) return true
    return false
}
```

:::tip

上面的例子中，确实使用 `instanceof` 更加合适，因为 `HttpError` 是一个 JavaScript 的类，能够通过 `instanceof` 来判断 `error` 是否是它的实例。

但是有的情况下 `ApiError` 和 `HttpError` 不是一个真正的类，而只是一个 TypeScript 的接口（`interface`），接口是一个类型，不是一个真正的值，它在编译结果中会被删除，当然就无法使用 `instanceof` 来做运行时判断了

:::

此时就只能用类型断言，通过判断是否存在 `code` 属性，来判断传入的参数是不是 `ApiError` 了：

```ts
interface ApiError extends Error {
    code: number;
}
interface HttpError extends Error {
    statusCode: number;
}

function isApiError(error: Error) {
    if (typeof (error as ApiError).code === 'number') {
        return true;
    }
    return false;
}
```