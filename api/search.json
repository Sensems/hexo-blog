[{"id":"bb9a845fbb318ca0c43a367531668643","title":"进阶 - 声明合并","content":"声明合并如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型：\n函数的合并之前学习过，我们可以使用重载定义多个函数类型：\nfunction reverse(x: number): number;\nfunction reverse(x: string): string;\nfunction reverse(x: number | string): number | string &#123;\n    if (typeof x &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;\n        return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));\n    &#125; else if (typeof x &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;\n        return x.split(&#39;&#39;).reverse().join(&#39;&#39;);\n    &#125;\n&#125;\n\n接口的合并接口中的属性在合并时会简单的合并到一个接口中：\ninterface Alarm &#123;\n    price: number;\n&#125;\ninterface Alarm &#123;\n    weight: number;\n&#125;\n\n相当于：\ninterface Alarm &#123;\n    price: number;\n    weight: number;\n&#125;\n\n注意，合并的属性的类型必须是唯一的：\ninterface Alarm &#123;\n    price: number;\n&#125;\ninterface Alarm &#123;\n    price: number;  &#x2F;&#x2F; 虽然重复了，但是类型都是 &#96;number&#96;，所以不会报错\n    weight: number;\n&#125;\ninterface Alarm &#123;\n    price: number;\n&#125;\ninterface Alarm &#123;\n    price: string;  &#x2F;&#x2F; 类型不一致，会报错\n    weight: number;\n&#125;\n\n&#x2F;&#x2F; index.ts(5,3): error TS2403: Subsequent variable declarations must have the same type.  Variable &#39;price&#39; must be of type &#39;number&#39;, but here has type &#39;string&#39;.\n\n接口中方法的合并，与函数的合并一样：\ninterface Alarm &#123;\n    price: number;\n    alert(s: string): string;\n&#125;\ninterface Alarm &#123;\n    weight: number;\n    alert(s: string, n: number): string;\n&#125;\n\n相当于：\ninterface Alarm &#123;\n    price: number;\n    weight: number;\n    alert(s: string): string;\n    alert(s: string, n: number): string;\n&#125;\n\n类的合并类的合并与接口的合并规则一致。\n参考\nDeclaration Merging（[中文版](https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Declaration Merging.html)）\n\n","slug":"typescript/进阶/声明合并","date":"2023-01-13T06:56:55.700Z","categories_index":"TypeScript入门","tags_index":"TypeScript,进阶","author_index":"木木木"},{"id":"d6f1b6e982ce476d664aab7cf5051e90","title":"进阶 - 泛型","content":"泛型泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。\n简单的例子首先，我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值：\nfunction createArray(length: number, value: any): Array&lt;any&gt; &#123;\n    let result &#x3D; [];\n    for (let i &#x3D; 0; i &lt; length; i++) &#123;\n        result[i] &#x3D; value;\n    &#125;\n    return result;\n&#125;\n\ncreateArray(3, &#39;x&#39;); &#x2F;&#x2F; [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]\n\n上例中，我们使用了之前提到过的数组泛型来定义返回值的类型。\n这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：\nArray&lt;any&gt; 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的 value 的类型。\n这时候，泛型就派上用场了：\nfunction createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;\n    let result: T[] &#x3D; [];\n    for (let i &#x3D; 0; i &lt; length; i++) &#123;\n        result[i] &#x3D; value;\n    &#125;\n    return result;\n&#125;\n\ncreateArray&lt;string&gt;(3, &#39;x&#39;); &#x2F;&#x2F; [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]\n\n上例中，我们在函数名后添加了 &lt;T&gt;，其中 T 用来指代任意输入的类型，在后面的输入 value: T 和输出 Array&lt;T&gt; 中即可使用了。\n接着在调用的时候，可以指定它具体的类型为 string。当然，也可以不手动指定，而让类型推论自动推算出来：\nfunction createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;\n    let result: T[] &#x3D; [];\n    for (let i &#x3D; 0; i &lt; length; i++) &#123;\n        result[i] &#x3D; value;\n    &#125;\n    return result;\n&#125;\n\ncreateArray(3, &#39;x&#39;); &#x2F;&#x2F; [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]\n\n多个类型参数定义泛型的时候，可以一次定义多个类型参数：\nfunction swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123;\n    return [tuple[1], tuple[0]];\n&#125;\n\nswap([7, &#39;seven&#39;]); &#x2F;&#x2F; [&#39;seven&#39;, 7]\n\n上例中，我们定义了一个 swap 函数，用来交换输入的元组。\n泛型约束在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：\nfunction loggingIdentity&lt;T&gt;(arg: T): T &#123;\n    console.log(arg.length);\n    return arg;\n&#125;\n\n&#x2F;&#x2F; index.ts(2,19): error TS2339: Property &#39;length&#39; does not exist on type &#39;T&#39;.\n\n上例中，泛型 T 不一定包含属性 length，所以编译的时候报错了。\n这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 length 属性的变量。这就是泛型约束：\ninterface Lengthwise &#123;\n    length: number;\n&#125;\n\nfunction loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;\n    console.log(arg.length);\n    return arg;\n&#125;\n\n上例中，我们使用了 extends 约束了泛型 T 必须符合接口 Lengthwise 的形状，也就是必须包含 length 属性。\n此时如果调用 loggingIdentity 的时候，传入的 arg 不包含 length，那么在编译阶段就会报错了：\ninterface Lengthwise &#123;\n    length: number;\n&#125;\n\nfunction loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;\n    console.log(arg.length);\n    return arg;\n&#125;\n\nloggingIdentity(7);\n\n&#x2F;&#x2F; index.ts(10,17): error TS2345: Argument of type &#39;7&#39; is not assignable to parameter of type &#39;Lengthwise&#39;.\n\n多个类型参数之间也可以互相约束：\nfunction copyFields&lt;T extends U, U&gt;(target: T, source: U): T &#123;\n    for (let id in source) &#123;\n        target[id] &#x3D; (&lt;T&gt;source)[id];\n    &#125;\n    return target;\n&#125;\n\nlet x &#x3D; &#123; a: 1, b: 2, c: 3, d: 4 &#125;;\n\ncopyFields(x, &#123; b: 10, d: 20 &#125;);\n\n上例中，我们使用了两个类型参数，其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段。\n泛型接口之前学习过，可以使用接口的方式来定义一个函数需要符合的形状：\ninterface SearchFunc &#123;\n  (source: string, subString: string): boolean;\n&#125;\n\nlet mySearch: SearchFunc;\nmySearch &#x3D; function(source: string, subString: string) &#123;\n    return source.search(subString) !&#x3D;&#x3D; -1;\n&#125;\n\n当然也可以使用含有泛型的接口来定义函数的形状：\ninterface CreateArrayFunc &#123;\n    &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;\n&#125;\n\nlet createArray: CreateArrayFunc;\ncreateArray &#x3D; function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;\n    let result: T[] &#x3D; [];\n    for (let i &#x3D; 0; i &lt; length; i++) &#123;\n        result[i] &#x3D; value;\n    &#125;\n    return result;\n&#125;\n\ncreateArray(3, &#39;x&#39;); &#x2F;&#x2F; [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]\n\n进一步，我们可以把泛型参数提前到接口名上：\ninterface CreateArrayFunc&lt;T&gt; &#123;\n    (length: number, value: T): Array&lt;T&gt;;\n&#125;\n\nlet createArray: CreateArrayFunc&lt;any&gt;;\ncreateArray &#x3D; function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;\n    let result: T[] &#x3D; [];\n    for (let i &#x3D; 0; i &lt; length; i++) &#123;\n        result[i] &#x3D; value;\n    &#125;\n    return result;\n&#125;\n\ncreateArray(3, &#39;x&#39;); &#x2F;&#x2F; [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]\n\n注意，此时在使用泛型接口的时候，需要定义泛型的类型。\n泛型类与泛型接口类似，泛型也可以用于类的类型定义中：\nclass GenericNumber&lt;T&gt; &#123;\n    zeroValue: T;\n    add: (x: T, y: T) &#x3D;&gt; T;\n&#125;\n\nlet myGenericNumber &#x3D; new GenericNumber&lt;number&gt;();\nmyGenericNumber.zeroValue &#x3D; 0;\nmyGenericNumber.add &#x3D; function(x, y) &#123; return x + y; &#125;;\n\n泛型参数的默认类型在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。\nfunction createArray&lt;T &#x3D; string&gt;(length: number, value: T): Array&lt;T&gt; &#123;\n    let result: T[] &#x3D; [];\n    for (let i &#x3D; 0; i &lt; length; i++) &#123;\n        result[i] &#x3D; value;\n    &#125;\n    return result;\n&#125;\n\n参考\nGenerics（中文版）\nGeneric parameter defaults\n\n","slug":"typescript/进阶/泛型","date":"2023-01-13T06:55:07.240Z","categories_index":"TypeScript入门","tags_index":"TypeScript,进阶","author_index":"木木木"},{"id":"d98d9110fe663f18e58e01638df35f52","title":"进阶 - 类与接口","content":"类与接口之前学习过，接口（Interfaces）可以用于对「对象的形状（Shape）」进行描述。\n这一章主要介绍接口的另一个用途，对类的一部分行为进行抽象。\n类实现接口实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。\n举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它：\ninterface Alarm &#123;\n    alert(): void;\n&#125;\n\nclass Door &#123;\n&#125;\n\nclass SecurityDoor extends Door implements Alarm &#123;\n    alert() &#123;\n        console.log(&#39;SecurityDoor alert&#39;);\n    &#125;\n&#125;\n\nclass Car implements Alarm &#123;\n    alert() &#123;\n        console.log(&#39;Car alert&#39;);\n    &#125;\n&#125;\n\n一个类可以实现多个接口：\ninterface Alarm &#123;\n    alert(): void;\n&#125;\n\ninterface Light &#123;\n    lightOn(): void;\n    lightOff(): void;\n&#125;\n\nclass Car implements Alarm, Light &#123;\n    alert() &#123;\n        console.log(&#39;Car alert&#39;);\n    &#125;\n    lightOn() &#123;\n        console.log(&#39;Car light on&#39;);\n    &#125;\n    lightOff() &#123;\n        console.log(&#39;Car light off&#39;);\n    &#125;\n&#125;\n\n上例中，Car 实现了 Alarm 和 Light 接口，既能报警，也能开关车灯。\n接口继承接口接口与接口之间可以是继承关系：\ninterface Alarm &#123;\n    alert(): void;\n&#125;\n\ninterface LightableAlarm extends Alarm &#123;\n    lightOn(): void;\n    lightOff(): void;\n&#125;\n\n这很好理解，LightableAlarm 继承了 Alarm，除了拥有 alert 方法之外，还拥有两个新方法 lightOn 和 lightOff。\n接口继承类常见的面向对象语言中，接口是不能继承类的，但是在 TypeScript 中却是可以的：\nclass Point &#123;\n    x: number;\n    y: number;\n    constructor(x: number, y: number) &#123;\n        this.x &#x3D; x;\n        this.y &#x3D; y;\n    &#125;\n&#125;\n\ninterface Point3d extends Point &#123;\n    z: number;\n&#125;\n\nlet point3d: Point3d &#x3D; &#123;x: 1, y: 2, z: 3&#125;;\n\n为什么 TypeScript 会支持接口继承类呢？\n实际上，当我们在声明 class Point 时，除了会创建一个名为 Point 的类之外，同时也创建了一个名为 Point 的类型（实例的类型）。\n所以我们既可以将 Point 当做一个类来用（使用 new Point 创建它的实例）：\nclass Point &#123;\n    x: number;\n    y: number;\n    constructor(x: number, y: number) &#123;\n        this.x &#x3D; x;\n        this.y &#x3D; y;\n    &#125;\n&#125;\n\nconst p &#x3D; new Point(1, 2);\n\n也可以将 Point 当做一个类型来用（使用 : Point 表示参数的类型）：\nclass Point &#123;\n    x: number;\n    y: number;\n    constructor(x: number, y: number) &#123;\n        this.x &#x3D; x;\n        this.y &#x3D; y;\n    &#125;\n&#125;\n\nfunction printPoint(p: Point) &#123;\n    console.log(p.x, p.y);\n&#125;\n\nprintPoint(new Point(1, 2));\n\n这个例子实际上可以等价于：\nclass Point &#123;\n    x: number;\n    y: number;\n    constructor(x: number, y: number) &#123;\n        this.x &#x3D; x;\n        this.y &#x3D; y;\n    &#125;\n&#125;\n\ninterface PointInstanceType &#123;\n    x: number;\n    y: number;\n&#125;\n\nfunction printPoint(p: PointInstanceType) &#123;\n    console.log(p.x, p.y);\n&#125;\n\nprintPoint(new Point(1, 2));\n\n上例中我们新声明的 PointInstanceType 类型，与声明 class Point 时创建的 Point 类型是等价的。\n所以回到 Point3d 的例子中，我们就能很容易的理解为什么 TypeScript 会支持接口继承类了：\nclass Point &#123;\n    x: number;\n    y: number;\n    constructor(x: number, y: number) &#123;\n        this.x &#x3D; x;\n        this.y &#x3D; y;\n    &#125;\n&#125;\n\ninterface PointInstanceType &#123;\n    x: number;\n    y: number;\n&#125;\n\n&#x2F;&#x2F; 等价于 interface Point3d extends PointInstanceType\ninterface Point3d extends Point &#123;\n    z: number;\n&#125;\n\nlet point3d: Point3d &#x3D; &#123;x: 1, y: 2, z: 3&#125;;\n\n当我们声明 interface Point3d extends Point 时，Point3d 继承的实际上是类 Point 的实例的类型。\n换句话说，可以理解为定义了一个接口 Point3d 继承另一个接口 PointInstanceType。\n所以「接口继承类」和「接口继承接口」没有什么本质的区别。\n值得注意的是，PointInstanceType 相比于 Point，缺少了 constructor 方法，这是因为声明 Point 类时创建的 Point 类型是不包含构造函数的。另外，除了构造函数是不包含的，静态属性或静态方法也是不包含的（实例的类型当然不应该包括构造函数、静态属性或静态方法）。\n换句话说，声明 Point 类时创建的 Point 类型只包含其中的实例属性和实例方法：\nclass Point &#123;\n    &#x2F;** 静态属性，坐标系原点 *&#x2F;\n    static origin &#x3D; new Point(0, 0);\n    &#x2F;** 静态方法，计算与原点距离 *&#x2F;\n    static distanceToOrigin(p: Point) &#123;\n        return Math.sqrt(p.x * p.x + p.y * p.y);\n    &#125;\n    &#x2F;** 实例属性，x 轴的值 *&#x2F;\n    x: number;\n    &#x2F;** 实例属性，y 轴的值 *&#x2F;\n    y: number;\n    &#x2F;** 构造函数 *&#x2F;\n    constructor(x: number, y: number) &#123;\n        this.x &#x3D; x;\n        this.y &#x3D; y;\n    &#125;\n    &#x2F;** 实例方法，打印此点 *&#x2F;\n    printPoint() &#123;\n        console.log(this.x, this.y);\n    &#125;\n&#125;\n\ninterface PointInstanceType &#123;\n    x: number;\n    y: number;\n    printPoint(): void;\n&#125;\n\nlet p1: Point;\nlet p2: PointInstanceType;\n\n上例中最后的类型 Point 和类型 PointInstanceType 是等价的。\n同样的，在接口继承类的时候，也只会继承它的实例属性和实例方法。\n参考\nInterfaces（中文版）\n\n","slug":"typescript/进阶/类与接口","date":"2023-01-13T06:23:15.936Z","categories_index":"TypeScript入门","tags_index":"TypeScript,进阶","author_index":"木木木"},{"id":"9f43aa5c8aeb36a61685f7ea1f1e54fa","title":"进阶 - 类","content":"类传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承。而在 ES6 中，我们终于迎来了 class。\nTypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。\n这一节主要介绍类的用法，下一节再介绍如何定义类的类型。\n类的概念虽然 JavaScript 中有类的概念，但是可能大多数 JavaScript 程序员并不是非常熟悉类，这里对类相关的概念做一个简单的介绍。\n\n类（Class）：定义了一件事物的抽象特点，包含它的属性和方法\n对象（Object）：类的实例，通过 new 生成\n面向对象（OOP）的三大特性：封装、继承、多态\n封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据\n继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性\n多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat 还是 Dog，就可以直接调用 eat 方法，程序会自动判断出来应该如何执行 eat\n存取器（getter &amp; setter）：用以改变属性的读取和赋值行为\n修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法\n抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现\n接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口\n\nES6 中类的用法下面我们先回顾一下 ES6 中类的用法，更详细的介绍可以参考 ECMAScript 6 入门 - Class。\n属性和方法使用 class 定义类，使用 constructor 定义构造函数。\n通过 new 生成新实例的时候，会自动调用构造函数。\nclass Animal &#123;\n    public name;\n    constructor(name) &#123;\n        this.name &#x3D; name;\n    &#125;\n    sayHi() &#123;\n        return &#96;My name is $&#123;this.name&#125;&#96;;\n    &#125;\n&#125;\n\nlet a &#x3D; new Animal(&#39;Jack&#39;);\nconsole.log(a.sayHi()); &#x2F;&#x2F; My name is Jack\n\n类的继承使用 extends 关键字实现继承，子类中使用 super 关键字来调用父类的构造函数和方法。\nclass Cat extends Animal &#123;\n  constructor(name) &#123;\n    super(name); &#x2F;&#x2F; 调用父类的 constructor(name)\n    console.log(this.name);\n  &#125;\n  sayHi() &#123;\n    return &#39;Meow, &#39; + super.sayHi(); &#x2F;&#x2F; 调用父类的 sayHi()\n  &#125;\n&#125;\n\nlet c &#x3D; new Cat(&#39;Tom&#39;); &#x2F;&#x2F; Tom\nconsole.log(c.sayHi()); &#x2F;&#x2F; Meow, My name is Tom\n\n存取器使用 getter 和 setter 可以改变属性的赋值和读取行为：\nclass Animal &#123;\n  constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n  get name() &#123;\n    return &#39;Jack&#39;;\n  &#125;\n  set name(value) &#123;\n    console.log(&#39;setter: &#39; + value);\n  &#125;\n&#125;\n\nlet a &#x3D; new Animal(&#39;Kitty&#39;); &#x2F;&#x2F; setter: Kitty\na.name &#x3D; &#39;Tom&#39;; &#x2F;&#x2F; setter: Tom\nconsole.log(a.name); &#x2F;&#x2F; Jack\n\n静态方法使用 static 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用：\nclass Animal &#123;\n  static isAnimal(a) &#123;\n    return a instanceof Animal;\n  &#125;\n&#125;\n\nlet a &#x3D; new Animal(&#39;Jack&#39;);\nAnimal.isAnimal(a); &#x2F;&#x2F; true\na.isAnimal(a); &#x2F;&#x2F; TypeError: a.isAnimal is not a function\n\nES7 中类的用法ES7 中有一些关于类的提案，TypeScript 也实现了它们，这里做一个简单的介绍。\n实例属性ES6 中实例的属性只能通过构造函数中的 this.xxx 来定义，ES7 提案中可以直接在类里面定义：\nclass Animal &#123;\n  name &#x3D; &#39;Jack&#39;;\n\n  constructor() &#123;\n    &#x2F;&#x2F; ...\n  &#125;\n&#125;\n\nlet a &#x3D; new Animal();\nconsole.log(a.name); &#x2F;&#x2F; Jack\n\n静态属性ES7 提案中，可以使用 static 定义一个静态属性：\nclass Animal &#123;\n  static num &#x3D; 42;\n\n  constructor() &#123;\n    &#x2F;&#x2F; ...\n  &#125;\n&#125;\n\nconsole.log(Animal.num); &#x2F;&#x2F; 42\n\nTypeScript 中类的用法public private 和 protectedTypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected。\n\npublic 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的\nprivate 修饰的属性或方法是私有的，不能在声明它的类的外部访问\nprotected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的\n\n下面举一些例子：\nclass Animal &#123;\n  public name;\n  public constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n&#125;\n\nlet a &#x3D; new Animal(&#39;Jack&#39;);\nconsole.log(a.name); &#x2F;&#x2F; Jack\na.name &#x3D; &#39;Tom&#39;;\nconsole.log(a.name); &#x2F;&#x2F; Tom\n\n上面的例子中，name 被设置为了 public，所以直接访问实例的 name 属性是允许的。\n很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 private 了：\nclass Animal &#123;\n  private name;\n  public constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n&#125;\n\nlet a &#x3D; new Animal(&#39;Jack&#39;);\nconsole.log(a.name);\na.name &#x3D; &#39;Tom&#39;;\n\n&#x2F;&#x2F; index.ts(9,13): error TS2341: Property &#39;name&#39; is private and only accessible within class &#39;Animal&#39;.\n&#x2F;&#x2F; index.ts(10,1): error TS2341: Property &#39;name&#39; is private and only accessible within class &#39;Animal&#39;.\n\n需要注意的是，TypeScript 编译之后的代码中，并没有限制 private 属性在外部的可访问性。\n上面的例子编译后的代码是：\nvar Animal &#x3D; (function () &#123;\n  function Animal(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n  return Animal;\n&#125;)();\nvar a &#x3D; new Animal(&#39;Jack&#39;);\nconsole.log(a.name);\na.name &#x3D; &#39;Tom&#39;;\n\n使用 private 修饰的属性或方法，在子类中也是不允许访问的：\nclass Animal &#123;\n  private name;\n  public constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n&#125;\n\nclass Cat extends Animal &#123;\n  constructor(name) &#123;\n    super(name);\n    console.log(this.name);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; index.ts(11,17): error TS2341: Property &#39;name&#39; is private and only accessible within class &#39;Animal&#39;.\n\n而如果是用 protected 修饰，则允许在子类中访问：\nclass Animal &#123;\n  protected name;\n  public constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n&#125;\n\nclass Cat extends Animal &#123;\n  constructor(name) &#123;\n    super(name);\n    console.log(this.name);\n  &#125;\n&#125;\n\n当构造函数修饰为 private 时，该类不允许被继承或者实例化：\nclass Animal &#123;\n  public name;\n  private constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n&#125;\nclass Cat extends Animal &#123;\n  constructor(name) &#123;\n    super(name);\n  &#125;\n&#125;\n\nlet a &#x3D; new Animal(&#39;Jack&#39;);\n\n&#x2F;&#x2F; index.ts(7,19): TS2675: Cannot extend a class &#39;Animal&#39;. Class constructor is marked as private.\n&#x2F;&#x2F; index.ts(13,9): TS2673: Constructor of class &#39;Animal&#39; is private and only accessible within the class declaration.\n\n当构造函数修饰为 protected 时，该类只允许被继承：\nclass Animal &#123;\n  public name;\n  protected constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n&#125;\nclass Cat extends Animal &#123;\n  constructor(name) &#123;\n    super(name);\n  &#125;\n&#125;\n\nlet a &#x3D; new Animal(&#39;Jack&#39;);\n\n&#x2F;&#x2F; index.ts(13,9): TS2674: Constructor of class &#39;Animal&#39; is protected and only accessible within the class declaration.\n\n参数属性[§]修饰符和readonly还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。\nclass Animal &#123;\n  &#x2F;&#x2F; public name: string;\n  public constructor(public name) &#123;\n    &#x2F;&#x2F; this.name &#x3D; name;\n  &#125;\n&#125;\n\nreadonly只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。\nclass Animal &#123;\n  readonly name;\n  public constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n&#125;\n\nlet a &#x3D; new Animal(&#39;Jack&#39;);\nconsole.log(a.name); &#x2F;&#x2F; Jack\na.name &#x3D; &#39;Tom&#39;;\n\n&#x2F;&#x2F; index.ts(10,3): TS2540: Cannot assign to &#39;name&#39; because it is a read-only property.\n\n注意如果 readonly 和其他访问修饰符同时存在的话，需要写在其后面。\nclass Animal &#123;\n  &#x2F;&#x2F; public readonly name;\n  public constructor(public readonly name) &#123;\n    &#x2F;&#x2F; this.name &#x3D; name;\n  &#125;\n&#125;\n\n抽象类abstract 用于定义抽象类和其中的抽象方法。\n什么是抽象类？\n首先，抽象类是不允许被实例化的：\nabstract class Animal &#123;\n  public name;\n  public constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n  public abstract sayHi();\n&#125;\n\nlet a &#x3D; new Animal(&#39;Jack&#39;);\n\n&#x2F;&#x2F; index.ts(9,11): error TS2511: Cannot create an instance of the abstract class &#39;Animal&#39;.\n\n上面的例子中，我们定义了一个抽象类 Animal，并且定义了一个抽象方法 sayHi。在实例化抽象类的时候报错了。\n其次，抽象类中的抽象方法必须被子类实现：\nabstract class Animal &#123;\n  public name;\n  public constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n  public abstract sayHi();\n&#125;\n\nclass Cat extends Animal &#123;\n  public eat() &#123;\n    console.log(&#96;$&#123;this.name&#125; is eating.&#96;);\n  &#125;\n&#125;\n\nlet cat &#x3D; new Cat(&#39;Tom&#39;);\n\n&#x2F;&#x2F; index.ts(9,7): error TS2515: Non-abstract class &#39;Cat&#39; does not implement inherited abstract member &#39;sayHi&#39; from class &#39;Animal&#39;.\n\n上面的例子中，我们定义了一个类 Cat 继承了抽象类 Animal，但是没有实现抽象方法 sayHi，所以编译报错了。\n下面是一个正确使用抽象类的例子：\nabstract class Animal &#123;\n  public name;\n  public constructor(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n  public abstract sayHi();\n&#125;\n\nclass Cat extends Animal &#123;\n  public sayHi() &#123;\n    console.log(&#96;Meow, My name is $&#123;this.name&#125;&#96;);\n  &#125;\n&#125;\n\nlet cat &#x3D; new Cat(&#39;Tom&#39;);\n\n上面的例子中，我们实现了抽象方法 sayHi，编译通过了。\n需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类，上面的代码的编译结果是：\nvar __extends &#x3D;\n  (this &amp;&amp; this.__extends) ||\n  function (d, b) &#123;\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] &#x3D; b[p];\n    function __() &#123;\n      this.constructor &#x3D; d;\n    &#125;\n    d.prototype &#x3D; b &#x3D;&#x3D;&#x3D; null ? Object.create(b) : ((__.prototype &#x3D; b.prototype), new __());\n  &#125;;\nvar Animal &#x3D; (function () &#123;\n  function Animal(name) &#123;\n    this.name &#x3D; name;\n  &#125;\n  return Animal;\n&#125;)();\nvar Cat &#x3D; (function (_super) &#123;\n  __extends(Cat, _super);\n  function Cat() &#123;\n    _super.apply(this, arguments);\n  &#125;\n  Cat.prototype.sayHi &#x3D; function () &#123;\n    console.log(&#39;Meow, My name is &#39; + this.name);\n  &#125;;\n  return Cat;\n&#125;)(Animal);\nvar cat &#x3D; new Cat(&#39;Tom&#39;);\n\n类的类型给类加上 TypeScript 的类型很简单，与接口类似：\nclass Animal &#123;\n  name: string;\n  constructor(name: string) &#123;\n    this.name &#x3D; name;\n  &#125;\n  sayHi(): string &#123;\n    return &#96;My name is $&#123;this.name&#125;&#96;;\n  &#125;\n&#125;\n\nlet a: Animal &#x3D; new Animal(&#39;Jack&#39;);\nconsole.log(a.sayHi()); &#x2F;&#x2F; My name is Jack\n\n参考\nClasses（中文版）\nECMAScript 6 入门 - Class\n\n","slug":"typescript/进阶/类","date":"2023-01-13T06:12:38.033Z","categories_index":"TypeScript入门","tags_index":"TypeScript,进阶","author_index":"木木木"},{"id":"166aa4a154e3566e6dbc6748e810dd70","title":"进阶 - 枚举","content":"枚举枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。\n简单的例子枚举使用 enum 关键字来定义：\nenum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;\n\n枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射：\nenum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;\n\nconsole.log(Days[&quot;Sun&quot;] &#x3D;&#x3D;&#x3D; 0); &#x2F;&#x2F; true\nconsole.log(Days[&quot;Mon&quot;] &#x3D;&#x3D;&#x3D; 1); &#x2F;&#x2F; true\nconsole.log(Days[&quot;Tue&quot;] &#x3D;&#x3D;&#x3D; 2); &#x2F;&#x2F; true\nconsole.log(Days[&quot;Sat&quot;] &#x3D;&#x3D;&#x3D; 6); &#x2F;&#x2F; true\n\nconsole.log(Days[0] &#x3D;&#x3D;&#x3D; &quot;Sun&quot;); &#x2F;&#x2F; true\nconsole.log(Days[1] &#x3D;&#x3D;&#x3D; &quot;Mon&quot;); &#x2F;&#x2F; true\nconsole.log(Days[2] &#x3D;&#x3D;&#x3D; &quot;Tue&quot;); &#x2F;&#x2F; true\nconsole.log(Days[6] &#x3D;&#x3D;&#x3D; &quot;Sat&quot;); &#x2F;&#x2F; true\n\n事实上，上面的例子会被编译为：\nvar Days;\n(function (Days) &#123;\n    Days[Days[&quot;Sun&quot;] &#x3D; 0] &#x3D; &quot;Sun&quot;;\n    Days[Days[&quot;Mon&quot;] &#x3D; 1] &#x3D; &quot;Mon&quot;;\n    Days[Days[&quot;Tue&quot;] &#x3D; 2] &#x3D; &quot;Tue&quot;;\n    Days[Days[&quot;Wed&quot;] &#x3D; 3] &#x3D; &quot;Wed&quot;;\n    Days[Days[&quot;Thu&quot;] &#x3D; 4] &#x3D; &quot;Thu&quot;;\n    Days[Days[&quot;Fri&quot;] &#x3D; 5] &#x3D; &quot;Fri&quot;;\n    Days[Days[&quot;Sat&quot;] &#x3D; 6] &#x3D; &quot;Sat&quot;;\n&#125;)(Days || (Days &#x3D; &#123;&#125;));\n\n手动赋值我们也可以给枚举项手动赋值：\nenum Days &#123;Sun &#x3D; 7, Mon &#x3D; 1, Tue, Wed, Thu, Fri, Sat&#125;;\n\nconsole.log(Days[&quot;Sun&quot;] &#x3D;&#x3D;&#x3D; 7); &#x2F;&#x2F; true\nconsole.log(Days[&quot;Mon&quot;] &#x3D;&#x3D;&#x3D; 1); &#x2F;&#x2F; true\nconsole.log(Days[&quot;Tue&quot;] &#x3D;&#x3D;&#x3D; 2); &#x2F;&#x2F; true\nconsole.log(Days[&quot;Sat&quot;] &#x3D;&#x3D;&#x3D; 6); &#x2F;&#x2F; true\n\n上面的例子中，未手动赋值的枚举项会接着上一个枚举项递增。\n如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的：\nenum Days &#123;Sun &#x3D; 3, Mon &#x3D; 1, Tue, Wed, Thu, Fri, Sat&#125;;\n\nconsole.log(Days[&quot;Sun&quot;] &#x3D;&#x3D;&#x3D; 3); &#x2F;&#x2F; true\nconsole.log(Days[&quot;Wed&quot;] &#x3D;&#x3D;&#x3D; 3); &#x2F;&#x2F; true\nconsole.log(Days[3] &#x3D;&#x3D;&#x3D; &quot;Sun&quot;); &#x2F;&#x2F; false\nconsole.log(Days[3] &#x3D;&#x3D;&#x3D; &quot;Wed&quot;); &#x2F;&#x2F; true\n\n上面的例子中，递增到 3 的时候与前面的 Sun 的取值重复了，但是 TypeScript 并没有报错，导致 Days[3] 的值先是 &quot;Sun&quot;，而后又被 &quot;Wed&quot; 覆盖了。编译的结果是：\nvar Days;\n(function (Days) &#123;\n    Days[Days[&quot;Sun&quot;] &#x3D; 3] &#x3D; &quot;Sun&quot;;\n    Days[Days[&quot;Mon&quot;] &#x3D; 1] &#x3D; &quot;Mon&quot;;\n    Days[Days[&quot;Tue&quot;] &#x3D; 2] &#x3D; &quot;Tue&quot;;\n    Days[Days[&quot;Wed&quot;] &#x3D; 3] &#x3D; &quot;Wed&quot;;\n    Days[Days[&quot;Thu&quot;] &#x3D; 4] &#x3D; &quot;Thu&quot;;\n    Days[Days[&quot;Fri&quot;] &#x3D; 5] &#x3D; &quot;Fri&quot;;\n    Days[Days[&quot;Sat&quot;] &#x3D; 6] &#x3D; &quot;Sat&quot;;\n&#125;)(Days || (Days &#x3D; &#123;&#125;));\n\n所以使用的时候需要注意，最好不要出现这种覆盖的情况。\n手动赋值的枚举项可以不是数字，此时需要使用类型断言来让 tsc 无视类型检查 (编译出的 js 仍然是可用的)：\nenum Days &#123;Sun &#x3D; 7, Mon, Tue, Wed, Thu, Fri, Sat &#x3D; &lt;any&gt;&quot;S&quot;&#125;;\nvar Days;\n(function (Days) &#123;\n    Days[Days[&quot;Sun&quot;] &#x3D; 7] &#x3D; &quot;Sun&quot;;\n    Days[Days[&quot;Mon&quot;] &#x3D; 8] &#x3D; &quot;Mon&quot;;\n    Days[Days[&quot;Tue&quot;] &#x3D; 9] &#x3D; &quot;Tue&quot;;\n    Days[Days[&quot;Wed&quot;] &#x3D; 10] &#x3D; &quot;Wed&quot;;\n    Days[Days[&quot;Thu&quot;] &#x3D; 11] &#x3D; &quot;Thu&quot;;\n    Days[Days[&quot;Fri&quot;] &#x3D; 12] &#x3D; &quot;Fri&quot;;\n    Days[Days[&quot;Sat&quot;] &#x3D; &quot;S&quot;] &#x3D; &quot;Sat&quot;;\n&#125;)(Days || (Days &#x3D; &#123;&#125;));\n\n当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 1：\nenum Days &#123;Sun &#x3D; 7, Mon &#x3D; 1.5, Tue, Wed, Thu, Fri, Sat&#125;;\n\nconsole.log(Days[&quot;Sun&quot;] &#x3D;&#x3D;&#x3D; 7); &#x2F;&#x2F; true\nconsole.log(Days[&quot;Mon&quot;] &#x3D;&#x3D;&#x3D; 1.5); &#x2F;&#x2F; true\nconsole.log(Days[&quot;Tue&quot;] &#x3D;&#x3D;&#x3D; 2.5); &#x2F;&#x2F; true\nconsole.log(Days[&quot;Sat&quot;] &#x3D;&#x3D;&#x3D; 6.5); &#x2F;&#x2F; true\n\n常数项和计算所得项枚举项有两种类型：常数项（constant member）和计算所得项（computed member）。\n前面我们所举的例子都是常数项，一个典型的计算所得项的例子：\nenum Color &#123;Red, Green, Blue &#x3D; &quot;blue&quot;.length&#125;;\n\n上面的例子中，&quot;blue&quot;.length 就是一个计算所得项。\n上面的例子不会报错，但是如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错：\nenum Color &#123;Red &#x3D; &quot;red&quot;.length, Green, Blue&#125;;\n\n&#x2F;&#x2F; index.ts(1,33): error TS1061: Enum member must have initializer.\n&#x2F;&#x2F; index.ts(1,40): error TS1061: Enum member must have initializer.\n\n下面是常数项和计算所得项的完整定义，部分引用自中文手册 - 枚举：\n当满足以下条件时，枚举成员被当作是常数：\n\n不具有初始化函数并且之前的枚举成员是常数。在这种情况下，当前枚举成员的值为上一个枚举成员的值加 1。但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 0。\n枚举成员使用常数枚举表达式初始化。常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。当一个表达式满足下面条件之一时，它就是一个常数枚举表达式：\n数字字面量\n引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的）如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用\n带括号的常数枚举表达式\n+, -, ~ 一元运算符应用于常数枚举表达式\n+, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^ 二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为 NaN 或 Infinity，则会在编译阶段报错\n\n\n\n所有其它情况的枚举成员被当作是需要计算得出的值。\n常数枚举常数枚举是使用 const enum 定义的枚举类型：\nconst enum Directions &#123;\n    Up,\n    Down,\n    Left,\n    Right\n&#125;\n\nlet directions &#x3D; [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n\n常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。\n上例的编译结果是：\nvar directions &#x3D; [0 &#x2F;* Up *&#x2F;, 1 &#x2F;* Down *&#x2F;, 2 &#x2F;* Left *&#x2F;, 3 &#x2F;* Right *&#x2F;];\n\n假如包含了计算成员，则会在编译阶段报错：\nconst enum Color &#123;Red, Green, Blue &#x3D; &quot;blue&quot;.length&#125;;\n\n&#x2F;&#x2F; index.ts(1,38): error TS2474: In &#39;const&#39; enum declarations member initializer must be constant expression.\n\n外部枚举外部枚举（Ambient Enums）是使用 declare enum 定义的枚举类型：\ndeclare enum Directions &#123;\n    Up,\n    Down,\n    Left,\n    Right\n&#125;\n\nlet directions &#x3D; [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n\n之前提到过，declare 定义的类型只会用于编译时的检查，编译结果中会被删除。\n上例的编译结果是：\nvar directions &#x3D; [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n\n外部枚举与声明语句一样，常出现在声明文件中。\n同时使用 declare 和 const 也是可以的：\ndeclare const enum Directions &#123;\n    Up,\n    Down,\n    Left,\n    Right\n&#125;\n\nlet directions &#x3D; [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n\n编译结果：\nvar directions &#x3D; [0 &#x2F;* Up *&#x2F;, 1 &#x2F;* Down *&#x2F;, 2 &#x2F;* Left *&#x2F;, 3 &#x2F;* Right *&#x2F;];\n\n\n\n\n\n\n\n\n\n\nTypeScript 的枚举类型的概念来源于 C#。\n参考\nEnums（中文版）\nC# Enum\n\n","slug":"typescript/进阶/枚举","date":"2023-01-11T06:19:25.299Z","categories_index":"TypeScript入门","tags_index":"TypeScript,进阶","author_index":"木木木"},{"id":"f170bca01aa22bf32b2d78c42b7de103","title":"进阶 - 元组","content":"元组数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。\n元组起源于函数编程语言（如 F#），这些语言中会频繁使用 元组。\n简单的例子定义一对值分别为 string 和 number 的元组：\nlet tom: [string, number] &#x3D; [&#39;Tom&#39;, 25];\n\n当赋值或访问一个已知索引的元素时，会得到正确的类型：\nlet tom: [string, number];\ntom[0] &#x3D; &#39;Tom&#39;;\ntom[1] &#x3D; 25;\n\ntom[0].slice(1);\ntom[1].toFixed(2);\n\n也可以只赋值其中一项：\nlet tom: [string, number];\ntom[0] &#x3D; &#39;Tom&#39;;\n\n但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项。\nlet tom: [string, number];\ntom &#x3D; [&#39;Tom&#39;, 25];\nlet tom: [string, number];\ntom &#x3D; [&#39;Tom&#39;];\n\n&#x2F;&#x2F; Property &#39;1&#39; is missing in type &#39;[string]&#39; but required in type &#39;[string, number]&#39;.\n\n越界的元素当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型：\nlet tom: [string, number];\ntom &#x3D; [&#39;Tom&#39;, 25];\ntom.push(&#39;male&#39;);\ntom.push(true);\n\n&#x2F;&#x2F; Argument of type &#39;true&#39; is not assignable to parameter of type &#39;string | number&#39;.\n\n\n\n\n\n\n\n\n\n\n因此使用元祖可以确定元素数据类型，但不要超出范围，可以把元祖理解为固定长度，超出范围不能保证其类型。\n参考\nBasic Types # Tuple（[中文版](https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Basic Types.html#元组-tuple)）\n\n","slug":"typescript/进阶/元组","date":"2023-01-11T06:10:12.585Z","categories_index":"TypeScript入门","tags_index":"TypeScript,进阶","author_index":"木木木"},{"id":"b32d947f3f021fca07951b3bfe4d3d0f","title":"进阶 - 字符串字面量类型","content":"字符串字面量类型字符串字面量类型用来约束取值只能是某几个字符串中的一 个。\n简单的例子type EventNames &#x3D; &#39;click&#39; | &#39;scroll&#39; | &#39;mousemove&#39;;\nfunction handleEvent(ele: Element, event: EventNames) &#123;\n    &#x2F;&#x2F; do something\n&#125;\n\nhandleEvent(document.getElementById(&#39;hello&#39;), &#39;scroll&#39;);  &#x2F;&#x2F; 没问题\nhandleEvent(document.getElementById(&#39;world&#39;), &#39;dblclick&#39;); &#x2F;&#x2F; 报错，event 不能为 &#39;dblclick&#39;\n\n&#x2F;&#x2F; index.ts(7,47): error TS2345: Argument of type &#39;&quot;dblclick&quot;&#39; is not assignable to parameter of type &#39;EventNames&#39;.\n\n上例中，我们使用 type 定了一个字符串字面量类型 EventNames，它只能取三种字符串中的一种。\n注意，类型别名与字符串字面量类型都是使用 type 进行定义。\n参考\nAdvanced Types # Type Aliases（[中文版](https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced Types.html#字符串字面量类型)）\n\n","slug":"typescript/进阶/字符串字面量","date":"2023-01-11T05:54:58.636Z","categories_index":"TypeScript入门","tags_index":"TypeScript,进阶","author_index":"木木木"},{"id":"867cdea12f46a395484385c577e045cd","title":"进阶 - 类型别名","content":"类型别名类型别名用来给一个类型起一个新的名字\n简单的例子type Name &#x3D; string;\ntype NameResolver &#x3D; () &#x3D;&gt; string;\ntype NameOrResolver &#x3D; Name | NameResolver;\nfunction getName(n: NameOrResolver): Name &#123;\n    if (typeof n &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;\n        return n;\n    &#125; else &#123;\n        return n();\n    &#125;\n&#125;\n\n上例中，我们使用 type 创建类型别名。\n类型别名常用于联合类型。\n参考\nAdvanced Types # Type Aliases（[中文版](https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced Types.html#类型别名)）\n\n","slug":"typescript/进阶/类型别名","date":"2023-01-10T09:09:19.889Z","categories_index":"TypeScript入门","tags_index":"TypeScript,进阶","author_index":"木木木"},{"id":"e2d507142ea3f2327476845d7100fc3b","title":"基础 - 内置对象","content":"内置对象JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型。\n内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。\nECMAScript 的内置对象ECMAScript 标准提供的内置对象有：\nBoolean、Error、Date、RegExp 等。\n我们可以在 TypeScript 中将变量定义为这些类型：\nlet b: Boolean &#x3D; new Boolean(1);\nlet e: Error &#x3D; new Error(&#39;Error occurred&#39;);\nlet d: Date &#x3D; new Date();\nlet r: RegExp &#x3D; &#x2F;[a-z]&#x2F;;\n\n更多的内置对象，可以查看 MDN 的文档。\n而他们的定义文件，则在 TypeScript 核心库的定义文件中。\nDOM 和 BOM 的内置对象DOM 和 BOM 提供的内置对象有：\nDocument、HTMLElement、Event、NodeList 等。\nTypeScript 中会经常用到这些类型：\nlet body: HTMLElement &#x3D; document.body;\nlet allDiv: NodeList &#x3D; document.querySelectorAll(&#39;div&#39;);\ndocument.addEventListener(&#39;click&#39;, function(e: MouseEvent) &#123;\n  &#x2F;&#x2F; Do something\n&#125;);\n\n它们的定义文件同样在 TypeScript 核心库的定义文件中。\nTypeScript 核心库的定义文件TypeScript 核心库的定义文件中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。\n当你在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了，比如：\nMath.pow(10, &#39;2&#39;);\n\n&#x2F;&#x2F; index.ts(1,14): error TS2345: Argument of type &#39;string&#39; is not assignable to parameter of type &#39;number&#39;.\n\n上面的例子中，Math.pow 必须接受两个 number 类型的参数。事实上 Math.pow 的类型定义如下：\ninterface Math &#123;\n    &#x2F;**\n     * Returns the value of a base expression taken to a specified power.\n     * @param x The base value of the expression.\n     * @param y The exponent value of the expression.\n     *&#x2F;\n    pow(x: number, y: number): number;\n&#125;\n\n再举一个 DOM 中的例子：\ndocument.addEventListener(&#39;click&#39;, function(e) &#123;\n    console.log(e.targetCurrent);\n&#125;);\n\n&#x2F;&#x2F; index.ts(2,17): error TS2339: Property &#39;targetCurrent&#39; does not exist on type &#39;MouseEvent&#39;.\n\n上面的例子中，addEventListener 方法是在 TypeScript 核心库中定义的：\ninterface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent &#123;\n    addEventListener(type: string, listener: (ev: MouseEvent) &#x3D;&gt; any, useCapture?: boolean): void;\n&#125;\n\n所以 e 被推断成了 MouseEvent，而 MouseEvent 是没有 targetCurrent 属性的，所以报错了。\n注意，TypeScript 核心库的定义中不包含 Node.js 部分。\n用 TypeScript 写 Node.jsNode.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：\nnpm install @types&#x2F;node --save-dev\n\n参考\n内置对象\nTypeScript 核心库的定义文件\n\n","slug":"typescript/基础/内置对象","date":"2023-01-10T08:41:16.613Z","categories_index":"TypeScript入门","tags_index":"TypeScript,基础","author_index":"木木木"},{"id":"4fa72d19c14aa96fb5e16c70521c71a4","title":"基础 - 声明文件","content":"声明文件当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。\n新语法索引§由于本章涉及大量新语法，故在本章开头列出新语法的索引，方便大家在使用这些新语法时能快速查找到对应的讲解：\n\ndeclare var 声明全局变量\ndeclare function 声明全局方法\ndeclare class 声明全局类\ndeclare enum 声明全局枚举类型\ndeclare namespace 声明（含有子属性的）全局对象\ninterface 和 type 声明全局类型\nexport 导出变量\nexport namespace 导出（含有子属性的）对象\nexport default ES6 默认导出\nexport = commonjs 导出模块\nexport as namespace UMD 库声明全局变量\ndeclare global 扩展全局变量\ndeclare module 扩展模块\n///  三斜线指令\n\n什么是声明语句§假如我们想使用第三方库 jQuery，一种常见的方式是在 html 中通过 &lt;script&gt; 标签引入 jQuery，然后就可以使用全局变量 $ 或 jQuery 了。\n我们通常这样获取一个 id 是 foo 的元素：\n$(&#39;#foo&#39;);\n&#x2F;&#x2F; or\njQuery(&#39;#foo&#39;);\n\n但是在 ts 中，编译器并不知道 $ 或 jQuery 是什么东西1：\njQuery(&#39;#foo&#39;);\n&#x2F;&#x2F; ERROR: Cannot find name &#39;jQuery&#39;.\n\n这时，我们需要使用 declare var 来定义它的类型2：\ndeclare var jQuery: (selector: string) &#x3D;&gt; any;\n\njQuery(&#39;#foo&#39;);\n\n上例中，declare var 并没有真的定义一个变量，只是定义了全局变量 jQuery 的类型，仅仅会用于编译时的检查，在编译结果中会被删除。它编译结果是：\njQuery(&#39;#foo&#39;);\n\n除了 declare var 之外，还有其他很多种声明语句，将会在后面详细介绍。\n什么是声明文件§通常我们会把声明语句放到一个单独的文件（jQuery.d.ts）中，这就是声明文件3：\n&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare var jQuery: (selector: string) &#x3D;&gt; any;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery(&#39;#foo&#39;);\n\n声明文件必需以 .d.ts 为后缀。\n一般来说，ts 会解析项目中所有的 *.ts 文件，当然也包含以 .d.ts 结尾的文件。所以当我们将 jQuery.d.ts 放到项目中时，其他所有 *.ts 文件就都可以获得 jQuery 的类型定义了。\n&#x2F;path&#x2F;to&#x2F;project\n├── src\n|  ├── index.ts\n|  └── jQuery.d.ts\n└── tsconfig.json\n\n假如仍然无法解析，那么可以检查下 tsconfig.json 中的 files、include 和 exclude 配置，确保其包含了 jQuery.d.ts 文件。\n这里只演示了全局变量这种模式的声明文件，假如是通过模块导入的方式使用第三方库的话，那么引入声明文件又是另一种方式了，将会在后面详细介绍。\n第三方声明文件§当然，jQuery 的声明文件不需要我们定义了，社区已经帮我们定义好了：jQuery in DefinitelyTyped。\n我们可以直接下载下来使用，但是更推荐的是使用 @types 统一管理第三方库的声明文件。\n@types 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例：\nnpm install @types&#x2F;jquery --save-dev\n\n可以在这个页面搜索你需要的声明文件。\n书写声明文件§当一个第三方库没有提供声明文件时，我们就需要自己书写声明文件了。前面只介绍了最简单的声明文件内容，而真正书写一个声明文件并不是一件简单的事，以下会详细介绍如何书写声明文件。\n在不同的场景下，声明文件的内容和使用方式会有所区别。\n库的使用场景主要有以下几种：\n\n全局变量：通过 &lt;script&gt; 标签引入第三方库，注入全局变量\nnpm 包：通过 import foo from &#39;foo&#39; 导入，符合 ES6 模块规范\nUMD 库：既可以通过 &lt;script&gt; 标签引入，又可以通过 import 导入\n直接扩展全局变量：通过 &lt;script&gt; 标签引入后，改变一个全局变量的结构\n在 npm 包或 UMD 库中扩展全局变量：引用 npm 包或 UMD 库后，改变一个全局变量的结构\n模块插件：通过 &lt;script&gt; 或 import 导入后，改变另一个模块的结构\n\n全局变量§全局变量是最简单的一种场景，之前举的例子就是通过 &lt;script&gt; 标签引入 jQuery，注入全局变量 $ 和 jQuery。\n使用全局变量的声明文件时，如果是以 npm install @types/xxx --save-dev 安装的，则不需要任何配置。如果是将声明文件直接存放于当前项目中，则建议和其他源码一起放到 src 目录下（或者对应的源码目录下）：\n&#x2F;path&#x2F;to&#x2F;project\n├── src\n|  ├── index.ts\n|  └── jQuery.d.ts\n└── tsconfig.json\n\n如果没有生效，可以检查下 tsconfig.json 中的 files、include 和 exclude 配置，确保其包含了 jQuery.d.ts 文件。\n全局变量的声明文件主要有以下几种语法：\n\ndeclare var 声明全局变量\ndeclare function 声明全局方法\ndeclare class 声明全局类\ndeclare enum 声明全局枚举类型\ndeclare namespace 声明（含有子属性的）全局对象\ninterface 和 type 声明全局类型\n\ndeclare var§在所有的声明语句中，declare var 是最简单的，如之前所学，它能够用来定义一个全局变量的类型。与其类似的，还有 declare let 和 declare const，使用 let 与使用 var 没有什么区别：\n&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare let jQuery: (selector: string) &#x3D;&gt; any;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery(&#39;#foo&#39;);\n&#x2F;&#x2F; 使用 declare let 定义的 jQuery 类型，允许修改这个全局变量\njQuery &#x3D; function(selector) &#123;\n    return document.querySelector(selector);\n&#125;;\n\n而当我们使用 const 定义时，表示此时的全局变量是一个常量，不允许再去修改它的值了4：\n&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare const jQuery: (selector: string) &#x3D;&gt; any;\n\njQuery(&#39;#foo&#39;);\n&#x2F;&#x2F; 使用 declare const 定义的 jQuery 类型，禁止修改这个全局变量\njQuery &#x3D; function(selector) &#123;\n    return document.querySelector(selector);\n&#125;;\n&#x2F;&#x2F; ERROR: Cannot assign to &#39;jQuery&#39; because it is a constant or a read-only property.\n\n一般来说，全局变量都是禁止修改的常量，所以大部分情况都应该使用 const 而不是 var 或 let。\n需要注意的是，声明语句中只能定义类型，切勿在声明语句中定义具体的实现5：\ndeclare const jQuery &#x3D; function(selector) &#123;\n    return document.querySelector(selector);\n&#125;;\n&#x2F;&#x2F; ERROR: An implementation cannot be declared in ambient contexts.\n\ndeclare function§declare function 用来定义全局函数的类型。jQuery 其实就是一个函数，所以也可以用 function 来定义：\n&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare function jQuery(selector: string): any;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery(&#39;#foo&#39;);\n\n在函数类型的声明语句中，函数重载也是支持的6：\n&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare function jQuery(selector: string): any;\ndeclare function jQuery(domReadyCallback: () &#x3D;&gt; any): any;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery(&#39;#foo&#39;);\njQuery(function() &#123;\n    alert(&#39;Dom Ready!&#39;);\n&#125;);\n\ndeclare class§当全局变量是一个类的时候，我们用 declare class 来定义它的类型7：\n&#x2F;&#x2F; src&#x2F;Animal.d.ts\n\ndeclare class Animal &#123;\n    name: string;\n    constructor(name: string);\n    sayHi(): string;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nlet cat &#x3D; new Animal(&#39;Tom&#39;);\n\n同样的，declare class 语句也只能用来定义类型，不能用来定义具体的实现，比如定义 sayHi 方法的具体实现则会报错：\n&#x2F;&#x2F; src&#x2F;Animal.d.ts\n\ndeclare class Animal &#123;\n    name: string;\n    constructor(name: string);\n    sayHi() &#123;\n        return &#96;My name is $&#123;this.name&#125;&#96;;\n    &#125;;\n    &#x2F;&#x2F; ERROR: An implementation cannot be declared in ambient contexts.\n&#125;\n\ndeclare enum§使用 declare enum 定义的枚举类型也称作外部枚举（Ambient Enums），举例如下8：\n&#x2F;&#x2F; src&#x2F;Directions.d.ts\n\ndeclare enum Directions &#123;\n    Up,\n    Down,\n    Left,\n    Right\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nlet directions &#x3D; [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n\n与其他全局变量的类型声明一致，declare enum 仅用来定义类型，而不是具体的值。\nDirections.d.ts 仅仅会用于编译时的检查，声明文件里的内容在编译结果中会被删除。它编译结果是：\nvar directions &#x3D; [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n\n其中 Directions 是由第三方库定义好的全局变量。\ndeclare namespace§namespace 是 ts 早期时为了解决模块化而创造的关键字，中文称为命名空间。\n由于历史遗留原因，在早期还没有 ES6 的时候，ts 提供了一种模块化方案，使用 module 关键字表示内部模块。但由于后来 ES6 也使用了 module 关键字，ts 为了兼容 ES6，使用 namespace 替代了自己的 module，更名为命名空间。\n随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的 namespace，而推荐使用 ES6 的模块化方案了，故我们不再需要学习 namespace 的使用了。\nnamespace 被淘汰了，但是在声明文件中，declare namespace 还是比较常用的，它用来表示全局变量是一个对象，包含很多子属性。\n比如 jQuery 是一个全局变量，它是一个对象，提供了一个 jQuery.ajax 方法可以调用，那么我们就应该使用 declare namespace jQuery 来声明这个拥有多个子属性的全局变量。\n&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare namespace jQuery &#123;\n    function ajax(url: string, settings?: any): void;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery.ajax(&#39;&#x2F;api&#x2F;get_something&#39;);\n\n注意，在 declare namespace 内部，我们直接使用 function ajax 来声明函数，而不是使用 declare function ajax。类似的，也可以使用 const, class, enum 等语句9：\n&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare namespace jQuery &#123;\n    function ajax(url: string, settings?: any): void;\n    const version: number;\n    class Event &#123;\n        blur(eventType: EventType): void\n    &#125;\n    enum EventType &#123;\n        CustomClick\n    &#125;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery.ajax(&#39;&#x2F;api&#x2F;get_something&#39;);\nconsole.log(jQuery.version);\nconst e &#x3D; new jQuery.Event();\ne.blur(jQuery.EventType.CustomClick);\n\n嵌套的命名空间§如果对象拥有深层的层级，则需要用嵌套的 namespace 来声明深层的属性的类型10：\n&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare namespace jQuery &#123;\n    function ajax(url: string, settings?: any): void;\n    namespace fn &#123;\n        function extend(object: any): void;\n    &#125;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery.ajax(&#39;&#x2F;api&#x2F;get_something&#39;);\njQuery.fn.extend(&#123;\n    check: function() &#123;\n        return this.each(function() &#123;\n            this.checked &#x3D; true;\n        &#125;);\n    &#125;\n&#125;);\n\n假如 jQuery 下仅有 fn 这一个属性（没有 ajax 等其他属性或方法），则可以不需要嵌套 namespace11：\n&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare namespace jQuery.fn &#123;\n    function extend(object: any): void;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery.fn.extend(&#123;\n    check: function() &#123;\n        return this.each(function() &#123;\n            this.checked &#x3D; true;\n        &#125;);\n    &#125;\n&#125;);\n\ninterface 和 type§除了全局变量之外，可能有一些类型我们也希望能暴露出来。在类型声明文件中，我们可以直接使用 interface 或 type 来声明一个全局的接口或类型12：\n&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ninterface AjaxSettings &#123;\n    method?: &#39;GET&#39; | &#39;POST&#39;\n    data?: any;\n&#125;\ndeclare namespace jQuery &#123;\n    function ajax(url: string, settings?: AjaxSettings): void;\n&#125;\n\n这样的话，在其他文件中也可以使用这个接口或类型了：\n&#x2F;&#x2F; src&#x2F;index.ts\n\nlet settings: AjaxSettings &#x3D; &#123;\n    method: &#39;POST&#39;,\n    data: &#123;\n        name: &#39;foo&#39;\n    &#125;\n&#125;;\njQuery.ajax(&#39;&#x2F;api&#x2F;post_something&#39;, settings);\n\ntype 与 interface 类似，不再赘述。\n防止命名冲突§暴露在最外层的 interface 或 type 会作为全局类型作用于整个项目中，我们应该尽可能的减少全局变量或全局类型的数量。故最好将他们放到 namespace 下13：\n&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare namespace jQuery &#123;\n    interface AjaxSettings &#123;\n        method?: &#39;GET&#39; | &#39;POST&#39;\n        data?: any;\n    &#125;\n    function ajax(url: string, settings?: AjaxSettings): void;\n&#125;\n\n注意，在使用这个 interface 的时候，也应该加上 jQuery 前缀：\n&#x2F;&#x2F; src&#x2F;index.ts\n\nlet settings: jQuery.AjaxSettings &#x3D; &#123;\n    method: &#39;POST&#39;,\n    data: &#123;\n        name: &#39;foo&#39;\n    &#125;\n&#125;;\njQuery.ajax(&#39;&#x2F;api&#x2F;post_something&#39;, settings);\n\n声明合并§假如 jQuery 既是一个函数，可以直接被调用 jQuery(&#39;#foo&#39;)，又是一个对象，拥有子属性 jQuery.ajax()（事实确实如此），那么我们可以组合多个声明语句，它们会不冲突的合并起来14：\n&#x2F;&#x2F; src&#x2F;jQuery.d.ts\n\ndeclare function jQuery(selector: string): any;\ndeclare namespace jQuery &#123;\n    function ajax(url: string, settings?: any): void;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery(&#39;#foo&#39;);\njQuery.ajax(&#39;&#x2F;api&#x2F;get_something&#39;);\n\n关于声明合并的更多用法，可以查看声明合并章节。\nnpm 包§一般我们通过 import foo from &#39;foo&#39; 导入一个 npm 包，这是符合 ES6 模块规范的。\n在我们尝试给一个 npm 包创建声明文件之前，需要先看看它的声明文件是否已经存在。一般来说，npm 包的声明文件可能存在于两个地方：\n\n与该 npm 包绑定在一起。判断依据是 package.json 中有 types 字段，或者有一个 index.d.ts 声明文件。这种模式不需要额外安装其他包，是最为推荐的，所以以后我们自己创建 npm 包的时候，最好也将声明文件与 npm 包绑定在一起。\n发布到 @types 里。我们只需要尝试安装一下对应的 @types 包就知道是否存在该声明文件，安装命令是 npm install @types/foo --save-dev。这种模式一般是由于 npm 包的维护者没有提供声明文件，所以只能由其他人将声明文件发布到 @types 里了。\n\n假如以上两种方式都没有找到对应的声明文件，那么我们就需要自己为它写声明文件了。由于是通过 import 语句导入的模块，所以声明文件存放的位置也有所约束，一般有两种方案：\n\n创建一个 node_modules/@types/foo/index.d.ts 文件，存放 foo 模块的声明文件。这种方式不需要额外的配置，但是 node_modules 目录不稳定，代码也没有被保存到仓库中，无法回溯版本，有不小心被删除的风险，故不太建议用这种方案，一般只用作临时测试。\n创建一个 types 目录，专门用来管理自己写的声明文件，将 foo 的声明文件放到 types/foo/index.d.ts 中。这种方式需要配置下 tsconfig.json 中的 paths 和 baseUrl 字段。\n\n目录结构：\n&#x2F;path&#x2F;to&#x2F;project\n├── src\n|  └── index.ts\n├── types\n|  └── foo\n|     └── index.d.ts\n└── tsconfig.json\n\ntsconfig.json 内容：\n&#123;\n    &quot;compilerOptions&quot;: &#123;\n        &quot;module&quot;: &quot;commonjs&quot;,\n        &quot;baseUrl&quot;: &quot;.&#x2F;&quot;,\n        &quot;paths&quot;: &#123;\n            &quot;*&quot;: [&quot;types&#x2F;*&quot;]\n        &#125;\n    &#125;\n&#125;\n\n如此配置之后，通过 import 导入 foo 的时候，也会去 types 目录下寻找对应的模块的声明文件了。\n注意 module 配置可以有很多种选项，不同的选项会影响模块的导入导出模式。这里我们使用了 commonjs 这个最常用的选项，后面的教程也都默认使用的这个选项。\n不管采用了以上两种方式中的哪一种，我都强烈建议大家将书写好的声明文件（通过给第三方库发 pull request，或者直接提交到 @types 里）发布到开源社区中，享受了这么多社区的优秀的资源，就应该在力所能及的时候给出一些回馈。只有所有人都参与进来，才能让 ts 社区更加繁荣。\nnpm 包的声明文件主要有以下几种语法：\n\nexport 导出变量\nexport namespace 导出（含有子属性的）对象\nexport default ES6 默认导出\nexport = commonjs 导出模块\n\nexport§npm 包的声明文件与全局变量的声明文件有很大区别。在 npm 包的声明文件中，使用 declare 不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。只有在声明文件中使用 export 导出，然后在使用方 import 导入后，才会应用到这些类型声明。\nexport 的语法与普通的 ts 中的语法类似，区别仅在于声明文件中禁止定义具体的实现15：\n&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport const name: string;\nexport function getName(): string;\nexport class Animal &#123;\n    constructor(name: string);\n    sayHi(): string;\n&#125;\nexport enum Directions &#123;\n    Up,\n    Down,\n    Left,\n    Right\n&#125;\nexport interface Options &#123;\n    data: any;\n&#125;\n\n对应的导入和使用模块应该是这样：\n&#x2F;&#x2F; src&#x2F;index.ts\n\nimport &#123; name, getName, Animal, Directions, Options &#125; from &#39;foo&#39;;\n\nconsole.log(name);\nlet myName &#x3D; getName();\nlet cat &#x3D; new Animal(&#39;Tom&#39;);\nlet directions &#x3D; [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\nlet options: Options &#x3D; &#123;\n    data: &#123;\n        name: &#39;foo&#39;\n    &#125;\n&#125;;\n\n混用 declare 和 export§我们也可以使用 declare 先声明多个变量，最后再用 export 一次性导出。上例的声明文件可以等价的改写为16：\n&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\ndeclare const name: string;\ndeclare function getName(): string;\ndeclare class Animal &#123;\n    constructor(name: string);\n    sayHi(): string;\n&#125;\ndeclare enum Directions &#123;\n    Up,\n    Down,\n    Left,\n    Right\n&#125;\ninterface Options &#123;\n    data: any;\n&#125;\n\nexport &#123; name, getName, Animal, Directions, Options &#125;;\n\n注意，与全局变量的声明文件类似，interface 前是不需要 declare 的。\nexport namespace§与 declare namespace 类似，export namespace 用来导出一个拥有子属性的对象17：\n&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport namespace foo &#123;\n    const name: string;\n    namespace bar &#123;\n        function baz(): string;\n    &#125;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nimport &#123; foo &#125; from &#39;foo&#39;;\n\nconsole.log(foo.name);\nfoo.bar.baz();\n\nexport default§在 ES6 模块系统中，使用 export default 可以导出一个默认值，使用方可以用 import foo from &#39;foo&#39; 而不是 import &#123; foo &#125; from &#39;foo&#39; 来导入这个默认值。\n在类型声明文件中，export default 用来导出默认值的类型18：\n&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport default function foo(): string;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nimport foo from &#39;foo&#39;;\n\nfoo();\n\n注意，只有 function、class 和 interface 可以直接默认导出，其他的变量需要先定义出来，再默认导出19：\n&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport default enum Directions &#123;\n&#x2F;&#x2F; ERROR: Expression expected.\n    Up,\n    Down,\n    Left,\n    Right\n&#125;\n\n上例中 export default enum 是错误的语法，需要使用 declare enum 定义出来，然后使用 export default 导出：\n&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\ndeclare enum Directions &#123;\n    Up,\n    Down,\n    Left,\n    Right\n&#125;\n\nexport default Directions;\n\n针对这种默认导出，我们一般会将导出语句放在整个声明文件的最前面20：\n&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport default Directions;\n\ndeclare enum Directions &#123;\n    Up,\n    Down,\n    Left,\n    Right\n&#125;\n\nexport =§在 commonjs 规范中，我们用以下方式来导出一个模块：\n&#x2F;&#x2F; 整体导出\nmodule.exports &#x3D; foo;\n&#x2F;&#x2F; 单个导出\nexports.bar &#x3D; bar;\n\n在 ts 中，针对这种模块导出，有多种方式可以导入，第一种方式是 const ... = require：\n&#x2F;&#x2F; 整体导入\nconst foo &#x3D; require(&#39;foo&#39;);\n&#x2F;&#x2F; 单个导入\nconst bar &#x3D; require(&#39;foo&#39;).bar;\n\n第二种方式是 import ... from，注意针对整体导出，需要使用 import * as 来导入：\n&#x2F;&#x2F; 整体导入\nimport * as foo from &#39;foo&#39;;\n&#x2F;&#x2F; 单个导入\nimport &#123; bar &#125; from &#39;foo&#39;;\n\n第三种方式是 import ... require，这也是 ts 官方推荐的方式：\n&#x2F;&#x2F; 整体导入\nimport foo &#x3D; require(&#39;foo&#39;);\n&#x2F;&#x2F; 单个导入\nimport bar &#x3D; foo.bar;\n\n对于这种使用 commonjs 规范的库，假如要为它写类型声明文件的话，就需要使用到 export = 这种语法了21：\n&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport &#x3D; foo;\n\ndeclare function foo(): string;\ndeclare namespace foo &#123;\n    const bar: number;\n&#125;\n\n需要注意的是，上例中使用了 export = 之后，就不能再单个导出 export &#123; bar &#125; 了。所以我们通过声明合并，使用 declare namespace foo 来将 bar 合并到 foo 里。\n准确地讲，export = 不仅可以用在声明文件中，也可以用在普通的 ts 文件中。实际上，import ... require 和 export = 都是 ts 为了兼容 AMD 规范和 commonjs 规范而创立的新语法，由于并不常用也不推荐使用，所以这里就不详细介绍了，感兴趣的可以看官方文档。\n由于很多第三方库是 commonjs 规范的，所以声明文件也就不得不用到 export = 这种语法了。但是还是需要再强调下，相比与 export =，我们更推荐使用 ES6 标准的 export default 和 export。\nUMD 库§既可以通过 &lt;script&gt; 标签引入，又可以通过 import 导入的库，称为 UMD 库。相比于 npm 包的类型声明文件，我们需要额外声明一个全局变量，为了实现这种方式，ts 提供了一个新语法 export as namespace。\nexport as namespace§一般使用 export as namespace 时，都是先有了 npm 包的声明文件，再基于它添加一条 export as namespace 语句，即可将声明好的一个变量声明为全局变量，举例如下22：\n&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport as namespace foo;\nexport &#x3D; foo;\n\ndeclare function foo(): string;\ndeclare namespace foo &#123;\n    const bar: number;\n&#125;\n\n当然它也可以与 export default 一起使用：\n&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\nexport as namespace foo;\nexport default foo;\n\ndeclare function foo(): string;\ndeclare namespace foo &#123;\n    const bar: number;\n&#125;\n\n直接扩展全局变量§有的第三方库扩展了一个全局变量，可是此全局变量的类型却没有相应的更新过来，就会导致 ts 编译错误，此时就需要扩展全局变量的类型。比如扩展 String 类型23：\ninterface String &#123;\n    prependHello(): string;\n&#125;\n\n&#39;foo&#39;.prependHello();\n\n通过声明合并，使用 interface String 即可给 String 添加属性或方法。\n也可以使用 declare namespace 给已有的命名空间添加类型声明24：\n&#x2F;&#x2F; types&#x2F;jquery-plugin&#x2F;index.d.ts\n\ndeclare namespace JQuery &#123;\n    interface CustomOptions &#123;\n        bar: string;\n    &#125;\n&#125;\n\ninterface JQueryStatic &#123;\n    foo(options: JQuery.CustomOptions): string;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\njQuery.foo(&#123;\n    bar: &#39;&#39;\n&#125;);\n\n在 npm 包或 UMD 库中扩展全局变量§如之前所说，对于一个 npm 包或者 UMD 库的声明文件，只有 export 导出的类型声明才能被导入。所以对于 npm 包或 UMD 库，如果导入此库之后会扩展全局变量，则需要使用另一种语法在声明文件中扩展全局变量的类型，那就是 declare global。\ndeclare global§使用 declare global 可以在 npm 包或者 UMD 库的声明文件中扩展全局变量的类型25：\n&#x2F;&#x2F; types&#x2F;foo&#x2F;index.d.ts\n\ndeclare global &#123;\n    interface String &#123;\n        prependHello(): string;\n    &#125;\n&#125;\n\nexport &#123;&#125;;\n&#x2F;&#x2F; src&#x2F;index.ts\n\n&#39;bar&#39;.prependHello();\n\n注意即使此声明文件不需要导出任何东西，仍然需要导出一个空对象，用来告诉编译器这是一个模块的声明文件，而不是一个全局变量的声明文件。\n模块插件§有时通过 import 导入一个模块插件，可以改变另一个原有模块的结构。此时如果原有模块已经有了类型声明文件，而插件模块没有类型声明文件，就会导致类型不完整，缺少插件部分的类型。ts 提供了一个语法 declare module，它可以用来扩展原有模块的类型。\ndeclare module§如果是需要扩展原有模块的话，需要在类型声明文件中先引用原有模块，再使用 declare module 扩展原有模块26：\n&#x2F;&#x2F; types&#x2F;moment-plugin&#x2F;index.d.ts\n\nimport * as moment from &#39;moment&#39;;\n\ndeclare module &#39;moment&#39; &#123;\n    export function foo(): moment.CalendarKey;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nimport * as moment from &#39;moment&#39;;\nimport &#39;moment-plugin&#39;;\n\nmoment.foo();\n\ndeclare module 也可用于在一个文件中一次性声明多个模块的类型27：\n&#x2F;&#x2F; types&#x2F;foo-bar.d.ts\n\ndeclare module &#39;foo&#39; &#123;\n    export interface Foo &#123;\n        foo: string;\n    &#125;\n&#125;\n\ndeclare module &#39;bar&#39; &#123;\n    export function bar(): string;\n&#125;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nimport &#123; Foo &#125; from &#39;foo&#39;;\nimport * as bar from &#39;bar&#39;;\n\nlet f: Foo;\nbar.bar();\n\n声明文件中的依赖§一个声明文件有时会依赖另一个声明文件中的类型，比如在前面的 declare module 的例子中，我们就在声明文件中导入了 moment，并且使用了 moment.CalendarKey 这个类型：\n&#x2F;&#x2F; types&#x2F;moment-plugin&#x2F;index.d.ts\n\nimport * as moment from &#39;moment&#39;;\n\ndeclare module &#39;moment&#39; &#123;\n    export function foo(): moment.CalendarKey;\n&#125;\n\n除了可以在声明文件中通过 import 导入另一个声明文件中的类型之外，还有一个语法也可以用来导入另一个声明文件，那就是三斜线指令。\n三斜线指令§与 namespace 类似，三斜线指令也是 ts 在早期版本中为了描述模块之间的依赖关系而创造的语法。随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的三斜线指令来声明模块之间的依赖关系了。\n但是在声明文件中，它还是有一定的用武之地。\n类似于声明文件中的 import，它可以用来导入另一个声明文件。与 import 的区别是，当且仅当在以下几个场景下，我们才需要使用三斜线指令替代 import：\n\n当我们在书写一个全局变量的声明文件时\n当我们需要依赖一个全局变量的声明文件时\n\n书写一个全局变量的声明文件§这些场景听上去很拗口，但实际上很好理解——在全局变量的声明文件中，是不允许出现 import, export 关键字的。一旦出现了，那么他就会被视为一个 npm 包或 UMD 库，就不再是全局变量的声明文件了。故当我们在书写一个全局变量的声明文件时，如果需要引用另一个库的类型，那么就必须用三斜线指令了28：\n&#x2F;&#x2F; types&#x2F;jquery-plugin&#x2F;index.d.ts\n\n&#x2F;&#x2F;&#x2F; &lt;reference types&#x3D;&quot;jquery&quot; &#x2F;&gt;\n\ndeclare function foo(options: JQuery.AjaxSettings): string;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nfoo(&#123;&#125;);\n\n三斜线指令的语法如上，/// 后面使用 xml 的格式添加了对 jquery 类型的依赖，这样就可以在声明文件中使用 JQuery.AjaxSettings 类型了。\n注意，三斜线指令必须放在文件的最顶端，三斜线指令的前面只允许出现单行或多行注释。\n依赖一个全局变量的声明文件§在另一个场景下，当我们需要依赖一个全局变量的声明文件时，由于全局变量不支持通过 import 导入，当然也就必须使用三斜线指令来引入了29：\n&#x2F;&#x2F; types&#x2F;node-plugin&#x2F;index.d.ts\n\n&#x2F;&#x2F;&#x2F; &lt;reference types&#x3D;&quot;node&quot; &#x2F;&gt;\n\nexport function foo(p: NodeJS.Process): string;\n&#x2F;&#x2F; src&#x2F;index.ts\n\nimport &#123; foo &#125; from &#39;node-plugin&#39;;\n\nfoo(global.process);\n\n在上面的例子中，我们通过三斜线指引入了 node 的类型，然后在声明文件中使用了 NodeJS.Process 这个类型。最后在使用到 foo 的时候，传入了 node 中的全局变量 process。\n由于引入的 node 中的类型都是全局变量的类型，它们是没有办法通过 import 来导入的，所以这种场景下也只能通过三斜线指令来引入了。\n以上两种使用场景下，都是由于需要书写或需要依赖全局变量的声明文件，所以必须使用三斜线指令。在其他的一些不是必要使用三斜线指令的情况下，就都需要使用 import 来导入。\n拆分声明文件§当我们的全局变量的声明文件太大时，可以通过拆分为多个文件，然后在一个入口文件中将它们一一引入，来提高代码的可维护性。比如 jQuery 的声明文件就是这样的：\n&#x2F;&#x2F; node_modules&#x2F;@types&#x2F;jquery&#x2F;index.d.ts\n\n&#x2F;&#x2F;&#x2F; &lt;reference types&#x3D;&quot;sizzle&quot; &#x2F;&gt;\n&#x2F;&#x2F;&#x2F; &lt;reference path&#x3D;&quot;JQueryStatic.d.ts&quot; &#x2F;&gt;\n&#x2F;&#x2F;&#x2F; &lt;reference path&#x3D;&quot;JQuery.d.ts&quot; &#x2F;&gt;\n&#x2F;&#x2F;&#x2F; &lt;reference path&#x3D;&quot;misc.d.ts&quot; &#x2F;&gt;\n&#x2F;&#x2F;&#x2F; &lt;reference path&#x3D;&quot;legacy.d.ts&quot; &#x2F;&gt;\n\nexport &#x3D; jQuery;\n\n其中用到了 types 和 path 两种不同的指令。它们的区别是：types 用于声明对另一个库的依赖，而 path 用于声明对另一个文件的依赖。\n上例中，sizzle 是与 jquery 平行的另一个库，所以需要使用 types=&quot;sizzle&quot; 来声明对它的依赖。而其他的三斜线指令就是将 jquery 的声明拆分到不同的文件中了，然后在这个入口文件中使用 path=&quot;foo&quot; 将它们一一引入。\n其他三斜线指令§除了这两种三斜线指令之外，还有其他的三斜线指令，比如 /// &lt;reference no-default-lib=&quot;true&quot;/&gt;, /// &lt;amd-module /&gt; 等，但它们都是废弃的语法，故这里就不介绍了，详情可见官网。\n自动生成声明文件§如果库的源码本身就是由 ts 写的，那么在使用 tsc 脚本将 ts 编译为 js 的时候，添加 declaration 选项，就可以同时也生成 .d.ts 声明文件了。\n我们可以在命令行中添加 --declaration（简写 -d），或者在 tsconfig.json 中添加 declaration 选项。这里以 tsconfig.json 为例：\n&#123;\n    &quot;compilerOptions&quot;: &#123;\n        &quot;module&quot;: &quot;commonjs&quot;,\n        &quot;outDir&quot;: &quot;lib&quot;,\n        &quot;declaration&quot;: true,\n    &#125;\n&#125;\n\n上例中我们添加了 outDir 选项，将 ts 文件的编译结果输出到 lib 目录下，然后添加了 declaration 选项，设置为 true，表示将会由 ts 文件自动生成 .d.ts 声明文件，也会输出到 lib 目录下。\n运行 tsc 之后，目录结构如下30：\n&#x2F;path&#x2F;to&#x2F;project\n├── lib\n|  ├── bar\n|  |  ├── index.d.ts\n|  |  └── index.js\n|  ├── index.d.ts\n|  └── index.js\n├── src\n|  ├── bar\n|  |  └── index.ts\n|  └── index.ts\n├── package.json\n└── tsconfig.json\n\n在这个例子中，src 目录下有两个 ts 文件，分别是 src/index.ts 和 src/bar/index.ts，它们被编译到 lib 目录下的同时，也会生成对应的两个声明文件 lib/index.d.ts 和 lib/bar/index.d.ts。它们的内容分别是：\n&#x2F;&#x2F; src&#x2F;index.ts\n\nexport * from &#39;.&#x2F;bar&#39;;\n\nexport default function foo() &#123;\n    return &#39;foo&#39;;\n&#125;\n&#x2F;&#x2F; src&#x2F;bar&#x2F;index.ts\n\nexport function bar() &#123;\n    return &#39;bar&#39;;\n&#125;\n&#x2F;&#x2F; lib&#x2F;index.d.ts\n\nexport * from &#39;.&#x2F;bar&#39;;\nexport default function foo(): string;\n&#x2F;&#x2F; lib&#x2F;bar&#x2F;index.d.ts\n\nexport declare function bar(): string;\n\n可见，自动生成的声明文件基本保持了源码的结构，而将具体实现去掉了，生成了对应的类型声明。\n使用 tsc 自动生成声明文件时，每个 ts 文件都会对应一个 .d.ts 声明文件。这样的好处是，使用方不仅可以在使用 import foo from &#39;foo&#39; 导入默认的模块时获得类型提示，还可以在使用 import bar from &#39;foo/lib/bar&#39; 导入一个子模块时，也获得对应的类型提示。\n除了 declaration 选项之外，还有几个选项也与自动生成声明文件有关，这里只简单列举出来，不做详细演示了：\n\ndeclarationDir 设置生成 .d.ts 文件的目录\ndeclarationMap 对每个 .d.ts 文件，都生成对应的 .d.ts.map（sourcemap）文件\nemitDeclarationOnly 仅生成 .d.ts 文件，不生成 .js 文件\n\n发布声明文件§当我们为一个库写好了声明文件之后，下一步就是将它发布出去了。\n此时有两种方案：\n\n将声明文件和源码放在一起\n将声明文件发布到 @types 下\n\n这两种方案中优先选择第一种方案。保持声明文件与源码在一起，使用时就不需要额外增加单独的声明文件库的依赖了，而且也能保证声明文件的版本与源码的版本保持一致。\n仅当我们在给别人的仓库添加类型声明文件，但原作者不愿意合并 pull request 时，才需要使用第二种方案，将声明文件发布到 @types 下。\n将声明文件和源码放在一起§如果声明文件是通过 tsc 自动生成的，那么无需做任何其他配置，只需要把编译好的文件也发布到 npm 上，使用方就可以获取到类型提示了。\n如果是手动写的声明文件，那么需要满足以下条件之一，才能被正确的识别：\n\n给 package.json 中的 types 或 typings 字段指定一个类型声明文件地址\n在项目根目录下，编写一个 index.d.ts 文件\n针对入口文件（package.json 中的 main 字段指定的入口文件），编写一个同名不同后缀的 .d.ts 文件\n\n第一种方式是给 package.json 中的 types 或 typings 字段指定一个类型声明文件地址。比如：\n&#123;\n    &quot;name&quot;: &quot;foo&quot;,\n    &quot;version&quot;: &quot;1.0.0&quot;,\n    &quot;main&quot;: &quot;lib&#x2F;index.js&quot;,\n    &quot;types&quot;: &quot;foo.d.ts&quot;,\n&#125;\n\n指定了 types 为 foo.d.ts 之后，导入此库的时候，就会去找 foo.d.ts 作为此库的类型声明文件了。\ntypings 与 types 一样，只是另一种写法。\n如果没有指定 types 或 typings，那么就会在根目录下寻找 index.d.ts 文件，将它视为此库的类型声明文件。\n如果没有找到 index.d.ts 文件，那么就会寻找入口文件（package.json 中的 main 字段指定的入口文件）是否存在对应同名不同后缀的 .d.ts 文件。\n比如 package.json 是这样时：\n&#123;\n    &quot;name&quot;: &quot;foo&quot;,\n    &quot;version&quot;: &quot;1.0.0&quot;,\n    &quot;main&quot;: &quot;lib&#x2F;index.js&quot;\n&#125;\n\n就会先识别 package.json 中是否存在 types 或 typings 字段。发现不存在，那么就会寻找是否存在 index.d.ts 文件。如果还是不存在，那么就会寻找是否存在 lib/index.d.ts 文件。假如说连 lib/index.d.ts 都不存在的话，就会被认为是一个没有提供类型声明文件的库了。\n有的库为了支持导入子模块，比如 import bar from &#39;foo/lib/bar&#39;，就需要额外再编写一个类型声明文件 lib/bar.d.ts 或者 lib/bar/index.d.ts，这与自动生成声明文件类似，一个库中同时包含了多个类型声明文件。\n将声明文件发布到 @types 下§如果我们是在给别人的仓库添加类型声明文件，但原作者不愿意合并 pull request，那么就需要将声明文件发布到 @types 下。\n与普通的 npm 模块不同，@types 是统一由 DefinitelyTyped 管理的。要将声明文件发布到 @types 下，就需要给 DefinitelyTyped 创建一个 pull-request，其中包含了类型声明文件，测试代码，以及 tsconfig.json 等。\npull-request 需要符合它们的规范，并且通过测试，才能被合并，稍后就会被自动发布到 @types 下。\n在 DefinitelyTyped 中创建一个新的类型声明，需要用到一些工具，DefinitelyTyped 的文档中已经有了详细的介绍，这里就不赘述了，以官方文档为准。\n如果大家有此类需求，可以参考下笔者提交的 pull-request 。\n参考§\nWriting Declaration Files（[中文版](https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/declaration files/Introduction.html)）\nTriple-Slash Directives（[中文版](https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Triple-Slash Directives.html)）\ntypeRoots or paths\nDefinitelyTyped\n\n","slug":"typescript/基础/声明文件","date":"2023-01-10T08:29:21.761Z","categories_index":"TypeScript入门","tags_index":"TypeScript","author_index":"木木木"},{"id":"5c52f5f10bab6e186ef547fb5e21cada","title":"CentOS 镜像","content":"CentOS 镜像在线体验基于CentOS快速搭建LAMP环境去体验本教程介绍如何搭建LAMP环境，其中LAMP分别代表Linux、Apache、MySQL和PHP。\n简介CentOS，是基于Red Hat Linux提供的可自由使用源代码的企业级Linux发行版本；是一个稳定，可预测，可管理和可复制的免费企业级计算平台。\n下载地址: https://mirrors.aliyun.com/centos/\n相关仓库：\nCentOS过期源（centos-vault）：https://developer.aliyun.com/mirror/centos-vault\nCentOS arm源（centos-altarch）：https://developer.aliyun.com/mirror/centos-altarch/\nCentOS Stream源（centos-stream）：https://developer.aliyun.com/mirror/centos-stream\nCentOS debuginfo源（centos-debuginfo）：https://developer.aliyun.com/mirror/centos-debuginfo/\n\n配置方法\n\n\n\n\n\n\n\n\n通知：CentOS 8操作系统版本结束了生命周期（EOL），Linux社区已不再维护该操作系统版本。建议您切换到Anolis或Alinux。如果您的业务过渡期仍需要使用CentOS 8系统中的一些安装包，请根据下文切换CentOS 8的源。\n1. 备份mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup\n\n2. 下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/centos8（centos8官方源已下线，建议切换centos-vault源）wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo  https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-vault-8.5.2111.repo\n\n或者\ncurl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-vault-8.5.2111.repo\n\ncentos6（centos6官方源已下线，建议切换centos-vault源）\nwget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-vault-6.10.repo\n\n或者\ncurl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-vault-6.10.repo\n\nCentOS 7\nwget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo\n\n或者\ncurl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo\n\n3. 运行 yum makecache 生成缓存4. 其他非阿里云ECS用户会出现 Couldn’t resolve host ‘mirrors.cloud.aliyuncs.com’ 信息，不影响使用。用户也可自行修改相关配置: eg:\nsed -i -e &#39;&#x2F;mirrors.cloud.aliyuncs.com&#x2F;d&#39; -e &#39;&#x2F;mirrors.aliyuncs.com&#x2F;d&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo\n\n\n\nCentOS 8 结束生命周期如何切换源公网用户：mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup\nwget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-vault-8.5.2111.repo\nyum clean all &amp;&amp; yum makecache\n\n阿里云ecs用户：mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup\nwget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.cloud.aliyuncs.com&#x2F;repo&#x2F;Centos-vault-8.5.2111.repo\nsed -i &#39;s&#x2F;mirrors.cloud.aliyuncs.com&#x2F;url_tmp&#x2F;g&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &amp;&amp; sed -i &#39;s&#x2F;mirrors.aliyun.com&#x2F;mirrors.cloud.aliyuncs.com&#x2F;g&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &amp;&amp; sed -i &#39;s&#x2F;url_tmp&#x2F;mirrors.aliyun.com&#x2F;g&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo\nyum clean all &amp;&amp; yum makecache\n\n\n\n相关链接\n官方主页: http://www.centos.org/\n邮件列表: https://wiki.centos.org/GettingHelp/ListInfo\n论坛: https://forums.centos.org/\n文档: http://www.centos.org/docs/\nWiki: http://wiki.centos.org/\n\n","slug":"centos/centos镜像","date":"2023-01-09T07:45:49.147Z","categories_index":"Centos","tags_index":"Centos,镜像","author_index":"木木木"},{"id":"1edd776b9215e397a3ff2ca6bed21b52","title":"基础 - 类型断言","content":"类型断言语法值 as 类型 \n&#x2F;&#x2F; 或者\n&lt;类型&gt;值\n\n类型断言的用途类型断言的常见用途有以下几种\n将一个联合类型断言为其中一种之前提到过，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型中共有的属性或方法：\ninterface Cat &#123;\n    name: &#39;mimi;&#39;\n    cry(): void;\n&#125;\n\ninterface Dog &#123;\n    name: &#39;来福&#39;\n    cay(): void;\n&#125;\n\nfunction (fun: Cat | Dog) &#123;\n    return Cat.name\n&#125;\n\n而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法，比如：\ninterface Cat &#123;\n    name: &#39;mimi;&#39;\n    cry(): void;\n&#125;\n\ninterface Dog &#123;\n    name: &#39;来福&#39;\n    run(): void;\n&#125;\n\nfunction (fun: Cat | Dog): boolean &#123;\n    if (typeof fun.cry &#x3D;&#x3D; &#39;function&#39;) return true\n    return false\n&#125;\n&#x2F;&#x2F; index.ts:11:23 - error TS2339: Property &#39;cry&#39; does not exist on type &#39;Cat | Dog&#39;.\n&#x2F;&#x2F;   Property &#39;cry&#39; does not exist on type &#39;Cat&#39;.\n\n上面的例子中，获取 animal.swim 的时候会报错。\n此时可以使用类型断言，将 animal 断言成 Fish：\ninterface Cat &#123;\n    name: &#39;mimi;&#39;\n    cry(): void;\n&#125;\n\ninterface Dog &#123;\n    name: &#39;来福&#39;\n    run(): void;\n&#125;\n\nfunction (fun: Cat | Dog): boolean &#123;\n    if (typeof (fun.cry as Cat) &#x3D;&#x3D; &#39;function&#39;) return true\n    return false\n&#125;\n\n这样就可以解决访问 animal.swim 时报错的问题了。\n\n\n\n\n\n\n提示\n需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误：\n\n\ninterface Cat &#123;\n    name: &#39;mimi;&#39;\n    cry(): void;\n&#125;\n\ninterface Dog &#123;\n    name: &#39;来福&#39;\n    run(): void;\n&#125;\n\nfunction dosth (fun: Cat | Dog): boolean &#123;\n    if (typeof (fun.cry as Cat) &#x3D;&#x3D; &#39;function&#39;) return true\n    return false\n&#125;\n\nconst jeck: Dog &#x3D; &#123;\n    name: &#39;哼哈&#39;,\n    run() &#123; console.log(&#39;run&#39;) &#125;\n&#125;\n\ndosth(jeck)\n&#x2F;&#x2F; Uncaught TypeError: fun.cry is not a function&#96;\n\n报错的原因是因为 (fun.cry as Cat) 隐藏了fun为Dog的可能性, 直接将fun断言为了Cat而Cat类型里就没有run方法, 就会导致运行时错误了。\n\n\n\n\n\n\n\n\n\n总之，使用类型断言时一定要格外小心，尽量避免断言后调用方法或引用深层属性，以减少不必要的运行时错误。\n将一个父类断言为更具体的子类当类之间有继承关系的时候, 类型断言也是很常见的\nclass ApiError extends Error &#123;\n    code: number &#x3D; 0\n&#125;\n\nclass HttpError extends Error &#123;\n    statuscode: number &#x3D; 200\n&#125;\n\nfunction isHttpError (error: Error) &#123;\n    if (typeof (error as HttpError).statuscode &#x3D; &#39;number&#39;) return true\n    return false\n&#125;\n\n上面的例子中，我们声明了函数 isHttpError，它用来判断传入的参数是不是 HttpError 类型，为了实现这样一个函数，它的参数的类型肯定得是比ApiError和HttpError更抽象的父类 Error，这样的话这个函数就能接受 Error 或它的子类作为参数了。\n但是由于父类 Error 中没有 statuscode 属性，故直接获取 error.statuscode 会报错，需要使用类型断言获取 (error as HttpError).code。\n大家可能会注意到，在这个例子中有一个更合适的方式来判断是不是 HttpError，那就是使用 instanceof：\nclass ApiError extends Error &#123;\n    code: number &#x3D; 0\n&#125;\n\nclass HttpError extends Error &#123;\n    statuscode: number &#x3D; 200\n&#125;\n\nfunction isHttpError (error: Error) &#123;\n    if (error instanceof HttpError) return true\n    return false\n&#125;\n\n\n\n\n\n\n\n提示\n上面的例子中，确实使用 instanceof 更加合适，因为 HttpError 是一个 JavaScript 的类，能够通过 instanceof 来判断 error 是否是它的实例。\n但是有的情况下 ApiError 和 HttpError 不是一个真正的类，而只是一个 TypeScript 的接口（interface），接口是一个类型，不是一个真正的值，它在编译结果中会被删除，当然就无法使用 instanceof 来做运行时判断了\n\n\n此时就只能用类型断言，通过判断是否存在 code 属性，来判断传入的参数是不是 ApiError 了：\ninterface ApiError extends Error &#123;\n    code: number;\n&#125;\ninterface HttpError extends Error &#123;\n    statusCode: number;\n&#125;\n\nfunction isApiError(error: Error) &#123;\n    if (typeof (error as ApiError).code &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;\n        return true;\n    &#125;\n    return false;\n&#125;\n\n将任何一个类型断言为理想情况下，TypeScript 的类型系统运转良好，每个值的类型都具体而精确。\n当我们引用一个在此类型上不存在的属性或方法时，就会报错：\nconst foo: number &#x3D; 1;\nfoo.length &#x3D; 1;\n\n&#x2F;&#x2F; index.ts:2:5 - error TS2339: Property &#39;length&#39; does not exist on type &#39;number&#39;.\n\n上面的例子中，数字类型的变量 foo 上是没有 length 属性的，故 TypeScript 给出了相应的错误提示。\n这种错误提示显然是非常有用的。\n但有的时候，我们非常确定这段代码不会出错，比如下面这个例子：\nwindow.foo &#x3D; 1;\n\n&#x2F;&#x2F; index.ts:1:8 - error TS2339: Property &#39;foo&#39; does not exist on type &#39;Window &amp; typeof globalThis&#39;.\n\n上面的例子中，我们需要将 window 上添加一个属性 foo，但 TypeScript 编译时会报错，提示我们 window 上不存在 foo 属性。\n此时我们可以使用 as any 临时将 window 断言为 any 类型：\n(window as any).foo &#x3D; 1;\n\n在 any 类型的变量上，访问任何属性都是允许的。\n需要注意的是，将一个变量断言为 any 可以说是解决 TypeScript 中类型问题的最后一个手段。\n它极有可能掩盖了真正的类型错误，所以如果不是非常确定，就不要使用 as any。\n上面的例子中，我们也可以通过[扩展 window 的类型（TODO）][]解决这个错误，不过如果只是临时的增加 foo 属性，as any 会更加方便。\n总之，一方面不能滥用 as any，另一方面也不要完全否定它的作用，我们需要在类型的严格性和开发的便利性之间掌握平衡（这也是 TypeScript 的设计理念之一），才能发挥出 TypeScript 最大的价值。\n将 any 断言为一个具体的类型在日常的开发中，我们不可避免的需要处理 any 类型的变量，它们可能是由于第三方库未能定义好自己的类型，也有可能是历史遗留的或其他人编写的烂代码，还可能是受到 TypeScript 类型系统的限制而无法精确定义类型的场景。\n遇到 any 类型的变量时，我们可以选择无视它，任由它滋生更多的 any。\n我们也可以选择改进它，通过类型断言及时的把 any 断言为精确的类型，亡羊补牢，使我们的代码向着高可维护性的目标发展。\n举例来说，历史遗留的代码中有个 getCacheData，它的返回值是 any：\nfunction getCacheData(key: string): any &#123;\n    return (window as any).cache[key];\n&#125;\n\n那么我们在使用它时，最好能够将调用了它之后的返回值断言成一个精确的类型，这样就方便了后续的操作：\nfunction getCacheData(key: string): any &#123;\n    return (window as any).cache[key];\n&#125;\n\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst tom &#x3D; getCacheData(&#39;tom&#39;) as Cat;\ntom.run();\n\n上面的例子中，我们调用完 getCacheData 之后，立即将它断言为 Cat 类型。这样的话明确了 tom 的类型，后续对 tom 的访问时就有了代码补全，提高了代码的可维护性。\n类型断言的限制从上面的例子中，我们可以总结出：\n\n联合类型可以被断言为其中一个类型\n父类可以被断言为子类\n任何类型都可以被断言为 any\nany 可以被断言为任何类型\n\n那么类型断言有没有什么限制呢？是不是任何一个类型都可以被断言为任何另一个类型呢？\n答案是否定的——并不是任何一个类型都可以被断言为任何另一个类型。\n具体来说，若 A 兼容 B，那么 A 能够被断言为 B，B 也能被断言为 A。\n下面我们通过一个简化的例子，来理解类型断言的限制：\ninterface Animal &#123;\n    name: string;\n&#125;\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nlet tom: Cat &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    run: () &#x3D;&gt; &#123; console.log(&#39;run&#39;) &#125;\n&#125;;\nlet animal: Animal &#x3D; tom;\n\n我们知道，TypeScript 是结构类型系统，类型之间的对比只会比较它们最终的结构，而会忽略它们定义时的关系。\n在上面的例子中，Cat 包含了 Animal 中的所有属性，除此之外，它还有一个额外的方法 run。TypeScript 并不关心 Cat 和 Animal 之间定义时是什么关系，而只会看它们最终的结构有什么关系——所以它与 Cat extends Animal 是等价的：\ninterface Animal &#123;\n    name: string;\n&#125;\ninterface Cat extends Animal &#123;\n    run(): void;\n&#125;\n\n那么也不难理解为什么 Cat 类型的 tom 可以赋值给 Animal 类型的 animal 了——就像面向对象编程中我们可以将子类的实例赋值给类型为父类的变量。\n我们把它换成 TypeScript 中更专业的说法，即：Animal 兼容 Cat。\n当 Animal 兼容 Cat 时，它们就可以互相进行类型断言了：\ninterface Animal &#123;\n    name: string;\n&#125;\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nfunction testAnimal(animal: Animal) &#123;\n    return (animal as Cat);\n&#125;\nfunction testCat(cat: Cat) &#123;\n    return (cat as Animal);\n&#125;\n\n这样的设计其实也很容易就能理解：\n\n允许 animal as Cat 是因为「父类可以被断言为子类」，这个前面已经学习过了\n允许 cat as Animal 是因为既然子类拥有父类的属性和方法，那么被断言为父类，获取父类的属性、调用父类的方法，就不会有任何问题，故「子类可以被断言为父类」\n\n需要注意的是，这里我们使用了简化的父类子类的关系来表达类型的兼容性，而实际上 TypeScript 在判断类型的兼容性时，比这种情况复杂很多，详细请参考[类型的兼容性（TODO)][]章节。\n总之，若 A 兼容 B，那么 A 能够被断言为 B，B 也能被断言为 A。\n同理，若 B 兼容 A，那么 A 能够被断言为 B，B 也能被断言为 A。\n所以这也可以换一种说法：\n要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可，这也是为了在类型断言时的安全考虑，毕竟毫无根据的断言是非常危险的。\n综上所述：\n\n联合类型可以被断言为其中一个类型\n父类可以被断言为子类\n任何类型都可以被断言为 any\nany 可以被断言为任何类型\n要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可\n\n其实前四种情况都是最后一个的特例。\n双重断言既然：\n\n任何类型都可以被断言为 any\nany 可以被断言为任何类型\n\n那么我们是不是可以使用双重断言 as any as Foo 来将任何一个类型断言为任何另一个类型呢？\ninterface Cat &#123;\n    run(): void;\n&#125;\ninterface Fish &#123;\n    swim(): void;\n&#125;\n\nfunction testCat(cat: Cat) &#123;\n    return (cat as any as Fish);\n&#125;\n\n在上面的例子中，若直接使用 cat as Fish 肯定会报错，因为 Cat 和 Fish 互相都不兼容。\n但是若使用双重断言，则可以打破「要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可」的限制，将任何一个类型断言为任何另一个类型。\n若你使用了这种双重断言，那么十有八九是非常错误的，它很可能会导致运行时错误。\n除非迫不得已，千万别用双重断言。\n类型断言VS类型转换类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除：\nfunction toBoolean(something: any): boolean &#123;\n    return something as boolean;\n&#125;\n\ntoBoolean(1);\n&#x2F;&#x2F; 返回值为 1\n\n在上面的例子中，将 something 断言为 boolean 虽然可以通过编译，但是并没有什么用，代码在编译后会变成：\nfunction toBoolean(something) &#123;\n    return something;\n&#125;\n\ntoBoolean(1);\n&#x2F;&#x2F; 返回值为 1\n\n所以类型断言不是类型转换，它不会真的影响到变量的类型。\n若要进行类型转换，需要直接调用类型转换的方法：\nfunction toBoolean(something: any): boolean &#123;\n    return Boolean(something);\n&#125;\n\ntoBoolean(1);\n&#x2F;&#x2F; 返回值为 true\n\n类型断言 vs 类型声明在这个例子中：\nfunction getCacheData(key: string): any &#123;\n    return (window as any).cache[key];\n&#125;\n\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst tom &#x3D; getCacheData(&#39;tom&#39;) as Cat;\ntom.run();\n\n我们使用 as Cat 将 any 类型断言为了 Cat 类型。\n但实际上还有其他方式可以解决这个问题：\nfunction getCacheData(key: string): any &#123;\n    return (window as any).cache[key];\n&#125;\n\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst tom: Cat &#x3D; getCacheData(&#39;tom&#39;);\ntom.run();\n\n上面的例子中，我们通过类型声明的方式，将 tom 声明为 Cat，然后再将 any 类型的 getCacheData(&#39;tom&#39;) 赋值给 Cat 类型的 tom。\n这和类型断言是非常相似的，而且产生的结果也几乎是一样的——tom 在接下来的代码中都变成了 Cat 类型。\n它们的区别，可以通过这个例子来理解：\ninterface Animal &#123;\n    name: string;\n&#125;\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst animal: Animal &#x3D; &#123;\n    name: &#39;tom&#39;\n&#125;;\nlet tom &#x3D; animal as Cat;\n\n在上面的例子中，由于 Animal 兼容 Cat，故可以将 animal 断言为 Cat 赋值给 tom。\n但是若直接声明 tom 为 Cat 类型：\ninterface Animal &#123;\n    name: string;\n&#125;\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst animal: Animal &#x3D; &#123;\n    name: &#39;tom&#39;\n&#125;;\nlet tom: Cat &#x3D; animal;\n\n&#x2F;&#x2F; index.ts:12:5 - error TS2741: Property &#39;run&#39; is missing in type &#39;Animal&#39; but required in type &#39;Cat&#39;.\n\n则会报错，不允许将 animal 赋值为 Cat 类型的 tom。\n这很容易理解，Animal 可以看作是 Cat 的父类，当然不能将父类的实例赋值给类型为子类的变量。\n深入的讲，它们的核心区别就在于：\n\nanimal 断言为 Cat，只需要满足 Animal 兼容 Cat 或 Cat 兼容 Animal 即可\nanimal 赋值给 tom，需要满足 Cat 兼容 Animal 才行\n\n但是 Cat 并不兼容 Animal。\n而在前一个例子中，由于 getCacheData(&#39;tom&#39;) 是 any 类型，any 兼容 Cat，Cat 也兼容 any，故\nconst tom &#x3D; getCacheData(&#39;tom&#39;) as Cat;\n\n等价于\nconst tom: Cat &#x3D; getCacheData(&#39;tom&#39;);\n\n知道了它们的核心区别，就知道了类型声明是比类型断言更加严格的。\n所以为了增加代码的质量，我们最好优先使用类型声明，这也比类型断言的 as 语法更加优雅。\n类型断言 vs 泛型\n\n\n\n\n\n\n\n\n本小节的前置知识点：泛型\n还是这个例子：\nfunction getCacheData(key: string): any &#123;\n    return (window as any).cache[key];\n&#125;\n\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst tom &#x3D; getCacheData(&#39;tom&#39;) as Cat;\ntom.run();\n\n我们还有第三种方式可以解决这个问题，那就是泛型：\nfunction getCacheData&lt;T&gt;(key: string): T &#123;\n    return (window as any).cache[key];\n&#125;\n\ninterface Cat &#123;\n    name: string;\n    run(): void;\n&#125;\n\nconst tom &#x3D; getCacheData&lt;Cat&gt;(&#39;tom&#39;);\ntom.run();\n\n通过给 getCacheData 函数添加了一个泛型 &lt;T&gt;，我们可以更加规范的实现对 getCacheData 返回值的约束，这也同时去除掉了代码中的 any，是最优的一个解决方案。\n参考§\nTypeScript Deep Dive / Type Assertion\nAdvanced Types # Type Guards and Differentiating Types（[中文版](https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Advanced Types.html#类型保护与区分类型（type-guards-and-differentiating-types）)）\nTypeScript 的设计理念\n\n","slug":"typescript/基础/类型断言","date":"2023-01-06T07:14:23.135Z","categories_index":"TypeScript入门","tags_index":"TypeScript,基础","author_index":"木木木"},{"id":"29afe61d2c425b0032ecc379d9200dbe","title":"基础 - 函数的类型","content":"函数的类型函数的声明一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：\nfunction sum(x: number, y:number): number &#123;\n  return x + y\n&#125;\n\n\n\n\n\n\n\n提示\n输入多余的（或者少于要求的）参数，都是不被允许的\n\n函数表达式我们现在写一个对函数的表达式( Function Expression ), 可能会写成这样\nlet mySum &#x3D; function (x: number, y: number): number &#123;\n    return x + y;\n&#125;;\n\n这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 mySum 添加类型，则应该是这样：\nlet mySum: (x: number, y: number) &#x3D;&gt; number &#x3D; function (x: number, y: number): number &#123;\n    return x + y;\n&#125;;\n\n注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。\n在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。\n在 ES6 中，=&gt; 叫做箭头函数，应用十分广泛，可以参考 ES6 中的箭头函数。\n用接口定义函数的形状我们也可以使用接口的方式来定义一个函数需要符合的形状：\ninterface SearchFunc &#123;\n    (source: string, subString: string): boolean;\n&#125;\n\nlet mySearch: SearchFunc;\nmySearch &#x3D; function(source: string, subString: string) &#123;\n    return source.search(subString) !&#x3D;&#x3D; -1;\n&#125;\n\n采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。\n可选参数可选参数必须在必选参数的后面\nfunction buildName(firstName: string, lastName?: string) &#123;\n    if (lastName) &#123;\n        return firstName + &#39; &#39; + lastName;\n    &#125; else &#123;\n        return firstName;\n    &#125;\n&#125;\n\n需要注意的是, 可选参数后面不允许出现比选参数了\n参数默认值在 ES6 中，我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数：\nfunction buildName(firstName: string, lastName: string &#x3D; &#39;Cat&#39;) &#123;\n    return firstName + &#39; &#39; + lastName;\n&#125;\n\n 给了参数默认值后就不受可选参数必须在必选参数的后面的限制了\nfunction buildName(firstName?: string &#x3D; &#39;dog&#39;, lastName: string) &#123;\n    return firstName + &#39; &#39; + lastName;\n&#125;\n\n剩余参数在ES6中, 我们可以使用...items的方式来获取函数中的剩余参数(res参数)\nfunction push(array, ...items) &#123;\n    items.forEach(function(item) &#123;\n        array.push(item);\n    &#125;);\n&#125;\n\nlet a: any[] &#x3D; [];\npush(a, 1, 2, 3);\n\n事实上items是一个数组, 我们可以用数组的形式来定义它\nfunction push(array: any[], ...items: any[]) &#123;\n    items.forEach(function(item) &#123;\n        array.push(item);\n    &#125;);\n&#125;\n\nlet a &#x3D; [];\npush(a, 1, 2, 3);\n\n\n\n\n\n\n\n\n\n\n注意，rest 参数只能是最后一个参数，关于 rest 参数，可以参考 ES6 中的 rest 参数。\n重载重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。\n比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 &#39;hello&#39; 的时候，输出反转的字符串 &#39;olleh&#39;。\n这时，我们可以使用重载定义多个 reverse 的函数类型：\nfunction reverse(x: number): number;\nfunction reverse(x: string): string;\nfunction reverse(x: number | string): number | string | void &#123;\n    if (typeof x &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;\n        return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));\n    &#125; else if (typeof x &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;\n        return x.split(&#39;&#39;).reverse().join(&#39;&#39;);\n    &#125;\n&#125;\n\n上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。\n注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。\n参考\nFunctions（中文版）\nFunctions # Function Types（中文版）\nJS 函数式编程指南\nES6 中的箭头函数\nES6 中函数参数的默认值\nES6 中的 rest 参数\n\n","slug":"typescript/基础/函数的类型","date":"2023-01-06T02:30:32.294Z","categories_index":"TypeScript入门","tags_index":"TypeScript,类型,函数","author_index":"木木木"},{"id":"bb4675de51cf9271a480ed892e5e9379","title":"基础 - 数组的类型","content":"数组的类型在 TypeScript 中，数组类型有多种定义方式，比较灵活。\n「类型 + 方括号」表示法最简单的方法是使用「类型 + 方括号」来表示数组：\nlet fibonacci: number[] &#x3D; [1, 1, 2, 3, 5];\n\n数组的项中不允许出现其他的类型：\nlet fibonacci: number[] &#x3D; [1, &#39;1&#39;, 2, 3, 5];\n\n&#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;number&#39;.\n\n数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：\nlet fibonacci: number[] &#x3D; [1, 1, 2, 3, 5];\nfibonacci.push(&#39;8&#39;);\n\n&#x2F;&#x2F; Argument of type &#39;&quot;8&quot;&#39; is not assignable to parameter of type &#39;number&#39;.\n\n上例中，push 方法只允许传入 number 类型的参数，但是却传了一个 &quot;8&quot; 类型的参数，所以报错了。这里 &quot;8&quot; 是一个字符串字面量类型，会在后续章节中详细介绍。\n数组泛型我们也可以使用数组泛型（Array Generic） Array 来表示数组：\nlet fibonacci: Array&lt;number&gt; &#x3D; [1, 1, 2, 3, 5];\n\n关于泛型，可以参考泛型一章。\n用接口表示数组接口也可以用来描述数组：\ninterface NumberArray &#123;\n    [index: number]: number;\n&#125;\nlet fibonacci: NumberArray &#x3D; [1, 1, 2, 3, 5];\n\nNumberArray 表示：只要索引的类型是数字时，那么值的类型必须是数字。\n虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。\n不过有一种情况例外，那就是它常用来表示类数组。\n类数组类数组（Array-like Object）不是数组类型，比如 arguments：\nfunction sum() &#123;\n    let args: number[] &#x3D; arguments;\n&#125;\n\n&#x2F;&#x2F; Type &#39;IArguments&#39; is missing the following properties from type &#39;number[]&#39;: pop, push, concat, join, and 24 more.\n\n上例中，arguments 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：\nfunction sum() &#123;\n    let args: &#123;\n        [index: number]: number;\n        length: number;\n        callee: Function;\n    &#125; &#x3D; arguments;\n&#125;\n\n在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 length 和 callee 两个属性。\n事实上常用的类数组都有自己的接口定义，如 IArguments, NodeList, HTMLCollection 等：\nfunction sum() &#123;\n    let args: IArguments &#x3D; arguments;\n&#125;\n\n其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是：\ninterface IArguments &#123;\n    [index: number]: any;\n    length: number;\n    callee: Function;\n&#125;\n\n关于内置对象，可以参考内置对象一章。\nany 在数组中的应用一个比较常见的做法是，用 any 表示数组中允许出现任意类型：\ninterface IArguments &#123;\n    [index: number]: any;\n    length: number;\n    callee: Function;\n&#125;\n\n参考\nBasic Types # Array\nInterfaces # Indexable Types\n\n","slug":"typescript/基础/数组的类型","date":"2023-01-05T09:45:01.484Z","categories_index":"TypeScript入门","tags_index":"TypeScript,类型,数组","author_index":"木木木"},{"id":"681258ab14d4e7b50ea459ce622019e2","title":"基础 - 对象的类型——接口","content":"对象的类型——接口在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。\n什么是接口在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。\nTypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。\n简单的例子interface Person &#123;\n    name: string;\n    age: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25\n&#125;;\n\n上面的例子中，我们定义了一个接口 Person，接着定义了一个变量 tom，它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person 一致。\n接口一般首字母大写。有的编程语言中会建议接口的名称加上 I 前缀。\n定义的变量比接口少了一些属性是不允许的：\ninterface Person &#123;\n    name: string;\n    age: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;\n&#125;;\n\n&#x2F;&#x2F; index.ts(6,5): error TS2322: Type &#39;&#123; name: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Property &#39;age&#39; is missing in type &#39;&#123; name: string; &#125;&#39;.\n\n多一些属性也是不允许的：\ninterface Person &#123;\n    name: string;\n    age: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n&#x2F;&#x2F; index.ts(9,5): error TS2322: Type &#39;&#123; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Object literal may only specify known properties, and &#39;gender&#39; does not exist in type &#39;Person&#39;.\n\n可见，赋值的时候，变量的形状必须和接口的形状保持一致。\n可选属性有时我们希望不要完全匹配一个形状，那么可以用可选属性：\ninterface Person &#123;\n    name: string;\n    age?: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;\n&#125;;\n\ninterface Person &#123;\n    name: string;\n    age?: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25\n&#125;;\n\n可选属性的含义是该属性可以不存在。\n这时仍然不允许添加未定义的属性：\ninterface Person &#123;\n    name: string;\n    age?: number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n&#x2F;&#x2F; examples&#x2F;playground&#x2F;index.ts(9,5): error TS2322: Type &#39;&#123; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Object literal may only specify known properties, and &#39;gender&#39; does not exist in type &#39;Person&#39;.\n\n任意属性有时候我们希望一个接口允许有任意的属性，可以使用如下方式：\ninterface Person &#123;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;\n\n使用 [propName: string] 定义了任意属性取 string 类型的值。\n需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的同类型或者子集：\ninterface Person &#123;\n    name: string;\n    age?: number;\n    [propName: string]: string;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n&#x2F;&#x2F; index.ts(3,5): error TS2411: Property &#39;age&#39; of type &#39;number&#39; is not assignable to string index type &#39;string&#39;.\n&#x2F;&#x2F; index.ts(7,5): error TS2322: Type &#39;&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Index signatures are incompatible.\n&#x2F;&#x2F;     Type &#39;string | number&#39; is not assignable to type &#39;string&#39;.\n&#x2F;&#x2F;       Type &#39;number&#39; is not assignable to type &#39;string&#39;.\n\n上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。\n另外，在报错信息中可以看出，此时 &#123; name: &#39;Tom&#39;, age: 25, gender: &#39;male&#39; &#125; 的类型被推断成了 &#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;，这是联合类型和接口的结合。\n一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：\ninterface Person &#123;\n    name: string;\n    age?: number;\n    [propName: string]: string | number;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n只读属性有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性：\ninterface Person &#123;\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    id: 89757,\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;\n\ntom.id &#x3D; 9527;\n\n&#x2F;&#x2F; index.ts(14,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-only property.\n\n上例中，使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了。\n注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：\ninterface Person &#123;\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person &#x3D; &#123;\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;\n\ntom.id &#x3D; 89757;\n\n&#x2F;&#x2F; index.ts(8,5): error TS2322: Type &#39;&#123; name: string; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n&#x2F;&#x2F;   Property &#39;id&#39; is missing in type &#39;&#123; name: string; gender: string; &#125;&#39;.\n&#x2F;&#x2F; index.ts(13,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-only property.\n\n上例中，报错信息有两处，第一处是在对 tom 进行赋值的时候，没有给 id 赋值。\n第二处是在给 tom.id 赋值的时候，由于它是只读属性，所以报错了。\n参考\nInterfaces\n\n","slug":"typescript/基础/对象的类型——接口","date":"2023-01-05T08:16:54.245Z","categories_index":"TypeScript入门","tags_index":"TypeScript,类型","author_index":"木木木"},{"id":"b1398d75ab86fa5e1ccefc06f04a3c6f","title":"基础 - 联合类型","content":"联合类型联合类型（Union Types）表示取值可以为多种类型中的一种。\nlet myFavoriteNumber: string | number;\nmyFavoriteNumber &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\nlet myFavoriteNumber: string | number;\nmyFavoriteNumber &#x3D; true;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;boolean&#39; is not assignable to type &#39;string | number&#39;.\n&#x2F;&#x2F;   Type &#39;boolean&#39; is not assignable to type &#39;number&#39;.\n\n\n\n\n\n\n\n提示\n联合类型使用 | 分隔每个类型。\n这里的 let myFavoriteNumber: string | number 的含义是，允许 myFavoriteNumber 的类型是 string 或者 number，但是不能是其他类型。\n\n访问联合类型的属性或方法当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：\nfunction getLength(something: string | number): number &#123;\n    return something.length;\n&#125;\n\n&#x2F;&#x2F; index.ts(2,22): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.\n&#x2F;&#x2F;   Property &#39;length&#39; does not exist on type &#39;number&#39;.\n\n上例中，length 不是 string 和 number 的共有属性，所以会报错。\n访问 string 和 number 的共有属性是没问题的：\nfunction getString(something: string | number): string &#123;\n    return something.toString();\n&#125;\n\n联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：\nlet myFavoriteNumber: string | number;\nmyFavoriteNumber &#x3D; &#39;seven&#39;;\nconsole.log(myFavoriteNumber.length); &#x2F;&#x2F; 5\nmyFavoriteNumber &#x3D; 7;\nconsole.log(myFavoriteNumber.length); &#x2F;&#x2F; 编译时报错\n\n&#x2F;&#x2F; index.ts(5,30): error TS2339: Property &#39;length&#39; does not exist on type &#39;number&#39;.\n\n参考\nAdvanced Types # Union Types\n\n","slug":"typescript/基础/联合类型","date":"2023-01-05T08:05:08.103Z","categories_index":"TypeScript入门","tags_index":"TypeScript,类型","author_index":"木木木"},{"id":"60214032119e37fbea15a4db1ead45d9","title":"基础 - 类型推论","content":"类型推论如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。\n什么是类型推论以下代码虽然没有指定类型，但是会在编译的时候报错:\nlet myFavoriteNumber &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;\n\n事实上，它等价于：\nlet myFavoriteNumber: string &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.\n\nTypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。\n如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：\nlet myFavoriteNumber;\nmyFavoriteNumber &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n参考\nType Interface\n\n","slug":"typescript/基础/类型推论","date":"2023-01-05T07:51:40.501Z","categories_index":"TypeScript入门","tags_index":"TypeScript,基础","author_index":"木木木"},{"id":"4a36cb26fb4c51b35df980776346e43b","title":"基础 - 任意值","content":"任意值任意值（Any）用来表示允许赋值为任意类型。\n什么是任意值类型如果是一个普通类型，在赋值过程中改变类型是不被允许的：\nlet myFavoriteNumber: string &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n&#x2F;&#x2F; index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.\n\n但如果是 any 类型，则允许被赋值为任意类型\nlet myFavoriteNumber: any &#x3D; &#39;seven&#39;;\nmyFavoriteNumber &#x3D; 7;\n\n任意值的属性和方法在任意值上访问任何属性都是允许的：\nlet anyThing: any &#x3D; &#39;hello&#39;;\nconsole.log(anyThing.myName);\nconsole.log(anyThing.myName.firstName);\n\n也可以调用任何方法\nlet anyThing: any &#x3D; &#39;Tom&#39;;\nanyThing.setName(&#39;Jerry&#39;);\nanyThing.setName(&#39;Jerry&#39;).sayHello();\nanyThing.myName.setFirstName(&#39;Cat&#39;);\n\n可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值\n未声明类型的变量变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：\nlet something;\nsomething &#x3D; &#39;seven&#39;;\nsomething &#x3D; 7;\n\nsomething.setName(&#39;Tom&#39;);\n\n等价于\nlet something: any;\nsomething &#x3D; &#39;seven&#39;;\nsomething &#x3D; 7;\n\nsomething.setName(&#39;Tom&#39;);\n\n参考\nBasic Types # Any（中文版）\n\n","slug":"typescript/基础/任意值","date":"2023-01-05T07:02:13.455Z","categories_index":"TypeScript入门","tags_index":"TypeScript,基础","author_index":"木木木"},{"id":"95785751ac1389398263330b9b39fc70","title":"基础","content":"基础\n\n\n\n\n\n\n\n\n本部分介绍了 TypeScript 中的常用类型和一些基本概念，旨在让大家对 TypeScript 有个初步的理解。具体内容包括：\n\n原始数据类型\n\n任意值\n\n类型推论\n\n联合类型\n\n对象的类型——接口\n\n数组的类型\n\n函数的类型\n\n类型断言\n\n声明文件\n\n内置对象\n\n","slug":"typescript/基础/基础","date":"2023-01-05T02:27:24.372Z","categories_index":"TypeScript入门","tags_index":"TypeScript,基础","author_index":"木木木"},{"id":"78e5ff641c0f32df664f03d82148a661","title":"基础 - 原始数据类型","content":"基础 - 原始数据类型JavaScript的数据类型分为两种: 原始数据类型(Primitive Data types)和对象类型(Object types)\n原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。\n布尔值布尔值是最基础的数据类型, 在TypeScript中, 使用 boolean布尔值类型\nlet isMan: boolean &#x3D; true\n\n&#x2F;&#x2F; 编译通过\n\n\n\n\n\n\n\n提示\n注意，使用构造函数 Boolean 创造的对象不是布尔值：\n\nlet createByNewBoolean: boolean &#x3D; new Boolean(1)\n\n&#x2F;&#x2F; 此时会编译报错\n&#x2F;&#x2F; Type &#39;Boolean&#39; is not assignable to type &#39;boolean&#39;.\n&#x2F;&#x2F;   &#39;boolean&#39; is a primitive, but &#39;Boolean&#39; is a wrapper object. Prefer using &#39;boolean&#39; when possible.\n\n事实上 new Boolean() 返回的是一个Boolean对象:\n\n\n\n\n\n\n提示\n直接调用Boolean也可以返回一个boolean类型\nlet createdByBoolean: boolean &#x3D; Boolean(1);\n\n\n\n在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。\n数值使用 number定义数值类型\nlet decLiteral: number &#x3D; 6;\nlet hexLiteral: number &#x3D; 0xf00d;\n&#x2F;&#x2F; ES6 中的二进制表示法\nlet binaryLiteral: number &#x3D; 0b1010;\n&#x2F;&#x2F; ES6 中的八进制表示法\nlet octalLiteral: number &#x3D; 0o744;\nlet notANumber: number &#x3D; NaN;\nlet infinityNumber: number &#x3D; Infinity;\n\ntsc的编译结果\nvar decLiteral &#x3D; 6;\nvar hexLiteral &#x3D; 0xf00d;\n&#x2F;&#x2F; ES6 中的二进制表示法\nvar binaryLiteral &#x3D; 10;\n&#x2F;&#x2F; ES6 中的八进制表示法\nvar octalLiteral &#x3D; 484;\nvar notANumber &#x3D; NaN;\nvar infinityNumber &#x3D; Infinity;\n\n其中 0b1010 和 0o744 是 ES6 中的二进制和八进制表示法，它们会被编译为十进制数字。\n字符串使用 string定义字符串类型\nlet str: string &#x3D; &#39;jeck&#39;\n\n&#x2F;&#x2F; 模板字符串\nlet str_o: string &#x3D; &#96;my name is $&#123;str&#125;&#96;\n\n编译结果:\nvar str &#x3D; jeck\n\n&#x2F;&#x2F; 模板字符串\nvar str_o &#x3D; &#39;my name is&#39; + str\n\n空值JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：\nfunction alertName(): void &#123;\n    alert(&#39;My name is Tom&#39;);\n&#125;\n\n声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null（只在 –strictNullChecks 未指定时）：\nlet unusable: void &#x3D; undefined;\n\nNull 和 Undefined在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：\nlet u: undefined &#x3D; undefined;\nlet n: null &#x3D; null;\n\n\n\n\n\n\n\n\n\n\n与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：\n&#x2F;&#x2F; 这样不会报错\nlet num: number &#x3D; undefined;\n\n&#x2F;&#x2F; 这样也不会报错\nlet u: undefined;\nlet num: number &#x3D; u;\n\n而 void 类型的变量不能赋值给 number 类型的变量：\nlet u: void;\nlet num: number &#x3D; u;\n\n&#x2F;&#x2F; Type &#39;void&#39; is not assignable to type &#39;number&#39;.\n\n参考\nBasic Types（中文版）\nPrimitive data types\nES6 中的新类型 Symbol\nES6 中的二进制和八进制表示法\nES6 中的模板字符串\n\n","slug":"typescript/基础/原始数据类型","date":"2023-01-05T02:23:28.205Z","categories_index":"TypeScript入门","tags_index":"TypeScript,基础","author_index":"木木木"},{"id":"1e85ed2976471a124c7c5c4dd3f1cabd","title":"Docker 镜像的使用","content":"列出镜像列表我们可以使用 docker images 来列出本地主机上的镜像\n$ docker images\n\n选项说明\nREPOSITORY: 表示镜像的仓库源\nTAG:　镜像的标签\nIMAGE ID: 镜像ID\nCREATED: 镜像的创建时间\nSIZE: 镜像大小\n\n\n\n\n\n\n\n\n同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。\n\n\n获取一个新的镜像当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。\ndocker pull centos:8\n当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。\n查找镜像我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： https://hub.docker.com/我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。\n$ docker search httpd\n\n选项说明\nNAME: 镜像仓库源名称\nDESCRIPTION: 镜像的描述\nOFFICIAL: 是否 docker 官方发布\nSTARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。\nAUTOMATED: 自动构建。拖取镜像$ docker pull httpd\n下载完后我们就可以使用这个镜像了$ docker run httpd\n删除镜像$ docker rmi httpd\n\n","slug":"docker/Docker 镜像的使用","date":"2023-01-03T07:15:43.000Z","categories_index":"Docker","tags_index":"镜像,Docker,images","author_index":"木木木"},{"id":"dc1fbac9dbffcd89c2c867f0e7ab4b37","title":"Docker 容器的使用","content":"网络端口映射有以下两种端口映射方式\ndocker run -itd -P --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash\ndocker run -itd -p 1000:22 --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash\n参数说明\n-i：交互式操作\n\n-t: 终端\n\n-d: 后台运行\n\n-p 1000:22 :以指定的1000端口映射容器的22端口\n\n-P: 容器内部端口随机映射到主机端口\n\n–name: 容器别名\n\ndokken/centos-8: 容器源名称\n\n/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n区别\n-P :是容器内部端口随机映射到主机的端口。\n\n-p : 是容器内部端口绑定到指定的主机端口。\n\n\n另外, 我们可以指定容器绑定的网络地址, 比如绑定 127.0.0.1\ndocker run -itd -p 127.0.0.1:1000:22 --name centos8 dokken&#x2F;centos-8 &#x2F;bin&#x2F;bash\n这样我们就可以通过127.0.0.1:1000来访问容器的22端口了\n","slug":"docker/Docker 容器连接","date":"2023-01-03T07:13:50.000Z","categories_index":"Docker","tags_index":"Docker,容器,container","author_index":"木木木"},{"id":"dc1fbac9dbffcd89c2c867f0e7ab4b37","title":"Docker 容器的使用","content":"获取容器我们可以使用docker pull 命令来下载 centos镜像\n$ docker pull centos8\n启动容器$ docker run -it centos8 &#x2F;bin&#x2F;bash\n参数说明\n-i：交互式操作\n-t: 终端\ncentos8：centos8镜像\n/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n\n如果要退出终端那就使用\n$ exit\n查看所有容器$ docker ps -a\n启动一个已经停止的容器$ docker start b750bbbcfd88(容器id)\n停止一个已经启动的容器$ docker stop b750bbbcfd88(容器id)\n后台运行容器(不想进入容器的时候)$ docker -itd --name content_8 centos8 &#x2F;bin&#x2F;bash\n参数说明\n-i：交互式操作\n\n-t: 终端\n\n-d: 后台运行\n\n–name: 运行时指定容器的名称\n\n/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n进入容器在使用参数 -d 时, 容器会进入后台, 这个时候如果想要进入容器内部可以使用以下命令\n$ docker exec -it [容器ID] &#x2F;bin&#x2F;bash\n参数说明\n-i：交互式操作\n\n-t: 终端\n\n/bin/bash：这里我们希望有一个交互式的 Shell ，因此用的就是 /bin/bash\n导入和导出容器导出容器如果要导出到本地的某个容器, 可以使用 docker export 命令\n$ docker export [容器ID] &gt; centos8.tar\n\n\n\n\n\n\n\n\n\n导出容器ID到本地文件的 centos8.tar\n\n\n导入容器$ cat docker&#x2F;ubuntu.tar | docker import - test&#x2F;ubuntu:v1\n此外, 还可以通过指定URL或某个目录来导入\n$ docker import http:&#x2F;&#x2F;example.com&#x2F;exampleimage.tgz example&#x2F;imagerepo\n删除容器$ docker rm -f [容器ID]\n清除所有处于终止状态下的容器\n$ docker container prune\n\n","slug":"docker/Docker 容器的使用","date":"2022-12-06T08:00:12.000Z","categories_index":"Docker","tags_index":"Docker,容器,container","author_index":"木木木"},{"id":"38e6c7f2663dfaf0d43db7ca2bc52b5c","title":"webpack 创建简单的 ts 开发环境","content":"webpack 创建简单的 ts 开发环境前置要求需要的的 npm 插件\n\n\n\n\n\n\n\n\n\n\nwebpack ( webpack 本体 )\nwebpack-cli ( webpack 的命令行工具 )\ntypescript ( typescript 核心代码 )\nts-loader (typescript 的 webpck 编译模块)\nclean-webpack-plugin ( 打包前清除之前打包的文件夹 )\n\nts 开发环境目录\ntsconfig.json 配置&#123;\n  &quot;compilerOptions&quot;: &#123;\n\n    &quot;module&quot;: &quot;ES6&quot;,             &#x2F;&#x2F; 使用的模块规则\n\n    &quot;target&quot;: &quot;ES6&quot;,             &#x2F;&#x2F; 编译生成 js 的版本\n\n    &quot;noImplicitAny&quot;: true,       &#x2F;&#x2F; 不允许隐式的 any 类型\n\n    &quot;removeComments&quot;: true,      &#x2F;&#x2F; 删除注释\n\n    &quot;preserveConstEnums&quot;: true,  &#x2F;&#x2F; 保留 const 和 enum 声明\n\n    &quot;strict&quot;: true               &#x2F;&#x2F; 使用严格模式\n  &#125;,\n\n  &#x2F;&#x2F; 需要编译的 ts 文件\n  &quot;include&quot;: [\n    &quot;.&#x2F;src&#x2F;**&#x2F;*&quot;\n  ]\n&#125;\n\nwebpack.config.js 配置基本配置const path &#x3D; require(&quot;path&quot;)\nconst &#123; CleanWebpackPlugin &#125; &#x3D; require(&quot;clean-webpack-plugin&quot;)\n\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; 入口文件\n  entry: &quot;.&#x2F;src&#x2F;index.ts&quot;,\n\n  &#x2F;&#x2F; 打包后的出口文件\n  output: &#123;\n    &#x2F;&#x2F; 文件路径\n    path: path.resolve(__dirname, &quot;dist&quot;),\n\n    &#x2F;&#x2F; 文件名\n    filename: &quot;bundle.js&quot;,\n  &#125;,\n  &#x2F;&#x2F; 使用的编译模块\n  module: &#123;\n\n    &#x2F;&#x2F; 指定要加载的规则\n    rules: [\n      &#123;\n        &#x2F;&#x2F; test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n        test: &#x2F;\\.ts$&#x2F;,\n\n        &#x2F;&#x2F; 要使用的 loader\n        use: [&#39;ts-loader&#39;],\n\n        &#x2F;&#x2F; 排除要编译的文件夹\n        exclude: &#x2F;node_modules&#x2F;\n      &#125;\n    ]\n  &#125;,\n\n  &#x2F;&#x2F; 用来设置需要引用的模块文件 (这里包括了 ts 和 js) 不设置的话, 引用其他 ts&#x2F;js 文件会编译报错\n  resolve: &#123;\n    extensions: [&#39;.ts&#39;, &#39;.js&#39;]\n  &#125;,\n\n  &#x2F;&#x2F; 配置 webpack 插件\n  plugins: [\n    new CleanWebpackPlugin()\n  ],\n&#125;\n\n使用 html 文件配置\n\n\n\n\n\n\n\n\n前端项目中我们编译完的 js 文件最终会用到 html 文件中. 我们手动创建并引入 js 的话也不是不行, 但是很麻烦, 如果以后要增加一些其他的 js 或者 css 都得重新去手动引入. 这时候就可以用 webpack 给我们提供的一个自动引入经过 loader 编译后的文件 html 的插件 html-webpack-plugin\n**_npm install -D html-webpack-plugin_**\n在最外层的 plugins 中配置\n更多 html-webpack-plugin 的配置信息看这里\n&#x2F;&#x2F; 引入插件\nconst HtmlWebpackPlugin &#x3D; require(&quot;html-webpack-plugin&quot;)\n\nmodule.exprots &#x3D; &#123;\n  &#x2F;&#x2F; 配置 webpack 插件\n  plugins: [\n    new HtmlWebpackPlugin(&#123;\n      &#x2F;&#x2F; 配置 html 模板文件的目录\n      template: path.resolve(__dirname, &#39;public&#x2F;index.html&#39;)\n    &#125;)\n  ],\n&#125;\n\n使用 webpack-server 实时编译\n\n\n\n\n\n\n\n\n弄好 html 自动引入后我们需要打开网页去调试我们的 ts 程序, 按照普通方式来修改一次又要打包一遍, 又要重新刷新一遍网页的话就很麻烦, 这时我们可以用 webpack-server 来进行开发服务器部署\n**_npm install -D webpack-server_**\n安装完后直接在 package.json 中进行配置运行命令运行就行了\n&#123;\n  &quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;webpack server --mode development&quot;\n  &#125;\n&#125;\n\n配置 babel 来进行浏览器兼容在日常的开发中我们会经常遇到要兼容低版本浏览器的需要, 这时候为了增加开发效率我们可以用 **_babel_** 来将一些 **_ES6_** 中的高级属性来转换为低版本浏览器中的兼容属性\n需要的开发依赖\n\n\n\n\n\n\n\n\n\n\n@babel/core ( babel 的核心代码 )\n@babel/preset-env ( babel 的兼容库 )\ncore-js ( 高级属性的兼容性替代方案 )\n\n\n\n\n\n\n\n\n\n\n**_npm install -D @babel/core @babel/preset-env core-js_**\nwebpack 配置\n\nmodule.exports &#x3D; &#123;\n\n  &#x2F;&#x2F; 使用的编译模块\n  module: &#123;\n    &#x2F;&#x2F; 指定要加载的规则\n    rules: [\n      &#123;\n        &#x2F;&#x2F; test 是指定规则生效的文件(既对那些文件进行编译), 使用的是正则\n        test: &#x2F;\\.ts$&#x2F;,\n\n        &#x2F;&#x2F; 要使用的 loader\n        use: [\n\n          &#x2F;&#x2F; 配置 babel\n          &#123;\n            &#x2F;&#x2F; 指定要用的加载器\n            loader: &#39;babel-loader&#39;,\n\n            options: &#123;\n              &#x2F;&#x2F; 设置预定义的环境\n              presets: [\n                [\n                  &quot;@babel-preset-env&quot;,\n\n                  &#123;\n                    &#x2F;&#x2F; 需要兼容的目标浏览器, 根据项目需求填写\n                    targets: &#123;\n                      &quot;chrome&quot;: 95\n                    &#125;,\n\n                    &#x2F;&#x2F; 指定的 core 版本\n                    &quot;corejs&quot;: &#39;3&#39;,\n\n                    &#x2F;&#x2F; 使用 corejs 的方式 &quot;usage&quot; 按需加载\n                    &quot;useBuiltIns&quot;: &quot;usage&quot;\n                  &#125;\n                ]\n              ]\n            &#125;\n          &#125;,\n\n          &#x2F;&#x2F; 由于 webpack 中 rules 是从数组从后往前执行的, 所以 ts-loader 放在后面, 让 ts 先编译为 js 在通过 babel 进行兼容性转换\n          &#39;ts-loader&#39;\n        ],\n      &#125;\n    ]\n  &#125;\n&#125;\n","slug":"typescript/webpack 搭建 ts 开发环境","date":"2022-03-05T08:55:46.000Z","categories_index":"TypeScript","tags_index":"TypeScript,环境搭建,webpack","author_index":"木木木"},{"id":"2eed4986ddc0b5ad3de17ce564c45e28","title":"TypeScript的数据类型","content":"TypeScript的数据类型\n\n\n\n\n\n\n\n\n变量一但定义了某个数据类型后就不允许赋值其他数据类型的数值了\n基础数据类型numberstringbooleanvoidnullundefindedany (使用 TS 时不建议使用 any 类型)&#x2F;&#x2F; 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet d; &lt;&#x3D;&gt; let d: any;\n\n&#x2F;&#x2F; any 类型还可以赋值给任意类型的变量\nlet s: string;\ns &#x3D; d &#x2F;&#x2F; 这时候是成立的\n\nunknown&#x2F;&#x2F; 声明类型时如果不指定类型或者不赋值,则 ts 解析器会自动判断变量为 any 类型\nlet un: unknown;\n\n&#x2F;&#x2F; any 类型还可以赋值给任意类型的变量\nlet s: string;\ns &#x3D; un &#x2F;&#x2F; 这时候是不成立的\n&#x2F;&#x2F; 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n&#x2F;&#x2F; unknown 实际上就是一个类型安全的 any\n&#x2F;&#x2F; unknown 类型的变量不能直接赋值给其他类型的变量,可以间接实现\nif (typeof un &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;\n  s &#x3D; un; &#x2F;&#x2F; 由于先进行了类型判断, 所以这时候赋值是成立的\n&#125;\n\nenum(枚举类型)&#x2F;&#x2F; 使用场景\nenum Gender &#123;\n  male,\n  female\n&#125;\n\nlet p: &#123; name: string, gender: Gender &#125;\np &#x3D; &#123;\n  name: &#39;林丹&#39;,\n  gnder: Gender.male\n&#125;\n\n引用数据类型arrayobject&#x2F;&#x2F; 基础的定义方式\n&#x2F;&#x2F; 由于在 js 中几乎万物皆是对象,所以不推荐这样使用\nlet o: object\no &#x3D; &#123;&#125;\no &#x3D; function\n\n&#x2F;&#x2F; 可以用字面量的方式\nlet o1: &#123; name: string, age: number &#125;\no1 &#x3D; &#123; name: &#39;hanler&#39;, age: 12 &#125;\n\n&#x2F;&#x2F; 如果要可选常数则在常数后面加个问号\nlet o2: &#123; name: string, age?: number &#125;\no2 &#x3D; &#123; name: &#39;hehe&#39; &#125;\n\n&#x2F;&#x2F; 当你需要一个固定值, 但是又需要其他值且不清楚数量的时候可以像以下定义\n&#x2F;**\n * @param &#123;string&#125; propsName 这个是属性名, 后面的 string 代表的是 string 格式的属性名\n * 中括号后面的 string 代表的是属性(propsName)的值的格式\n * *&#x2F;\nlet o3: &#123; name: string, [propsName: string]: string &#125;\no3 &#x3D; &#123; name: &#39;str&#39;, age: &#39;12&#39; &#125;\n\n类型断言\n\n\n\n\n\n\n\n\n可以用来告诉 ts 解析器变量的实际数据类型\nlet un: nuknown;\nun &#x3D; &#39;string&#39;\n\nlet s: string;\n\ns &#x3D; un; &#x2F;&#x2F; 此时是不成立的\n&#x2F;&#x2F; 由于 un 是 unknow 类型的(未知类型数值), 是不能赋值给 string 类型的\n\n&#x2F;&#x2F; 由于此时的 un 确实是 string 类型,我们可以使用类型断言来告诉解析器 un 就是 string 类型的来解决解析器报错问题\n\n&#x2F;&#x2F; 两种写法\ns &#x3D; un as string;\ns &#x3D; &lt;string&gt;un;\n","slug":"typescript/TypeScript的数据类型","date":"2022-03-05T08:47:36.000Z","categories_index":"TypeScript","tags_index":"TypeScript,数据类型","author_index":"木木木"},{"id":"56833ebc3b5ebf1e1226fc895706e9a1","title":"tsconfig.json 编译配置","content":"tsconfig.json 编译配置&#123;\n  &#x2F;&#x2F; 设置保存文件的时候自动编译，但需要编译器支持。\n  &quot;compileOnSave&quot;: false,\n\n  &#x2F;&#x2F; 编译选项配置\n  &quot;compilerOptions&quot;: &#123;\n    &quot;incremental&quot;: true, &#x2F;&#x2F; TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n\n    &quot;tsBuildInfoFile&quot;: &quot;.&#x2F;buildFile&quot;, &#x2F;&#x2F; 增量编译文件的存储位置\n\n    &quot;diagnostics&quot;: true, &#x2F;&#x2F; 打印诊断信息\n\n    &quot;target&quot;: &quot;ES5&quot;, &#x2F;&#x2F; 目标语言的版本\n\n    &quot;module&quot;: &quot;CommonJS&quot;, &#x2F;&#x2F; 生成代码的模板标准\n\n    &quot;outFile&quot;: &quot;.&#x2F;app.js&quot;, &#x2F;&#x2F; 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置&quot;module&quot;: &quot;AMD&quot;,\n\n    &quot;lib&quot;: [&quot;DOM&quot;, &quot;ES2015&quot;, &quot;ScriptHost&quot;, &quot;ES2019.Array&quot;], &#x2F;&#x2F; TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入&quot;ES2019.Array&quot;,\n\n    &quot;allowJS&quot;: true, &#x2F;&#x2F; 允许编译器编译JS，JSX文件\n\n    &quot;checkJs&quot;: true, &#x2F;&#x2F; 允许在JS文件中报错，通常与allowJS一起使用\n\n    &quot;outDir&quot;: &quot;.&#x2F;dist&quot;, &#x2F;&#x2F; 指定输出目录\n\n    &quot;rootDir&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 指定输出文件目录(用于输出)，用于控制输出目录结构\n\n    &quot;declaration&quot;: true, &#x2F;&#x2F; 生成声明文件，开启后会自动生成声明文件\n\n    &quot;declarationDir&quot;: &quot;.&#x2F;file&quot;, &#x2F;&#x2F; 指定生成声明文件存放目录\n\n    &quot;emitDeclarationOnly&quot;: true, &#x2F;&#x2F; 只生成声明文件，而不会生成js文件\n\n    &quot;sourceMap&quot;: true, &#x2F;&#x2F; 生成目标文件的sourceMap文件\n\n    &quot;inlineSourceMap&quot;: true, &#x2F;&#x2F; 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n\n    &quot;declarationMap&quot;: true, &#x2F;&#x2F; 为声明文件生成sourceMap\n\n    &quot;typeRoots&quot;: [], &#x2F;&#x2F; 声明文件目录，默认时node_modules&#x2F;@types\n\n    &quot;types&quot;: [], &#x2F;&#x2F; 加载的声明文件包\n\n    &quot;removeComments&quot;:true, &#x2F;&#x2F; 删除注释\n\n    &quot;noEmit&quot;: true, &#x2F;&#x2F; 不输出文件,即编译后不会生成任何js文件\n\n    &quot;noEmitOnError&quot;: true, &#x2F;&#x2F; 发送错误时不输出任何文件\n\n    &quot;noEmitHelpers&quot;: true, &#x2F;&#x2F; 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n\n    &quot;importHelpers&quot;: true, &#x2F;&#x2F; 通过tslib引入helper函数，文件必须是模块\n\n    &quot;downlevelIteration&quot;: true, &#x2F;&#x2F; 降级遍历器实现，如果目标源是es3&#x2F;5，那么遍历器会有降级的实现\n\n    &quot;strict&quot;: true, &#x2F;&#x2F; 开启所有严格的类型检查\n\n    &quot;alwaysStrict&quot;: true, &#x2F;&#x2F; 在代码中注入&#39;use strict&#39;\n\n    &quot;noImplicitAny&quot;: true, &#x2F;&#x2F; 不允许隐式的any类型\n\n    &quot;strictNullChecks&quot;: true, &#x2F;&#x2F; 不允许把null、undefined赋值给其他类型的变量\n\n    &quot;strictFunctionTypes&quot;: true, &#x2F;&#x2F; 不允许函数参数双向协变\n\n    &quot;strictPropertyInitialization&quot;: true, &#x2F;&#x2F; 类的实例属性必须初始化\n\n    &quot;strictBindCallApply&quot;: true, &#x2F;&#x2F; 严格的bind&#x2F;call&#x2F;apply检查\n\n    &quot;noImplicitThis&quot;: true, &#x2F;&#x2F; 不允许this有隐式的any类型\n\n    &quot;noUnusedLocals&quot;: true, &#x2F;&#x2F; 检查只声明、未使用的局部变量(只提示不报错)\n\n    &quot;noUnusedParameters&quot;: true, &#x2F;&#x2F; 检查未使用的函数参数(只提示不报错)\n\n    &quot;noFallthroughCasesInSwitch&quot;: true, &#x2F;&#x2F; 防止switch语句贯穿(即如果没有break语句后面不会执行)\n\n    &quot;noImplicitReturns&quot;: true, &#x2F;&#x2F;每个分支都会有返回值\n\n    &quot;esModuleInterop&quot;: true, &#x2F;&#x2F; 允许export&#x3D;导出，由import from 导入\n\n    &quot;allowUmdGlobalAccess&quot;: true, &#x2F;&#x2F; 允许在模块中全局变量的方式访问umd模块\n\n    &quot;moduleResolution&quot;: &quot;node&quot;, &#x2F;&#x2F; 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n\n    &quot;baseUrl&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 解析非相对模块的基地址，默认是当前目录\n\n    &quot;paths&quot;: &#123; &#x2F;&#x2F; 路径映射，相对于baseUrl\n      &#x2F;&#x2F; 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n      &quot;jquery&quot;: [&quot;node_modules&#x2F;jquery&#x2F;dist&#x2F;jquery.min.js&quot;]\n    &#125;,\n\n    &quot;rootDirs&quot;: [&quot;src&quot;,&quot;out&quot;], &#x2F;&#x2F; 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n\n    &quot;listEmittedFiles&quot;: true, &#x2F;&#x2F; 打印输出文件\n\n    &quot;listFiles&quot;: true&#x2F;&#x2F; 打印编译的文件(包括引用的声明文件)\n  &#125;,\n\n  &#x2F;&#x2F; include 属性作用是指定编译需要编译的文件或目录。\n  &quot;include&quot;: [&quot;.&#x2F;src&#x2F;**&#x2F;*&quot;],\n\n  &#x2F;&#x2F; exclude 属性作用是指定编译器需要排除的文件或文件夹。默认排除 node_modules 文件夹下文件。\n  &quot;exclude&quot;: [&quot;.&#x2F;utils&#x2F;**&#x2F;*&quot;],\n\n  &#x2F;&#x2F; extends 属性作用是引入其他配置文件，继承配置。\n  &quot;extends&quot;: &quot;.&#x2F;tsconfig.base.json&quot;,\n\n  &#x2F;&#x2F; files 属性作用是指定需要编译的单个文件列表。 默认包含当前目录和子目录下所有 TypeScript 文件。\n  &quot;files&quot;: [\n    &#x2F;&#x2F; 指定编译文件是src目录下的leo.ts文件\n    &quot;scr&#x2F;leo.ts&quot;\n  ],\n\n  &#x2F;&#x2F; references 属性作用是指定工程引用依赖。\n  &#x2F;&#x2F; 在项目开发中，有时候我们为了方便将前端项目和后端node项目放在同一个目录下开发，两个项目依赖同一个配置文件和通用文件，但我们希望前后端项目进行灵活的分别打包，那么我们可以进行如下配置：\n  &quot;references&quot;: [ &#x2F;&#x2F; 指定依赖的工程\n    &#123;&quot;path&quot;: &quot;.&#x2F;common&quot;&#125;\n  ],\n\n  &#x2F;&#x2F; typeAcquisition 属性作用是设置自动引入库类型定义文件(.d.ts)相关。\n  &#x2F;&#x2F; enable  : 布尔类型，是否开启自动引入库类型定义文件(.d.ts)，默认为 false；\n  &#x2F;&#x2F; include  : 数组类型，允许自动引入的库名，如：[&quot;jquery&quot;, &quot;lodash&quot;]；\n  &#x2F;&#x2F; exculde  : 数组类型，排除的库名。\n  &quot;typeAcquisition&quot;: &#123;\n    &quot;enable&quot;: false,\n    &quot;exclude&quot;: [&quot;jquery&quot;],\n    &quot;include&quot;: [&quot;jest&quot;]\n  &#125;\n&#125;\n","slug":"typescript/tsconfig.json 编译配置","date":"2022-03-05T08:40:02.000Z","categories_index":"TypeScript","tags_index":"TypeScript,tsconfig","author_index":"木木木"}]