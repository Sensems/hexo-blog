{"title":"进阶 - 泛型","uid":"d6f1b6e982ce476d664aab7cf5051e90","slug":"typescript/进阶/泛型","date":"2023-01-13T06:55:07.240Z","updated":"2023-01-13T07:12:32.840Z","comments":true,"path":"api/articles/typescript/进阶/泛型.json","keywords":null,"cover":"https://api.onedrive.com/v1.0/shares/s!AkvcybxHlBS0kAEgrAsbNR5Gj39i/root/content","content":"<h1 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h1><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>\n<h2 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h2><p>首先，我们来实现一个函数 <code>createArray</code>，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function createArray(length: number, value: any): Array&lt;any&gt; &#123;\n    let result &#x3D; [];\n    for (let i &#x3D; 0; i &lt; length; i++) &#123;\n        result[i] &#x3D; value;\n    &#125;\n    return result;\n&#125;\n\ncreateArray(3, &#39;x&#39;); &#x2F;&#x2F; [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]</code></pre>\n\n<p>上例中，我们使用了<a href=\"https://ts.xcatliu.com/basics/type-of-array.html#%E6%95%B0%E7%BB%84%E6%B3%9B%E5%9E%8B\">之前提到过的数组泛型</a>来定义返回值的类型。</p>\n<p>这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：</p>\n<p><code>Array&lt;any&gt;</code> 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的 <code>value</code> 的类型。</p>\n<p>这时候，泛型就派上用场了：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;\n    let result: T[] &#x3D; [];\n    for (let i &#x3D; 0; i &lt; length; i++) &#123;\n        result[i] &#x3D; value;\n    &#125;\n    return result;\n&#125;\n\ncreateArray&lt;string&gt;(3, &#39;x&#39;); &#x2F;&#x2F; [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]</code></pre>\n\n<p>上例中，我们在函数名后添加了 <code>&lt;T&gt;</code>，其中 <code>T</code> 用来指代任意输入的类型，在后面的输入 <code>value: T</code> 和输出 <code>Array&lt;T&gt;</code> 中即可使用了。</p>\n<p>接着在调用的时候，可以指定它具体的类型为 <code>string</code>。当然，也可以不手动指定，而让类型推论自动推算出来：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;\n    let result: T[] &#x3D; [];\n    for (let i &#x3D; 0; i &lt; length; i++) &#123;\n        result[i] &#x3D; value;\n    &#125;\n    return result;\n&#125;\n\ncreateArray(3, &#39;x&#39;); &#x2F;&#x2F; [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]</code></pre>\n\n<h2 id=\"多个类型参数\"><a href=\"#多个类型参数\" class=\"headerlink\" title=\"多个类型参数\"></a>多个类型参数</h2><p>定义泛型的时候，可以一次定义多个类型参数：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123;\n    return [tuple[1], tuple[0]];\n&#125;\n\nswap([7, &#39;seven&#39;]); &#x2F;&#x2F; [&#39;seven&#39;, 7]</code></pre>\n\n<p>上例中，我们定义了一个 <code>swap</code> 函数，用来交换输入的元组。</p>\n<h2 id=\"泛型约束\"><a href=\"#泛型约束\" class=\"headerlink\" title=\"泛型约束\"></a>泛型约束</h2><p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function loggingIdentity&lt;T&gt;(arg: T): T &#123;\n    console.log(arg.length);\n    return arg;\n&#125;\n\n&#x2F;&#x2F; index.ts(2,19): error TS2339: Property &#39;length&#39; does not exist on type &#39;T&#39;.</code></pre>\n\n<p>上例中，泛型 <code>T</code> 不一定包含属性 <code>length</code>，所以编译的时候报错了。</p>\n<p>这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 <code>length</code> 属性的变量。这就是泛型约束：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Lengthwise &#123;\n    length: number;\n&#125;\n\nfunction loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;\n    console.log(arg.length);\n    return arg;\n&#125;</code></pre>\n\n<p>上例中，我们使用了 <code>extends</code> 约束了泛型 <code>T</code> 必须符合接口 <code>Lengthwise</code> 的形状，也就是必须包含 <code>length</code> 属性。</p>\n<p>此时如果调用 <code>loggingIdentity</code> 的时候，传入的 <code>arg</code> 不包含 <code>length</code>，那么在编译阶段就会报错了：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface Lengthwise &#123;\n    length: number;\n&#125;\n\nfunction loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;\n    console.log(arg.length);\n    return arg;\n&#125;\n\nloggingIdentity(7);\n\n&#x2F;&#x2F; index.ts(10,17): error TS2345: Argument of type &#39;7&#39; is not assignable to parameter of type &#39;Lengthwise&#39;.</code></pre>\n\n<p>多个类型参数之间也可以互相约束：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function copyFields&lt;T extends U, U&gt;(target: T, source: U): T &#123;\n    for (let id in source) &#123;\n        target[id] &#x3D; (&lt;T&gt;source)[id];\n    &#125;\n    return target;\n&#125;\n\nlet x &#x3D; &#123; a: 1, b: 2, c: 3, d: 4 &#125;;\n\ncopyFields(x, &#123; b: 10, d: 20 &#125;);</code></pre>\n\n<p>上例中，我们使用了两个类型参数，其中要求 <code>T</code> 继承 <code>U</code>，这样就保证了 <code>U</code> 上不会出现 <code>T</code> 中不存在的字段。</p>\n<h2 id=\"泛型接口\"><a href=\"#泛型接口\" class=\"headerlink\" title=\"泛型接口\"></a>泛型接口</h2><p><a href=\"https://ts.xcatliu.com/basics/type-of-function.html#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89\">之前学习过</a>，可以使用接口的方式来定义一个函数需要符合的形状：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface SearchFunc &#123;\n  (source: string, subString: string): boolean;\n&#125;\n\nlet mySearch: SearchFunc;\nmySearch &#x3D; function(source: string, subString: string) &#123;\n    return source.search(subString) !&#x3D;&#x3D; -1;\n&#125;</code></pre>\n\n<p>当然也可以使用含有泛型的接口来定义函数的形状：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface CreateArrayFunc &#123;\n    &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;\n&#125;\n\nlet createArray: CreateArrayFunc;\ncreateArray &#x3D; function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;\n    let result: T[] &#x3D; [];\n    for (let i &#x3D; 0; i &lt; length; i++) &#123;\n        result[i] &#x3D; value;\n    &#125;\n    return result;\n&#125;\n\ncreateArray(3, &#39;x&#39;); &#x2F;&#x2F; [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]</code></pre>\n\n<p>进一步，我们可以把泛型参数提前到接口名上：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">interface CreateArrayFunc&lt;T&gt; &#123;\n    (length: number, value: T): Array&lt;T&gt;;\n&#125;\n\nlet createArray: CreateArrayFunc&lt;any&gt;;\ncreateArray &#x3D; function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;\n    let result: T[] &#x3D; [];\n    for (let i &#x3D; 0; i &lt; length; i++) &#123;\n        result[i] &#x3D; value;\n    &#125;\n    return result;\n&#125;\n\ncreateArray(3, &#39;x&#39;); &#x2F;&#x2F; [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]</code></pre>\n\n<p>注意，此时在使用泛型接口的时候，需要定义泛型的类型。</p>\n<h2 id=\"泛型类\"><a href=\"#泛型类\" class=\"headerlink\" title=\"泛型类\"></a>泛型类</h2><p>与泛型接口类似，泛型也可以用于类的类型定义中：</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">class GenericNumber&lt;T&gt; &#123;\n    zeroValue: T;\n    add: (x: T, y: T) &#x3D;&gt; T;\n&#125;\n\nlet myGenericNumber &#x3D; new GenericNumber&lt;number&gt;();\nmyGenericNumber.zeroValue &#x3D; 0;\nmyGenericNumber.add &#x3D; function(x, y) &#123; return x + y; &#125;;</code></pre>\n\n<h2 id=\"泛型参数的默认类型\"><a href=\"#泛型参数的默认类型\" class=\"headerlink\" title=\"泛型参数的默认类型\"></a>泛型参数的默认类型</h2><p>在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function createArray&lt;T &#x3D; string&gt;(length: number, value: T): Array&lt;T&gt; &#123;\n    let result: T[] &#x3D; [];\n    for (let i &#x3D; 0; i &lt; length; i++) &#123;\n        result[i] &#x3D; value;\n    &#125;\n    return result;\n&#125;</code></pre>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.typescriptlang.org/docs/handbook/generics.html\">Generics</a>（<a href=\"https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/generics.html\">中文版</a>）</li>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html#generic-parameter-defaults\">Generic parameter defaults</a></li>\n</ul>\n","feature":true,"text":"泛型泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 简单的例子首先，我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值： function createArra...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"TypeScript入门","slug":"TypeScript入门","count":19,"path":"api/categories/TypeScript入门.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":22,"path":"api/tags/TypeScript.json"},{"name":"进阶","slug":"进阶","count":8,"path":"api/tags/进阶.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B\"><span class=\"toc-text\">泛型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">简单的例子</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E4%B8%AA%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">多个类型参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F\"><span class=\"toc-text\">泛型约束</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">泛型接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E7%B1%BB\"><span class=\"toc-text\">泛型类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">泛型参数的默认类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83\"><span class=\"toc-text\">参考</span></a></li></ol></li></ol>","author":{"name":"木木木","slug":"blog-author","avatar":"https://homeimage.hoiyee.net/lbs/2023-1-3/ywa8wim0wn_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230103144606.jpg","link":"/","description":"一位正在重塑和新增知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"进阶 - 声明合并","uid":"bb9a845fbb318ca0c43a367531668643","slug":"typescript/进阶/声明合并","date":"2023-01-13T06:56:55.700Z","updated":"2023-01-13T07:12:52.754Z","comments":true,"path":"api/articles/typescript/进阶/声明合并.json","keywords":null,"cover":"https://api.onedrive.com/v1.0/shares/s!AkvcybxHlBS0kAEgrAsbNR5Gj39i/root/content","text":"声明合并如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型： 函数的合并之前学习过，我们可以使用重载定义多个函数类型： function reverse(x: number): number; function reverse(x: string): string;...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"TypeScript入门","slug":"TypeScript入门","count":19,"path":"api/categories/TypeScript入门.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":22,"path":"api/tags/TypeScript.json"},{"name":"进阶","slug":"进阶","count":8,"path":"api/tags/进阶.json"}],"author":{"name":"木木木","slug":"blog-author","avatar":"https://homeimage.hoiyee.net/lbs/2023-1-3/ywa8wim0wn_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230103144606.jpg","link":"/","description":"一位正在重塑和新增知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"进阶 - 类与接口","uid":"d98d9110fe663f18e58e01638df35f52","slug":"typescript/进阶/类与接口","date":"2023-01-13T06:23:15.936Z","updated":"2023-01-13T06:24:52.045Z","comments":true,"path":"api/articles/typescript/进阶/类与接口.json","keywords":null,"cover":"https://api.onedrive.com/v1.0/shares/s!AkvcybxHlBS0kAEgrAsbNR5Gj39i/root/content","text":"类与接口之前学习过，接口（Interfaces）可以用于对「对象的形状（Shape）」进行描述。 这一章主要介绍接口的另一个用途，对类的一部分行为进行抽象。 类实现接口实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"TypeScript入门","slug":"TypeScript入门","count":19,"path":"api/categories/TypeScript入门.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":22,"path":"api/tags/TypeScript.json"},{"name":"进阶","slug":"进阶","count":8,"path":"api/tags/进阶.json"}],"author":{"name":"木木木","slug":"blog-author","avatar":"https://homeimage.hoiyee.net/lbs/2023-1-3/ywa8wim0wn_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230103144606.jpg","link":"/","description":"一位正在重塑和新增知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}